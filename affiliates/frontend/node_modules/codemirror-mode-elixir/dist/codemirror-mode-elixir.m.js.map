{"version":3,"file":"codemirror-mode-elixir.m.js","sources":["../index.js"],"sourcesContent":["// CodeMirror Mode Elixir, copyright (c) by Marijn Haverbeke, Ian Walter, and\n// others. Distributed under an MIT license: http://codemirror.net/LICENSE.\nimport CodeMirror from 'codemirror'\n\nCodeMirror.defineMode('elixir', config => {\n  const wordObj = words => {\n    let o = {}\n    for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true\n    return o\n  }\n\n  const keywords = wordObj([\n    'alias', 'case', 'cond', 'def', 'defmodule', 'defp', 'defstruct',\n    'defprotocol', 'defimpl', 'defmacro', 'quote', 'unquote', 'receive', 'fn',\n    'do', 'else', 'else if', 'end', 'false', 'if', 'in', 'next', 'rescue',\n    'for', 'true', 'unless', 'when', 'nil', 'raise', 'throw', 'try', 'catch',\n    'after', 'with', 'require', 'use', '__MODULE__', '__FILE__', '__DIR__',\n    '__ENV__', '__CALLER__'\n  ])\n  const indentWords = wordObj([\n    'def', 'defmodule', 'defp', 'case', 'cond', 'rescue', 'try', 'catch', '->'\n  ])\n  const dedentWords = wordObj(['end'])\n  const matching = {'[': ']', '{': '}', '(': ')'}\n\n  let curPunc\n\n  const chain = (newtok, stream, state) => {\n    state.tokenize.push(newtok)\n    return newtok(stream, state)\n  }\n\n  const tokenBase = (stream, state) => {\n    if (stream.sol() && stream.match('\"\"\"') && stream.eol()) {\n      state.tokenize.push(readBlockComment)\n      return 'comment'\n    }\n\n    if (stream.eatSpace()) {\n      return null\n    }\n\n    let ch = stream.next()\n    let m\n\n    if (ch === '\\'' || ch === '\"') {\n      return chain(readQuoted(ch, 'string', ch === '\"'), stream, state)\n    } else if (ch === '/') {\n      let currentIndex = stream.current().length\n      if (stream.skipTo('/')) {\n        let searchTill = stream.current().length\n        let balance = 0  // balance brackets\n\n        stream.backUp(stream.current().length - currentIndex)\n\n        while (stream.current().length < searchTill) {\n          const chchr = stream.next()\n          if (chchr === '(') {\n            balance += 1\n          } else if (chchr === ')') {\n            balance -= 1\n          }\n          if (balance < 0) {\n            break\n          }\n        }\n\n        stream.backUp(stream.current().length - currentIndex)\n\n        if (balance === 0) {\n          return chain(readQuoted(ch, 'string-2', true), stream, state)\n        }\n      }\n\n      return 'operator'\n    } else if (ch === '%') {\n      let style = 'string'\n      let embed = true\n\n      if (stream.eat('s')) {\n        style = 'atom'\n      } else if (stream.eat(/[WQ]/)) {\n        style = 'string'\n      } else if (stream.eat(/[r]/)) {\n        style = 'string-2'\n      } else if (stream.eat(/[wxq]/)) {\n        style = 'string'\n        embed = false\n      }\n\n      let delim = stream.eat(/[^\\w\\s=]/)\n\n      if (!delim) {\n        return 'operator'\n      }\n\n      if (matching.propertyIsEnumerable(delim)) {\n        delim = matching[delim]\n      }\n\n      return chain(readQuoted(delim, style, embed, true), stream, state)\n    } else if (ch === '#') {\n      stream.skipToEnd()\n      return 'comment'\n    } else if (\n      ch === '<' &&\n      (m = stream.match(/^<-?[\\`\\\"\\']?([a-zA-Z_?]\\w*)[\\`\\\"\\']?(?:;|$)/))\n    ) {\n      return chain(readHereDoc(m[1]), stream, state)\n    } else if (ch === '0') {\n      if (stream.eat('x')) {\n        stream.eatWhile(/[\\da-fA-F]/)\n      } else if (stream.eat('b')) {\n        stream.eatWhile(/[01]/)\n      } else {\n        stream.eatWhile(/[0-7]/)\n      }\n      return 'number'\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+\\-]?[\\d_]+)?/)\n      return 'number'\n    } else if (ch === '?') {\n      while (stream.match(/^\\\\[CM]-/)) {}\n\n      if (stream.eat('\\\\')) {\n        stream.eatWhile(/\\w/)\n      } else {\n        stream.next()\n      }\n      return 'string'\n    } else if (ch === ':') {\n      if (stream.eat('\\'')) {\n        return chain(readQuoted('\\'', 'atom', false), stream, state)\n      }\n      if (stream.eat('\"')) {\n        return chain(readQuoted('\"', 'atom', true), stream, state)\n      }\n\n      // :> :>> :< :<< are valid symbols\n      if (stream.eat(/[\\<\\>]/)) {\n        stream.eat(/[\\<\\>]/)\n        return 'atom'\n      }\n\n      // :+ :- :/ :* :| :& :! are valid symbols\n      if (stream.eat(/[\\+\\-\\*\\/\\&\\|\\:\\!]/)) {\n        return 'atom'\n      }\n\n      // Symbols can't start by a digit\n      if (stream.eat(/[a-zA-Z$@_\\xa1-\\uffff]/)) {\n        stream.eatWhile(/[\\w$\\xa1-\\uffff]/)\n        // Only one ? ! = is allowed and only as the last character\n        stream.eat(/[\\?\\!\\=]/)\n        return 'atom'\n      }\n\n      return 'operator'\n    } else if (ch === '@' && stream.match(/^@?[a-zA-Z_\\xa1-\\uffff]/)) {\n      stream.eat('@')\n      stream.eatWhile(/[\\w\\xa1-\\uffff]/)\n      return 'variable-2'\n    } else if (ch === '$') {\n      if (stream.eat(/[a-zA-Z_]/)) {\n        stream.eatWhile(/[\\w]/)\n      } else if (stream.eat(/\\d/)) {\n        stream.eat(/\\d/)\n      } else {\n        stream.next() // Must be a special global like $: or $!\n      }\n      return 'variable-3'\n    } else if (/[a-zA-Z_\\xa1-\\uffff]/.test(ch)) {\n      stream.eatWhile(/[\\w\\xa1-\\uffff]/)\n      stream.eat(/[\\?\\!]/)\n      if (stream.eat(':')) {\n        return 'atom'\n      }\n      return 'ident'\n    } else if (\n      ch === '|' &&\n      (state.varList || state.lastTok === '{' || state.lastTok === 'do')\n    ) {\n      curPunc = '|'\n      return null\n    } else if (/[\\(\\)\\[\\]{}\\\\;]/.test(ch)) {\n      curPunc = ch\n      return null\n    } else if (ch === '-' && stream.eat('>')) {\n      return 'arrow'\n    } else if (ch === '|' && stream.eat('>')) {\n      return 'pipe'\n    } else if (/[=+\\-\\/*:\\.^%<>~|]/.test(ch)) {\n      if (ch === '.' && !stream.eatWhile(/[=+\\-\\/*:\\.^%<>~|]/)) {\n        curPunc = '.'\n      }\n      return 'operator'\n    } else {\n      return null\n    }\n  }\n\n  const tokenBaseUntilBrace = depth => {\n    if (!depth) {\n      depth = 1\n    }\n\n    return (stream, state) => {\n      if (stream.peek() === '}') {\n        if (depth === 1) {\n          state.tokenize.pop()\n          return state.tokenize[state.tokenize.length - 1](stream, state)\n        } else {\n          state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth - 1)\n        }\n      } else if (stream.peek() === '{') {\n        state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth + 1)\n      }\n      return tokenBase(stream, state)\n    }\n  }\n\n  const tokenBaseOnce = () => {\n    let alreadyCalled = false\n    return (stream, state) => {\n      if (alreadyCalled) {\n        state.tokenize.pop()\n        return state.tokenize[state.tokenize.length - 1](stream, state)\n      }\n      alreadyCalled = true\n      return tokenBase(stream, state)\n    }\n  }\n\n  const readQuoted = (quote, style, embed, unescaped) => {\n    return (stream, state) => {\n      let escaped = false\n      let ch\n\n      if (state.context.type === 'read-quoted-paused') {\n        state.context = state.context.prev\n        stream.eat('}')\n      }\n\n      while ((ch = stream.next()) != null) { // eslint-disable-line\n        if (ch === quote && (unescaped || !escaped)) {\n          state.tokenize.pop()\n          break\n        }\n\n        if (embed && ch === '#' && !escaped) {\n          if (stream.eat('{')) {\n            if (quote === '}') {\n              state.context = {prev: state.context, type: 'read-quoted-paused'}\n            }\n            state.tokenize.push(tokenBaseUntilBrace())\n            break\n          } else if (/[@\\$]/.test(stream.peek())) {\n            state.tokenize.push(tokenBaseOnce())\n            break\n          }\n        }\n\n        escaped = !escaped && ch === '\\\\'\n      }\n\n      return style\n    }\n  }\n\n  const readHereDoc = phrase => {\n    return (stream, state) => {\n      if (stream.match(phrase)) {\n        state.tokenize.pop()\n      } else {\n        stream.skipToEnd()\n      }\n      return 'string'\n    }\n  }\n\n  const readBlockComment = (stream, state) => {\n    if (stream.sol() && stream.match('\"\"\"') && stream.eol()) {\n      state.tokenize.pop()\n    }\n    stream.skipToEnd()\n    return 'comment'\n  }\n\n  return {\n    startState: () => {\n      return {\n        tokenize: [tokenBase],\n        indented: 0,\n        context: {type: 'top', indented: -config.indentUnit},\n        continuedLine: false,\n        lastTok: null,\n        varList: false\n      }\n    },\n    token: (stream, state) => {\n      curPunc = null\n\n      // if (stream.sol()) {\n      //   state.indented = stream.indentation()\n      // }\n\n      let style = state.tokenize[state.tokenize.length - 1](stream, state)\n      let kwtype\n      let thisTok = curPunc\n\n      if (style === 'ident') {\n        let word = stream.current()\n\n        style = state.lastTok === '.' ? 'property'\n          : keywords.propertyIsEnumerable(stream.current()) ? 'keyword'\n          : /^[A-Z]/.test(word) ? 'tag'\n          : (state.lastTok === 'def' || state.lastTok === 'class' || state.varList) ? 'def'\n          : 'variable'\n\n        const isColumnIndent = stream.column() === stream.indentation()\n        if (style === 'keyword') {\n          thisTok = word\n          if (indentWords.propertyIsEnumerable(word)) {\n            kwtype = 'indent'\n          } else if (dedentWords.propertyIsEnumerable(word)) {\n            kwtype = 'dedent'\n          } else if ((word === 'if' || word === 'unless') && isColumnIndent) {\n            kwtype = 'indent'\n          } else if (word === 'do' && state.context.indented < state.indented) {\n            kwtype = 'indent'\n          }\n        }\n      }\n\n      if (curPunc || (style && style !== 'comment')) {\n        state.lastTok = thisTok\n      }\n\n      if (curPunc === '|') {\n        state.varList = !state.varList\n      }\n\n      if (kwtype === 'indent' || /[\\(\\[\\{]/.test(curPunc)) {\n        state.context = {\n          prev: state.context,\n          type: curPunc || style,\n          indented: state.indented\n        }\n      } else if (\n        (kwtype === 'dedent' || /[\\)\\]\\}]/.test(curPunc)) &&\n        state.context.prev\n      ) {\n        state.context = state.context.prev\n      }\n\n      if (stream.eol()) {\n        state.continuedLine = (curPunc === '\\\\' || style === 'operator')\n      }\n\n      return style\n    },\n    // indent: (state, textAfter) => {\n    //   if (state.tokenize[state.tokenize.length - 1] !== tokenBase) {\n    //     return 0\n    //   }\n    //   let firstChar = textAfter && textAfter.charAt(0)\n    //   let ct = state.context\n    //   let closing = ct.type === matching[firstChar] ||\n    //     ct.type === 'keyword' && /^(?:end|until|else|else if|when|rescue)\\b/.test(textAfter)\n    //   return ct.indented + (closing ? 0 : config.indentUnit) +\n    //     (state.continuedLine ? config.indentUnit : 0)\n    // },\n    electricInput: /^\\s*(?:end|rescue|else if|else|catch\\})$/,\n    lineComment: '#'\n  }\n})\n\nCodeMirror.defineMIME('text/x-elixir', 'elixir')\n"],"names":["CodeMirror","defineMode","config","const","curPunc","wordObj","words","let","o","i","e","length","keywords","indentWords","dedentWords","matching","[","{","(","chain","newtok","stream","state","tokenize","push","tokenBase","sol","match","eol","readBlockComment","eatSpace","m","ch","next","readQuoted","currentIndex","current","skipTo","searchTill","balance","backUp","chchr","style","embed","eat","delim","propertyIsEnumerable","skipToEnd","readHereDoc","eatWhile","test","varList","lastTok","tokenBaseUntilBrace","depth","peek","pop","tokenBaseOnce","alreadyCalled","quote","unescaped","escaped","context","type","prev","phrase","startState","indented","indentUnit","continuedLine","token","kwtype","thisTok","word","isColumnIndent","column","indentation","electricInput","lineComment","defineMIME"],"mappings":"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"}