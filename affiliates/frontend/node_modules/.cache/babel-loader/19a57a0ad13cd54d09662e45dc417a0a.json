{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n// Modelica support for CodeMirror, copyright (c) by Lennart Ochel\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"modelica\", function (config, parserConfig) {\n    var indentUnit = config.indentUnit;\n    var keywords = parserConfig.keywords || {};\n    var builtin = parserConfig.builtin || {};\n    var atoms = parserConfig.atoms || {};\n    var isSingleOperatorChar = /[;=\\(:\\),{}.*<>+\\-\\/^\\[\\]]/;\n    var isDoubleOperatorChar = /(:=|<=|>=|==|<>|\\.\\+|\\.\\-|\\.\\*|\\.\\/|\\.\\^)/;\n    var isDigit = /[0-9]/;\n    var isNonDigit = /[_a-zA-Z]/;\n\n    function tokenLineComment(stream, state) {\n      stream.skipToEnd();\n      state.tokenize = null;\n      return \"comment\";\n    }\n\n    function tokenBlockComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (maybeEnd && ch == \"/\") {\n          state.tokenize = null;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function tokenString(stream, state) {\n      var escaped = false,\n          ch;\n\n      while ((ch = stream.next()) != null) {\n        if (ch == '\"' && !escaped) {\n          state.tokenize = null;\n          state.sol = false;\n          break;\n        }\n\n        escaped = !escaped && ch == \"\\\\\";\n      }\n\n      return \"string\";\n    }\n\n    function tokenIdent(stream, state) {\n      stream.eatWhile(isDigit);\n\n      while (stream.eat(isDigit) || stream.eat(isNonDigit)) {}\n\n      var cur = stream.current();\n      if (state.sol && (cur == \"package\" || cur == \"model\" || cur == \"when\" || cur == \"connector\")) state.level++;else if (state.sol && cur == \"end\" && state.level > 0) state.level--;\n      state.tokenize = null;\n      state.sol = false;\n      if (keywords.propertyIsEnumerable(cur)) return \"keyword\";else if (builtin.propertyIsEnumerable(cur)) return \"builtin\";else if (atoms.propertyIsEnumerable(cur)) return \"atom\";else return \"variable\";\n    }\n\n    function tokenQIdent(stream, state) {\n      while (stream.eat(/[^']/)) {}\n\n      state.tokenize = null;\n      state.sol = false;\n      if (stream.eat(\"'\")) return \"variable\";else return \"error\";\n    }\n\n    function tokenUnsignedNuber(stream, state) {\n      stream.eatWhile(isDigit);\n\n      if (stream.eat('.')) {\n        stream.eatWhile(isDigit);\n      }\n\n      if (stream.eat('e') || stream.eat('E')) {\n        if (!stream.eat('-')) stream.eat('+');\n        stream.eatWhile(isDigit);\n      }\n\n      state.tokenize = null;\n      state.sol = false;\n      return \"number\";\n    } // Interface\n\n\n    return {\n      startState: function startState() {\n        return {\n          tokenize: null,\n          level: 0,\n          sol: true\n        };\n      },\n      token: function token(stream, state) {\n        if (state.tokenize != null) {\n          return state.tokenize(stream, state);\n        }\n\n        if (stream.sol()) {\n          state.sol = true;\n        } // WHITESPACE\n\n\n        if (stream.eatSpace()) {\n          state.tokenize = null;\n          return null;\n        }\n\n        var ch = stream.next(); // LINECOMMENT\n\n        if (ch == '/' && stream.eat('/')) {\n          state.tokenize = tokenLineComment;\n        } // BLOCKCOMMENT\n        else if (ch == '/' && stream.eat('*')) {\n            state.tokenize = tokenBlockComment;\n          } // TWO SYMBOL TOKENS\n          else if (isDoubleOperatorChar.test(ch + stream.peek())) {\n              stream.next();\n              state.tokenize = null;\n              return \"operator\";\n            } // SINGLE SYMBOL TOKENS\n            else if (isSingleOperatorChar.test(ch)) {\n                state.tokenize = null;\n                return \"operator\";\n              } // IDENT\n              else if (isNonDigit.test(ch)) {\n                  state.tokenize = tokenIdent;\n                } // Q-IDENT\n                else if (ch == \"'\" && stream.peek() && stream.peek() != \"'\") {\n                    state.tokenize = tokenQIdent;\n                  } // STRING\n                  else if (ch == '\"') {\n                      state.tokenize = tokenString;\n                    } // UNSIGNED_NUBER\n                    else if (isDigit.test(ch)) {\n                        state.tokenize = tokenUnsignedNuber;\n                      } // ERROR\n                      else {\n                          state.tokenize = null;\n                          return \"error\";\n                        }\n\n        return state.tokenize(stream, state);\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != null) return CodeMirror.Pass;\n        var level = state.level;\n        if (/(algorithm)/.test(textAfter)) level--;\n        if (/(equation)/.test(textAfter)) level--;\n        if (/(initial algorithm)/.test(textAfter)) level--;\n        if (/(initial equation)/.test(textAfter)) level--;\n        if (/(end)/.test(textAfter)) level--;\n        if (level > 0) return indentUnit * level;else return 0;\n      },\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\"\n    };\n  });\n\n  function words(str) {\n    var obj = {},\n        words = str.split(\" \");\n\n    for (var i = 0; i < words.length; ++i) {\n      obj[words[i]] = true;\n    }\n\n    return obj;\n  }\n\n  var modelicaKeywords = \"algorithm and annotation assert block break class connect connector constant constrainedby der discrete each else elseif elsewhen encapsulated end enumeration equation expandable extends external false final flow for function if import impure in initial inner input loop model not operator or outer output package parameter partial protected public pure record redeclare replaceable return stream then true type when while within\";\n  var modelicaBuiltin = \"abs acos actualStream asin atan atan2 cardinality ceil cos cosh delay div edge exp floor getInstanceName homotopy inStream integer log log10 mod pre reinit rem semiLinear sign sin sinh spatialDistribution sqrt tan tanh\";\n  var modelicaAtoms = \"Real Boolean Integer String\";\n\n  function def(mimes, mode) {\n    if (typeof mimes == \"string\") mimes = [mimes];\n    var words = [];\n\n    function add(obj) {\n      if (obj) for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) words.push(prop);\n      }\n    }\n\n    add(mode.keywords);\n    add(mode.builtin);\n    add(mode.atoms);\n\n    if (words.length) {\n      mode.helperType = mimes[0];\n      CodeMirror.registerHelper(\"hintWords\", mimes[0], words);\n    }\n\n    for (var i = 0; i < mimes.length; ++i) {\n      CodeMirror.defineMIME(mimes[i], mode);\n    }\n  }\n\n  def([\"text/x-modelica\"], {\n    name: \"modelica\",\n    keywords: words(modelicaKeywords),\n    builtin: words(modelicaBuiltin),\n    atoms: words(modelicaAtoms)\n  });\n});","map":null,"metadata":{},"sourceType":"script"}