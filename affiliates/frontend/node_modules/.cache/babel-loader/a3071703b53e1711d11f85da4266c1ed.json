{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode('smalltalk', function (config) {\n    var specialChars = /[+\\-\\/\\\\*~<>=@%|&?!.,:;^]/;\n    var keywords = /true|false|nil|self|super|thisContext/;\n\n    var Context = function Context(tokenizer, parent) {\n      this.next = tokenizer;\n      this.parent = parent;\n    };\n\n    var Token = function Token(name, context, eos) {\n      this.name = name;\n      this.context = context;\n      this.eos = eos;\n    };\n\n    var State = function State() {\n      this.context = new Context(next, null);\n      this.expectVariable = true;\n      this.indentation = 0;\n      this.userIndentationDelta = 0;\n    };\n\n    State.prototype.userIndent = function (indentation) {\n      this.userIndentationDelta = indentation > 0 ? indentation / config.indentUnit - this.indentation : 0;\n    };\n\n    var next = function next(stream, context, state) {\n      var token = new Token(null, context, false);\n      var aChar = stream.next();\n\n      if (aChar === '\"') {\n        token = nextComment(stream, new Context(nextComment, context));\n      } else if (aChar === '\\'') {\n        token = nextString(stream, new Context(nextString, context));\n      } else if (aChar === '#') {\n        if (stream.peek() === '\\'') {\n          stream.next();\n          token = nextSymbol(stream, new Context(nextSymbol, context));\n        } else {\n          if (stream.eatWhile(/[^\\s.{}\\[\\]()]/)) token.name = 'string-2';else token.name = 'meta';\n        }\n      } else if (aChar === '$') {\n        if (stream.next() === '<') {\n          stream.eatWhile(/[^\\s>]/);\n          stream.next();\n        }\n\n        token.name = 'string-2';\n      } else if (aChar === '|' && state.expectVariable) {\n        token.context = new Context(nextTemporaries, context);\n      } else if (/[\\[\\]{}()]/.test(aChar)) {\n        token.name = 'bracket';\n        token.eos = /[\\[{(]/.test(aChar);\n\n        if (aChar === '[') {\n          state.indentation++;\n        } else if (aChar === ']') {\n          state.indentation = Math.max(0, state.indentation - 1);\n        }\n      } else if (specialChars.test(aChar)) {\n        stream.eatWhile(specialChars);\n        token.name = 'operator';\n        token.eos = aChar !== ';'; // ; cascaded message expression\n      } else if (/\\d/.test(aChar)) {\n        stream.eatWhile(/[\\w\\d]/);\n        token.name = 'number';\n      } else if (/[\\w_]/.test(aChar)) {\n        stream.eatWhile(/[\\w\\d_]/);\n        token.name = state.expectVariable ? keywords.test(stream.current()) ? 'keyword' : 'variable' : null;\n      } else {\n        token.eos = state.expectVariable;\n      }\n\n      return token;\n    };\n\n    var nextComment = function nextComment(stream, context) {\n      stream.eatWhile(/[^\"]/);\n      return new Token('comment', stream.eat('\"') ? context.parent : context, true);\n    };\n\n    var nextString = function nextString(stream, context) {\n      stream.eatWhile(/[^']/);\n      return new Token('string', stream.eat('\\'') ? context.parent : context, false);\n    };\n\n    var nextSymbol = function nextSymbol(stream, context) {\n      stream.eatWhile(/[^']/);\n      return new Token('string-2', stream.eat('\\'') ? context.parent : context, false);\n    };\n\n    var nextTemporaries = function nextTemporaries(stream, context) {\n      var token = new Token(null, context, false);\n      var aChar = stream.next();\n\n      if (aChar === '|') {\n        token.context = context.parent;\n        token.eos = true;\n      } else {\n        stream.eatWhile(/[^|]/);\n        token.name = 'variable';\n      }\n\n      return token;\n    };\n\n    return {\n      startState: function startState() {\n        return new State();\n      },\n      token: function token(stream, state) {\n        state.userIndent(stream.indentation());\n\n        if (stream.eatSpace()) {\n          return null;\n        }\n\n        var token = state.context.next(stream, state.context, state);\n        state.context = token.context;\n        state.expectVariable = token.eos;\n        return token.name;\n      },\n      blankLine: function blankLine(state) {\n        state.userIndent(0);\n      },\n      indent: function indent(state, textAfter) {\n        var i = state.context.next === next && textAfter && textAfter.charAt(0) === ']' ? -1 : state.userIndentationDelta;\n        return (state.indentation + i) * config.indentUnit;\n      },\n      electricChars: ']'\n    };\n  });\n  CodeMirror.defineMIME('text/x-stsrc', {\n    name: 'smalltalk'\n  });\n});","map":null,"metadata":{},"sourceType":"script"}