{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar CharacterStream = function () {\n  function CharacterStream(sourceText) {\n    var _this = this;\n\n    _classCallCheck(this, CharacterStream);\n\n    this.getStartOfToken = function () {\n      return _this._start;\n    };\n\n    this.getCurrentPosition = function () {\n      return _this._pos;\n    };\n\n    this.eol = function () {\n      return _this._sourceText.length === _this._pos;\n    };\n\n    this.sol = function () {\n      return _this._pos === 0;\n    };\n\n    this.peek = function () {\n      return _this._sourceText.charAt(_this._pos) ? _this._sourceText.charAt(_this._pos) : null;\n    };\n\n    this.next = function () {\n      var char = _this._sourceText.charAt(_this._pos);\n\n      _this._pos++;\n      return char;\n    };\n\n    this.eat = function (pattern) {\n      var isMatched = _this._testNextCharacter(pattern);\n\n      if (isMatched) {\n        _this._start = _this._pos;\n        _this._pos++;\n        return _this._sourceText.charAt(_this._pos - 1);\n      }\n\n      return undefined;\n    };\n\n    this.eatWhile = function (match) {\n      var isMatched = _this._testNextCharacter(match);\n\n      var didEat = false; // If a match, treat the total upcoming matches as one token\n\n      if (isMatched) {\n        didEat = isMatched;\n        _this._start = _this._pos;\n      }\n\n      while (isMatched) {\n        _this._pos++;\n        isMatched = _this._testNextCharacter(match);\n        didEat = true;\n      }\n\n      return didEat;\n    };\n\n    this.eatSpace = function () {\n      return _this.eatWhile(/[\\s\\u00a0]/);\n    };\n\n    this.skipToEnd = function () {\n      _this._pos = _this._sourceText.length;\n    };\n\n    this.skipTo = function (position) {\n      _this._pos = position;\n    };\n\n    this.match = function (pattern) {\n      var consume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var caseFold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var token = null;\n      var match = null;\n\n      if (typeof pattern === 'string') {\n        var regex = new RegExp(pattern, caseFold ? 'i' : 'g');\n        match = regex.test(_this._sourceText.substr(_this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = _this._sourceText.slice(_this._pos).match(pattern);\n        token = match && match[0];\n      }\n\n      if (match != null) {\n        if (typeof pattern === 'string' || match instanceof Array && // String.match returns 'index' property, which flow fails to detect\n        // for some reason. The below is a workaround, but an easier solution\n        // is just checking if `match.index === 0`\n        _this._sourceText.startsWith(match[0], _this._pos)) {\n          if (consume) {\n            _this._start = _this._pos;\n\n            if (token && token.length) {\n              _this._pos += token.length;\n            }\n          }\n\n          return match;\n        }\n      } // No match available.\n\n\n      return false;\n    };\n\n    this.backUp = function (num) {\n      _this._pos -= num;\n    };\n\n    this.column = function () {\n      return _this._pos;\n    };\n\n    this.indentation = function () {\n      var match = _this._sourceText.match(/\\s*/);\n\n      var indent = 0;\n\n      if (match && match.length === 0) {\n        var whitespaces = match[0];\n        var pos = 0;\n\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n\n          pos++;\n        }\n      }\n\n      return indent;\n    };\n\n    this.current = function () {\n      return _this._sourceText.slice(_this._start, _this._pos);\n    };\n\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n\n  CharacterStream.prototype._testNextCharacter = function _testNextCharacter(pattern) {\n    var character = this._sourceText.charAt(this._pos);\n\n    var isMatched = false;\n\n    if (typeof pattern === 'string') {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n\n    return isMatched;\n  };\n\n  return CharacterStream;\n}();\n/**\n *  Copyright (c) Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  \n */\n\n/**\n * CharacterStream implements a stream of character tokens given a source text.\n * The API design follows that of CodeMirror.StringStream.\n *\n * Required:\n *\n *      sourceText: (string), A raw GraphQL source text. Works best if a line\n *        is supplied.\n *\n */\n\n\nexports.default = CharacterStream;","map":null,"metadata":{},"sourceType":"script"}