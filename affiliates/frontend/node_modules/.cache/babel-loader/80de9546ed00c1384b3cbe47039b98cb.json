{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.multiplexingMode = function (outer\n  /*, others */\n  ) {\n    // Others should be {open, close, mode [, delimStyle] [, innerStyle]} objects\n    var others = Array.prototype.slice.call(arguments, 1);\n\n    function indexOf(string, pattern, from, returnEnd) {\n      if (typeof pattern == \"string\") {\n        var found = string.indexOf(pattern, from);\n        return returnEnd && found > -1 ? found + pattern.length : found;\n      }\n\n      var m = pattern.exec(from ? string.slice(from) : string);\n      return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;\n    }\n\n    return {\n      startState: function startState() {\n        return {\n          outer: CodeMirror.startState(outer),\n          innerActive: null,\n          inner: null\n        };\n      },\n      copyState: function copyState(state) {\n        return {\n          outer: CodeMirror.copyState(outer, state.outer),\n          innerActive: state.innerActive,\n          inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner)\n        };\n      },\n      token: function token(stream, state) {\n        if (!state.innerActive) {\n          var cutOff = Infinity,\n              oldContent = stream.string;\n\n          for (var i = 0; i < others.length; ++i) {\n            var other = others[i];\n            var found = indexOf(oldContent, other.open, stream.pos);\n\n            if (found == stream.pos) {\n              if (!other.parseDelimiters) stream.match(other.open);\n              state.innerActive = other; // Get the outer indent, making sure to handle CodeMirror.Pass\n\n              var outerIndent = 0;\n\n              if (outer.indent) {\n                var possibleOuterIndent = outer.indent(state.outer, \"\", \"\");\n                if (possibleOuterIndent !== CodeMirror.Pass) outerIndent = possibleOuterIndent;\n              }\n\n              state.inner = CodeMirror.startState(other.mode, outerIndent);\n              return other.delimStyle && other.delimStyle + \" \" + other.delimStyle + \"-open\";\n            } else if (found != -1 && found < cutOff) {\n              cutOff = found;\n            }\n          }\n\n          if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);\n          var outerToken = outer.token(stream, state.outer);\n          if (cutOff != Infinity) stream.string = oldContent;\n          return outerToken;\n        } else {\n          var curInner = state.innerActive,\n              oldContent = stream.string;\n\n          if (!curInner.close && stream.sol()) {\n            state.innerActive = state.inner = null;\n            return this.token(stream, state);\n          }\n\n          var found = curInner.close ? indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;\n\n          if (found == stream.pos && !curInner.parseDelimiters) {\n            stream.match(curInner.close);\n            state.innerActive = state.inner = null;\n            return curInner.delimStyle && curInner.delimStyle + \" \" + curInner.delimStyle + \"-close\";\n          }\n\n          if (found > -1) stream.string = oldContent.slice(0, found);\n          var innerToken = curInner.mode.token(stream, state.inner);\n          if (found > -1) stream.string = oldContent;\n          if (found == stream.pos && curInner.parseDelimiters) state.innerActive = state.inner = null;\n\n          if (curInner.innerStyle) {\n            if (innerToken) innerToken = innerToken + \" \" + curInner.innerStyle;else innerToken = curInner.innerStyle;\n          }\n\n          return innerToken;\n        }\n      },\n      indent: function indent(state, textAfter, line) {\n        var mode = state.innerActive ? state.innerActive.mode : outer;\n        if (!mode.indent) return CodeMirror.Pass;\n        return mode.indent(state.innerActive ? state.inner : state.outer, textAfter, line);\n      },\n      blankLine: function blankLine(state) {\n        var mode = state.innerActive ? state.innerActive.mode : outer;\n\n        if (mode.blankLine) {\n          mode.blankLine(state.innerActive ? state.inner : state.outer);\n        }\n\n        if (!state.innerActive) {\n          for (var i = 0; i < others.length; ++i) {\n            var other = others[i];\n\n            if (other.open === \"\\n\") {\n              state.innerActive = other;\n              state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, \"\", \"\") : 0);\n            }\n          }\n        } else if (state.innerActive.close === \"\\n\") {\n          state.innerActive = state.inner = null;\n        }\n      },\n      electricChars: outer.electricChars,\n      innerMode: function innerMode(state) {\n        return state.inner ? {\n          state: state.inner,\n          mode: state.innerActive.mode\n        } : {\n          state: state.outer,\n          mode: outer\n        };\n      }\n    };\n  };\n});","map":null,"metadata":{},"sourceType":"script"}