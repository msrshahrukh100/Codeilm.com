{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"go\", function (config) {\n    var indentUnit = config.indentUnit;\n    var keywords = {\n      \"break\": true,\n      \"case\": true,\n      \"chan\": true,\n      \"const\": true,\n      \"continue\": true,\n      \"default\": true,\n      \"defer\": true,\n      \"else\": true,\n      \"fallthrough\": true,\n      \"for\": true,\n      \"func\": true,\n      \"go\": true,\n      \"goto\": true,\n      \"if\": true,\n      \"import\": true,\n      \"interface\": true,\n      \"map\": true,\n      \"package\": true,\n      \"range\": true,\n      \"return\": true,\n      \"select\": true,\n      \"struct\": true,\n      \"switch\": true,\n      \"type\": true,\n      \"var\": true,\n      \"bool\": true,\n      \"byte\": true,\n      \"complex64\": true,\n      \"complex128\": true,\n      \"float32\": true,\n      \"float64\": true,\n      \"int8\": true,\n      \"int16\": true,\n      \"int32\": true,\n      \"int64\": true,\n      \"string\": true,\n      \"uint8\": true,\n      \"uint16\": true,\n      \"uint32\": true,\n      \"uint64\": true,\n      \"int\": true,\n      \"uint\": true,\n      \"uintptr\": true,\n      \"error\": true,\n      \"rune\": true\n    };\n    var atoms = {\n      \"true\": true,\n      \"false\": true,\n      \"iota\": true,\n      \"nil\": true,\n      \"append\": true,\n      \"cap\": true,\n      \"close\": true,\n      \"complex\": true,\n      \"copy\": true,\n      \"delete\": true,\n      \"imag\": true,\n      \"len\": true,\n      \"make\": true,\n      \"new\": true,\n      \"panic\": true,\n      \"print\": true,\n      \"println\": true,\n      \"real\": true,\n      \"recover\": true\n    };\n    var isOperatorChar = /[+\\-*&^%:=<>!|\\/]/;\n    var curPunc;\n\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n\n      if (ch == '\"' || ch == \"'\" || ch == \"`\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      }\n\n      if (/[\\d\\.]/.test(ch)) {\n        if (ch == \".\") {\n          stream.match(/^[0-9]+([eE][\\-+]?[0-9]+)?/);\n        } else if (ch == \"0\") {\n          stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);\n        } else {\n          stream.match(/^[0-9]*\\.?[0-9]*([eE][\\-+]?[0-9]+)?/);\n        }\n\n        return \"number\";\n      }\n\n      if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n        curPunc = ch;\n        return null;\n      }\n\n      if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        }\n\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n      }\n\n      if (isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return \"operator\";\n      }\n\n      stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n      var cur = stream.current();\n\n      if (keywords.propertyIsEnumerable(cur)) {\n        if (cur == \"case\" || cur == \"default\") curPunc = \"case\";\n        return \"keyword\";\n      }\n\n      if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n      return \"variable\";\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            next,\n            end = false;\n\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n\n          escaped = !escaped && quote != \"`\" && next == \"\\\\\";\n        }\n\n        if (end || !(escaped || quote == \"`\")) state.tokenize = tokenBase;\n        return \"string\";\n      };\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = tokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function Context(indented, column, type, align, prev) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.align = align;\n      this.prev = prev;\n    }\n\n    function pushContext(state, col, type) {\n      return state.context = new Context(state.indented, col, type, null, state.context);\n    }\n\n    function popContext(state) {\n      if (!state.context.prev) return;\n      var t = state.context.type;\n      if (t == \")\" || t == \"]\" || t == \"}\") state.indented = state.context.indented;\n      return state.context = state.context.prev;\n    } // Interface\n\n\n    return {\n      startState: function startState(basecolumn) {\n        return {\n          tokenize: null,\n          context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", false),\n          indented: 0,\n          startOfLine: true\n        };\n      },\n      token: function token(stream, state) {\n        var ctx = state.context;\n\n        if (stream.sol()) {\n          if (ctx.align == null) ctx.align = false;\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n          if (ctx.type == \"case\") ctx.type = \"}\";\n        }\n\n        if (stream.eatSpace()) return null;\n        curPunc = null;\n        var style = (state.tokenize || tokenBase)(stream, state);\n        if (style == \"comment\") return style;\n        if (ctx.align == null) ctx.align = true;\n        if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");else if (curPunc == \"case\") ctx.type = \"case\";else if (curPunc == \"}\" && ctx.type == \"}\") popContext(state);else if (curPunc == ctx.type) popContext(state);\n        state.startOfLine = false;\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;\n        var ctx = state.context,\n            firstChar = textAfter && textAfter.charAt(0);\n\n        if (ctx.type == \"case\" && /^(?:case|default)\\b/.test(textAfter)) {\n          state.context.type = \"}\";\n          return ctx.indented;\n        }\n\n        var closing = firstChar == ctx.type;\n        if (ctx.align) return ctx.column + (closing ? 0 : 1);else return ctx.indented + (closing ? 0 : indentUnit);\n      },\n      electricChars: \"{}):\",\n      closeBrackets: \"()[]{}''\\\"\\\"``\",\n      fold: \"brace\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-go\", \"go\");\n});","map":null,"metadata":{},"sourceType":"script"}