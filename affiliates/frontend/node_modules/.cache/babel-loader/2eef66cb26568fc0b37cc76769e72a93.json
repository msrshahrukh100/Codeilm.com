{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"haxe\", function (config, parserConfig) {\n    var indentUnit = config.indentUnit; // Tokenizer\n\n    function kw(type) {\n      return {\n        type: type,\n        style: \"keyword\"\n      };\n    }\n\n    var A = kw(\"keyword a\"),\n        B = kw(\"keyword b\"),\n        C = kw(\"keyword c\");\n    var operator = kw(\"operator\"),\n        atom = {\n      type: \"atom\",\n      style: \"atom\"\n    },\n        attribute = {\n      type: \"attribute\",\n      style: \"attribute\"\n    };\n    var type = kw(\"typedef\");\n    var keywords = {\n      \"if\": A,\n      \"while\": A,\n      \"else\": B,\n      \"do\": B,\n      \"try\": B,\n      \"return\": C,\n      \"break\": C,\n      \"continue\": C,\n      \"new\": C,\n      \"throw\": C,\n      \"var\": kw(\"var\"),\n      \"inline\": attribute,\n      \"static\": attribute,\n      \"using\": kw(\"import\"),\n      \"public\": attribute,\n      \"private\": attribute,\n      \"cast\": kw(\"cast\"),\n      \"import\": kw(\"import\"),\n      \"macro\": kw(\"macro\"),\n      \"function\": kw(\"function\"),\n      \"catch\": kw(\"catch\"),\n      \"untyped\": kw(\"untyped\"),\n      \"callback\": kw(\"cb\"),\n      \"for\": kw(\"for\"),\n      \"switch\": kw(\"switch\"),\n      \"case\": kw(\"case\"),\n      \"default\": kw(\"default\"),\n      \"in\": operator,\n      \"never\": kw(\"property_access\"),\n      \"trace\": kw(\"trace\"),\n      \"class\": type,\n      \"abstract\": type,\n      \"enum\": type,\n      \"interface\": type,\n      \"typedef\": type,\n      \"extends\": type,\n      \"implements\": type,\n      \"dynamic\": type,\n      \"true\": atom,\n      \"false\": atom,\n      \"null\": atom\n    };\n    var isOperatorChar = /[+\\-*&%=<>!?|]/;\n\n    function chain(stream, state, f) {\n      state.tokenize = f;\n      return f(stream, state);\n    }\n\n    function toUnescaped(stream, end) {\n      var escaped = false,\n          next;\n\n      while ((next = stream.next()) != null) {\n        if (next == end && !escaped) return true;\n        escaped = !escaped && next == \"\\\\\";\n      }\n    } // Used as scratch variables to communicate multiple values without\n    // consing up tons of objects.\n\n\n    var type, content;\n\n    function ret(tp, style, cont) {\n      type = tp;\n      content = cont;\n      return style;\n    }\n\n    function haxeTokenBase(stream, state) {\n      var ch = stream.next();\n\n      if (ch == '\"' || ch == \"'\") {\n        return chain(stream, state, haxeTokenString(ch));\n      } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n        return ret(ch);\n      } else if (ch == \"0\" && stream.eat(/x/i)) {\n        stream.eatWhile(/[\\da-f]/i);\n        return ret(\"number\", \"number\");\n      } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n        stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n        return ret(\"number\", \"number\");\n      } else if (state.reAllowed && ch == \"~\" && stream.eat(/\\//)) {\n        toUnescaped(stream, \"/\");\n        stream.eatWhile(/[gimsu]/);\n        return ret(\"regexp\", \"string-2\");\n      } else if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          return chain(stream, state, haxeTokenComment);\n        } else if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return ret(\"comment\", \"comment\");\n        } else {\n          stream.eatWhile(isOperatorChar);\n          return ret(\"operator\", null, stream.current());\n        }\n      } else if (ch == \"#\") {\n        stream.skipToEnd();\n        return ret(\"conditional\", \"meta\");\n      } else if (ch == \"@\") {\n        stream.eat(/:/);\n        stream.eatWhile(/[\\w_]/);\n        return ret(\"metadata\", \"meta\");\n      } else if (isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      } else {\n        var word;\n\n        if (/[A-Z]/.test(ch)) {\n          stream.eatWhile(/[\\w_<>]/);\n          word = stream.current();\n          return ret(\"type\", \"variable-3\", word);\n        } else {\n          stream.eatWhile(/[\\w_]/);\n          var word = stream.current(),\n              known = keywords.propertyIsEnumerable(word) && keywords[word];\n          return known && state.kwAllowed ? ret(known.type, known.style, word) : ret(\"variable\", \"variable\", word);\n        }\n      }\n    }\n\n    function haxeTokenString(quote) {\n      return function (stream, state) {\n        if (toUnescaped(stream, quote)) state.tokenize = haxeTokenBase;\n        return ret(\"string\", \"string\");\n      };\n    }\n\n    function haxeTokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = haxeTokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return ret(\"comment\", \"comment\");\n    } // Parser\n\n\n    var atomicTypes = {\n      \"atom\": true,\n      \"number\": true,\n      \"variable\": true,\n      \"string\": true,\n      \"regexp\": true\n    };\n\n    function HaxeLexical(indented, column, type, align, prev, info) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.prev = prev;\n      this.info = info;\n      if (align != null) this.align = align;\n    }\n\n    function inScope(state, varname) {\n      for (var v = state.localVars; v; v = v.next) {\n        if (v.name == varname) return true;\n      }\n    }\n\n    function parseHaxe(state, style, type, content, stream) {\n      var cc = state.cc; // Communicate our context to the combinators.\n      // (Less wasteful than consing up a hundred closures on every call.)\n\n      cx.state = state;\n      cx.stream = stream;\n      cx.marked = null, cx.cc = cc;\n      if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n\n      while (true) {\n        var combinator = cc.length ? cc.pop() : statement;\n\n        if (combinator(type, content)) {\n          while (cc.length && cc[cc.length - 1].lex) {\n            cc.pop()();\n          }\n\n          if (cx.marked) return cx.marked;\n          if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n          if (type == \"variable\" && imported(state, content)) return \"variable-3\";\n          return style;\n        }\n      }\n    }\n\n    function imported(state, typename) {\n      if (/[a-z]/.test(typename.charAt(0))) return false;\n      var len = state.importedtypes.length;\n\n      for (var i = 0; i < len; i++) {\n        if (state.importedtypes[i] == typename) return true;\n      }\n    }\n\n    function registerimport(importname) {\n      var state = cx.state;\n\n      for (var t = state.importedtypes; t; t = t.next) {\n        if (t.name == importname) return;\n      }\n\n      state.importedtypes = {\n        name: importname,\n        next: state.importedtypes\n      };\n    } // Combinator utils\n\n\n    var cx = {\n      state: null,\n      column: null,\n      marked: null,\n      cc: null\n    };\n\n    function pass() {\n      for (var i = arguments.length - 1; i >= 0; i--) {\n        cx.cc.push(arguments[i]);\n      }\n    }\n\n    function cont() {\n      pass.apply(null, arguments);\n      return true;\n    }\n\n    function inList(name, list) {\n      for (var v = list; v; v = v.next) {\n        if (v.name == name) return true;\n      }\n\n      return false;\n    }\n\n    function register(varname) {\n      var state = cx.state;\n\n      if (state.context) {\n        cx.marked = \"def\";\n        if (inList(varname, state.localVars)) return;\n        state.localVars = {\n          name: varname,\n          next: state.localVars\n        };\n      } else if (state.globalVars) {\n        if (inList(varname, state.globalVars)) return;\n        state.globalVars = {\n          name: varname,\n          next: state.globalVars\n        };\n      }\n    } // Combinators\n\n\n    var defaultVars = {\n      name: \"this\",\n      next: null\n    };\n\n    function pushcontext() {\n      if (!cx.state.context) cx.state.localVars = defaultVars;\n      cx.state.context = {\n        prev: cx.state.context,\n        vars: cx.state.localVars\n      };\n    }\n\n    function popcontext() {\n      cx.state.localVars = cx.state.context.vars;\n      cx.state.context = cx.state.context.prev;\n    }\n\n    popcontext.lex = true;\n\n    function pushlex(type, info) {\n      var result = function result() {\n        var state = cx.state;\n        state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n      };\n\n      result.lex = true;\n      return result;\n    }\n\n    function poplex() {\n      var state = cx.state;\n\n      if (state.lexical.prev) {\n        if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n        state.lexical = state.lexical.prev;\n      }\n    }\n\n    poplex.lex = true;\n\n    function expect(wanted) {\n      function f(type) {\n        if (type == wanted) return cont();else if (wanted == \";\") return pass();else return cont(f);\n      }\n\n      return f;\n    }\n\n    function statement(type) {\n      if (type == \"@\") return cont(metadef);\n      if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n      if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n      if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n      if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n      if (type == \";\") return cont();\n      if (type == \"attribute\") return cont(maybeattribute);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"), poplex, statement, poplex);\n      if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n      if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"), block, poplex, poplex);\n      if (type == \"case\") return cont(expression, expect(\":\"));\n      if (type == \"default\") return cont(expect(\":\"));\n      if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"), statement, poplex, popcontext);\n      if (type == \"import\") return cont(importdef, expect(\";\"));\n      if (type == \"typedef\") return cont(typedef);\n      return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n    }\n\n    function expression(type) {\n      if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n      if (type == \"type\") return cont(maybeoperator);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"keyword c\") return cont(maybeexpression);\n      if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n      if (type == \"operator\") return cont(expression);\n      if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n      if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n      return cont();\n    }\n\n    function maybeexpression(type) {\n      if (type.match(/[;\\}\\)\\],]/)) return pass();\n      return pass(expression);\n    }\n\n    function maybeoperator(type, value) {\n      if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n      if (type == \"operator\" || type == \":\") return cont(expression);\n      if (type == \";\") return;\n      if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n      if (type == \".\") return cont(property, maybeoperator);\n      if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n    }\n\n    function maybeattribute(type) {\n      if (type == \"attribute\") return cont(maybeattribute);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"var\") return cont(vardef1);\n    }\n\n    function metadef(type) {\n      if (type == \":\") return cont(metadef);\n      if (type == \"variable\") return cont(metadef);\n      if (type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n    }\n\n    function metaargs(type) {\n      if (type == \"variable\") return cont();\n    }\n\n    function importdef(type, value) {\n      if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n        registerimport(value);\n        return cont();\n      } else if (type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n    }\n\n    function typedef(type, value) {\n      if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n        registerimport(value);\n        return cont();\n      } else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) {\n        return cont();\n      }\n    }\n\n    function maybelabel(type) {\n      if (type == \":\") return cont(poplex, statement);\n      return pass(maybeoperator, expect(\";\"), poplex);\n    }\n\n    function property(type) {\n      if (type == \"variable\") {\n        cx.marked = \"property\";\n        return cont();\n      }\n    }\n\n    function objprop(type) {\n      if (type == \"variable\") cx.marked = \"property\";\n      if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n    }\n\n    function commasep(what, end) {\n      function proceed(type) {\n        if (type == \",\") return cont(what, proceed);\n        if (type == end) return cont();\n        return cont(expect(end));\n      }\n\n      return function (type) {\n        if (type == end) return cont();else return pass(what, proceed);\n      };\n    }\n\n    function block(type) {\n      if (type == \"}\") return cont();\n      return pass(statement, block);\n    }\n\n    function vardef1(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(typeuse, vardef2);\n      }\n\n      return cont();\n    }\n\n    function vardef2(type, value) {\n      if (value == \"=\") return cont(expression, vardef2);\n      if (type == \",\") return cont(vardef1);\n    }\n\n    function forspec1(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(forin, expression);\n      } else {\n        return pass();\n      }\n    }\n\n    function forin(_type, value) {\n      if (value == \"in\") return cont();\n    }\n\n    function functiondef(type, value) {\n      //function names starting with upper-case letters are recognised as types, so cludging them together here.\n      if (type == \"variable\" || type == \"type\") {\n        register(value);\n        return cont(functiondef);\n      }\n\n      if (value == \"new\") return cont(functiondef);\n      if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n    }\n\n    function typeuse(type) {\n      if (type == \":\") return cont(typestring);\n    }\n\n    function typestring(type) {\n      if (type == \"type\") return cont();\n      if (type == \"variable\") return cont();\n      if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n    }\n\n    function typeprop(type) {\n      if (type == \"variable\") return cont(typeuse);\n    }\n\n    function funarg(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(typeuse);\n      }\n    } // Interface\n\n\n    return {\n      startState: function startState(basecolumn) {\n        var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n        var state = {\n          tokenize: haxeTokenBase,\n          reAllowed: true,\n          kwAllowed: true,\n          cc: [],\n          lexical: new HaxeLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n          localVars: parserConfig.localVars,\n          importedtypes: defaulttypes,\n          context: parserConfig.localVars && {\n            vars: parserConfig.localVars\n          },\n          indented: 0\n        };\n        if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\") state.globalVars = parserConfig.globalVars;\n        return state;\n      },\n      token: function token(stream, state) {\n        if (stream.sol()) {\n          if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n          state.indented = stream.indentation();\n        }\n\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        if (type == \"comment\") return style;\n        state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n        state.kwAllowed = type != '.';\n        return parseHaxe(state, style, type, content, stream);\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != haxeTokenBase) return 0;\n        var firstChar = textAfter && textAfter.charAt(0),\n            lexical = state.lexical;\n        if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n        var type = lexical.type,\n            closing = firstChar == type;\n        if (type == \"vardef\") return lexical.indented + 4;else if (type == \"form\" && firstChar == \"{\") return lexical.indented;else if (type == \"stat\" || type == \"form\") return lexical.indented + indentUnit;else if (lexical.info == \"switch\" && !closing) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);\n      },\n      electricChars: \"{}\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-haxe\", \"haxe\");\n  CodeMirror.defineMode(\"hxml\", function () {\n    return {\n      startState: function startState() {\n        return {\n          define: false,\n          inString: false\n        };\n      },\n      token: function token(stream, state) {\n        var ch = stream.peek();\n        var sol = stream.sol(); ///* comments */\n\n        if (ch == \"#\") {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n\n        if (sol && ch == \"-\") {\n          var style = \"variable-2\";\n          stream.eat(/-/);\n\n          if (stream.peek() == \"-\") {\n            stream.eat(/-/);\n            style = \"keyword a\";\n          }\n\n          if (stream.peek() == \"D\") {\n            stream.eat(/[D]/);\n            style = \"keyword c\";\n            state.define = true;\n          }\n\n          stream.eatWhile(/[A-Z]/i);\n          return style;\n        }\n\n        var ch = stream.peek();\n\n        if (state.inString == false && ch == \"'\") {\n          state.inString = true;\n          stream.next();\n        }\n\n        if (state.inString == true) {\n          if (stream.skipTo(\"'\")) {} else {\n            stream.skipToEnd();\n          }\n\n          if (stream.peek() == \"'\") {\n            stream.next();\n            state.inString = false;\n          }\n\n          return \"string\";\n        }\n\n        stream.next();\n        return null;\n      },\n      lineComment: \"#\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-hxml\", \"hxml\");\n});","map":null,"metadata":{},"sourceType":"script"}