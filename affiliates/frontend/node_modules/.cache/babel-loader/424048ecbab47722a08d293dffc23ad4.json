{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t.prettierPlugins = t.prettierPlugins || {}, t.prettierPlugins.babylon = e());\n}(this, function () {\n  \"use strict\";\n\n  var t = function t(_t, e) {\n    var s = new SyntaxError(_t + \" (\" + e.start.line + \":\" + e.start.column + \")\");\n    return s.loc = e, s;\n  };\n\n  function e(t) {\n    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n  }\n\n  function s(t, e) {\n    return t(e = {\n      exports: {}\n    }, e.exports), e.exports;\n  }\n\n  var i = s(function (t) {\n    t.exports = function (t) {\n      if (\"string\" != typeof t) throw new TypeError(\"Expected a string\");\n      var e = t.match(/(?:\\r?\\n)/g) || [];\n      if (0 === e.length) return null;\n      var s = e.filter(function (t) {\n        return \"\\r\\n\" === t;\n      }).length;\n      return s > e.length - s ? \"\\r\\n\" : \"\\n\";\n    }, t.exports.graceful = function (e) {\n      return t.exports(e) || \"\\n\";\n    };\n  }),\n      r = {\n    EOL: \"\\n\"\n  },\n      a = Object.freeze({\n    default: r\n  }),\n      n = a && r || a,\n      o = s(function (t, e) {\n    var s, r;\n\n    function a() {\n      return s = (t = i) && t.__esModule ? t : {\n        default: t\n      };\n      var t;\n    }\n\n    function o() {\n      return r = n;\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.extract = function (t) {\n      var e = t.match(p);\n      return e ? e[0].trimLeft() : \"\";\n    }, e.strip = function (t) {\n      var e = t.match(p);\n      return e && e[0] ? t.substring(e[0].length) : t;\n    }, e.parse = function (t) {\n      return y(t).pragmas;\n    }, e.parseWithComments = y, e.print = function (t) {\n      var e = t.comments,\n          i = void 0 === e ? \"\" : e,\n          n = t.pragmas,\n          h = void 0 === n ? {} : n,\n          u = (0, (s || a()).default)(i) || (r || o()).EOL,\n          p = Object.keys(h),\n          c = p.map(function (t) {\n        return D(t, h[t]);\n      }).reduce(function (t, e) {\n        return t.concat(e);\n      }, []).map(function (t) {\n        return \" * \" + t + u;\n      }).join(\"\");\n\n      if (!i) {\n        if (0 === p.length) return \"\";\n\n        if (1 === p.length && !Array.isArray(h[p[0]])) {\n          var l = h[p[0]];\n          return \"\".concat(\"/**\", \" \").concat(D(p[0], l)[0]).concat(\" */\");\n        }\n      }\n\n      var d = i.split(u).map(function (t) {\n        return \"\".concat(\" *\", \" \").concat(t);\n      }).join(u) + u;\n      return \"/**\" + u + (i ? d : \"\") + (i && p.length ? \" *\" + u : \"\") + c + \" */\";\n    };\n    var h = /\\*\\/$/,\n        u = /^\\/\\*\\*/,\n        p = /^\\s*(\\/\\*\\*?(.|\\r?\\n)*?\\*\\/)/,\n        c = /(^|\\s+)\\/\\/([^\\r\\n]*)/g,\n        l = /^(\\r?\\n)+/,\n        d = /(?:^|\\r?\\n) *(@[^\\r\\n]*?) *\\r?\\n *(?![^@\\r\\n]*\\/\\/[^]*)([^@\\r\\n\\s][^@\\r\\n]+?) *\\r?\\n/g,\n        f = /(?:^|\\r?\\n) *@(\\S+) *([^\\r\\n]*)/g,\n        m = /(\\r?\\n|^) *\\* ?/g;\n\n    function y(t) {\n      var e = (0, (s || a()).default)(t) || (r || o()).EOL;\n      t = t.replace(u, \"\").replace(h, \"\").replace(m, \"$1\");\n\n      for (var i = \"\"; i !== t;) {\n        i = t, t = t.replace(d, \"\".concat(e, \"$1 $2\").concat(e));\n      }\n\n      t = t.replace(l, \"\").trimRight();\n\n      for (var n, p = Object.create(null), y = t.replace(f, \"\").replace(l, \"\").trimRight(); n = f.exec(t);) {\n        var D = n[2].replace(c, \"\");\n        \"string\" == typeof p[n[1]] || Array.isArray(p[n[1]]) ? p[n[1]] = [].concat(p[n[1]], D) : p[n[1]] = D;\n      }\n\n      return {\n        comments: y,\n        pragmas: p\n      };\n    }\n\n    function D(t, e) {\n      return [].concat(e).map(function (e) {\n        return \"@\".concat(t, \" \").concat(e).trim();\n      });\n    }\n  });\n  e(o);\n\n  var h = function h(t) {\n    var e = Object.keys(o.parse(o.extract(t)));\n    return -1 !== e.indexOf(\"prettier\") || -1 !== e.indexOf(\"format\");\n  },\n      u = function u(t) {\n    return t.length > 0 ? t[t.length - 1] : null;\n  };\n\n  var p = {\n    locStart: function t(e, s) {\n      return !(s = s || {}).ignoreDecorators && e.declaration && e.declaration.decorators && e.declaration.decorators.length > 0 ? t(e.declaration.decorators[0]) : !s.ignoreDecorators && e.decorators && e.decorators.length > 0 ? t(e.decorators[0]) : e.__location ? e.__location.startOffset : e.range ? e.range[0] : \"number\" == typeof e.start ? e.start : e.loc ? e.loc.start : null;\n    },\n    locEnd: function t(e) {\n      var s = e.nodes && u(e.nodes);\n      if (s && e.source && !e.source.end && (e = s), e.__location) return e.__location.endOffset;\n      var i = e.range ? e.range[1] : \"number\" == typeof e.end ? e.end : null;\n      return e.typeAnnotation ? Math.max(i, t(e.typeAnnotation)) : e.loc && !i ? e.loc.end : i;\n    }\n  };\n\n  function c(t) {\n    return (c = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    })(t);\n  }\n\n  var l = s(function (t) {\n    t.exports = function (t) {\n      t = Object.assign({\n        onlyFirst: !1\n      }, t);\n      var e = [\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[a-zA-Z\\\\d]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"].join(\"|\");\n      return new RegExp(e, t.onlyFirst ? void 0 : \"g\");\n    };\n  }),\n      d = s(function (t) {\n    t.exports = function (t) {\n      return !Number.isNaN(t) && t >= 4352 && (t <= 4447 || 9001 === t || 9002 === t || 11904 <= t && t <= 12871 && 12351 !== t || 12880 <= t && t <= 19903 || 19968 <= t && t <= 42182 || 43360 <= t && t <= 43388 || 44032 <= t && t <= 55203 || 63744 <= t && t <= 64255 || 65040 <= t && t <= 65049 || 65072 <= t && t <= 65131 || 65281 <= t && t <= 65376 || 65504 <= t && t <= 65510 || 110592 <= t && t <= 110593 || 127488 <= t && t <= 127569 || 131072 <= t && t <= 262141);\n    };\n  }),\n      f = s(function (t) {\n    var e = /\\uD83C\\uDFF4(?:\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74)\\uDB40\\uDC7F|\\u200D\\u2620\\uFE0F)|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC68(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDB0-\\uDDB3])|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDB0-\\uDDB3]))|\\uD83D\\uDC69\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDB0-\\uDDB3])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC68(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|(?:(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)\\uFE0F|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDD6-\\uDDDD])(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\u200D[\\u2640\\u2642])|\\uD83D\\uDC69\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC68(?:\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDB0-\\uDDB3])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDB5\\uDDB6\\uDDD1-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDEEB\\uDEEC\\uDEF4-\\uDEF9]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD70\\uDD73-\\uDD76\\uDD7A\\uDD7C-\\uDDA2\\uDDB0-\\uDDB9\\uDDC0-\\uDDC2\\uDDD0-\\uDDFF])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEF9]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD70\\uDD73-\\uDD76\\uDD7A\\uDD7C-\\uDDA2\\uDDB0-\\uDDB9\\uDDC0-\\uDDC2\\uDDD0-\\uDDFF])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC69\\uDC6E\\uDC70-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3D\\uDD3E\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDD1-\\uDDDD])/g;\n\n    t.exports = function (t) {\n      if (\"string\" != typeof (t = t.replace(e, \"  \")) || 0 === t.length) return 0;\n\n      t = function (t) {\n        return \"string\" == typeof t ? t.replace(l(), \"\") : t;\n      }(t);\n\n      for (var s = 0, i = 0; i < t.length; i++) {\n        var r = t.codePointAt(i);\n        r <= 31 || r >= 127 && r <= 159 || r >= 768 && r <= 879 || (r > 65535 && i++, s += d(r) ? 2 : 1);\n      }\n\n      return s;\n    };\n  }),\n      m = /[|\\\\{}()[\\]^$+*?.]/g,\n      y = function y(t) {\n    if (\"string\" != typeof t) throw new TypeError(\"Expected a string\");\n    return t.replace(m, \"\\\\$&\");\n  },\n      D = /[^\\x20-\\x7F]/;\n\n  function x(t) {\n    if (t) switch (t.type) {\n      case \"ExportDefaultDeclaration\":\n      case \"ExportDefaultSpecifier\":\n      case \"DeclareExportDeclaration\":\n      case \"ExportNamedDeclaration\":\n      case \"ExportAllDeclaration\":\n        return !0;\n    }\n    return !1;\n  }\n\n  function v(t) {\n    return function (e, s, i) {\n      var r = i && i.backwards;\n      if (!1 === s) return !1;\n\n      for (var a = e.length, n = s; n >= 0 && n < a;) {\n        var o = e.charAt(n);\n\n        if (t instanceof RegExp) {\n          if (!t.test(o)) return n;\n        } else if (-1 === t.indexOf(o)) return n;\n\n        r ? n-- : n++;\n      }\n\n      return (-1 === n || n === a) && n;\n    };\n  }\n\n  var P = v(/\\s/),\n      g = v(\" \\t\"),\n      b = v(\",; \\t\"),\n      C = v(/[^\\r\\n]/);\n\n  function w(t, e) {\n    if (!1 === e) return !1;\n    if (\"/\" === t.charAt(e) && \"*\" === t.charAt(e + 1)) for (var s = e + 2; s < t.length; ++s) {\n      if (\"*\" === t.charAt(s) && \"/\" === t.charAt(s + 1)) return s + 2;\n    }\n    return e;\n  }\n\n  function E(t, e) {\n    return !1 !== e && (\"/\" === t.charAt(e) && \"/\" === t.charAt(e + 1) ? C(t, e) : e);\n  }\n\n  function A(t, e, s) {\n    var i = s && s.backwards;\n    if (!1 === e) return !1;\n    var r = t.charAt(e);\n\n    if (i) {\n      if (\"\\r\" === t.charAt(e - 1) && \"\\n\" === r) return e - 2;\n      if (\"\\n\" === r || \"\\r\" === r || \"\\u2028\" === r || \"\\u2029\" === r) return e - 1;\n    } else {\n      if (\"\\r\" === r && \"\\n\" === t.charAt(e + 1)) return e + 2;\n      if (\"\\n\" === r || \"\\r\" === r || \"\\u2028\" === r || \"\\u2029\" === r) return e + 1;\n    }\n\n    return e;\n  }\n\n  function T(t, e, s) {\n    var i = g(t, (s = s || {}).backwards ? e - 1 : e, s);\n    return i !== A(t, i, s);\n  }\n\n  function N(t, e) {\n    for (var s = null, i = e; i !== s;) {\n      s = i, i = w(t, i = b(t, i)), i = g(t, i);\n    }\n\n    return T(t, i = A(t, i = E(t, i)));\n  }\n\n  function k(t, e) {\n    for (var s = null; e !== s;) {\n      s = e, e = A(t, e = E(t, e = w(t, e = g(t, e))));\n    }\n\n    return e;\n  }\n\n  function F(t, e, s) {\n    return k(t, s(e));\n  }\n\n  var S = {};\n\n  function I(t) {\n    return S[t];\n  }\n\n  [[\"|>\"], [\"||\", \"??\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]].forEach(function (t, e) {\n    t.forEach(function (t) {\n      S[t] = e;\n    });\n  });\n  var L = {\n    \"==\": !0,\n    \"!=\": !0,\n    \"===\": !0,\n    \"!==\": !0\n  },\n      O = {\n    \"*\": !0,\n    \"/\": !0,\n    \"%\": !0\n  },\n      M = {\n    \">>\": !0,\n    \">>>\": !0,\n    \"<<\": !0\n  };\n\n  function R(t, e, s) {\n    for (var i = 0, r = s = s || 0; r < t.length; ++r) {\n      \"\\t\" === t[r] ? i = i + e - i % e : i++;\n    }\n\n    return i;\n  }\n\n  function B(t, e) {\n    var s = t.slice(1, -1),\n        i = {\n      quote: '\"',\n      regex: /\"/g\n    },\n        r = {\n      quote: \"'\",\n      regex: /'/g\n    },\n        a = \"'\" === e ? r : i,\n        n = a === r ? i : r,\n        o = a.quote;\n    (s.includes(a.quote) || s.includes(n.quote)) && (o = (s.match(a.regex) || []).length > (s.match(n.regex) || []).length ? n.quote : a.quote);\n    return o;\n  }\n\n  function _(t, e, s) {\n    var i = '\"' === e ? \"'\" : '\"',\n        r = t.replace(/\\\\([\\s\\S])|(['\"])/g, function (t, r, a) {\n      return r === i ? r : a === e ? \"\\\\\" + a : a || (s && /^[^\\\\nrvtbfux\\r\\n\\u2028\\u2029\"'0-7]$/.test(r) ? r : \"\\\\\" + r);\n    });\n    return e + r + e;\n  }\n\n  function j(t) {\n    return t && t.comments && t.comments.length > 0 && t.comments.some(function (t) {\n      return \"prettier-ignore\" === t.value.trim();\n    });\n  }\n\n  function q(t, e) {\n    (t.comments || (t.comments = [])).push(e), e.printed = !1, \"JSXText\" === t.type && (e.printed = !0);\n  }\n\n  var U = {\n    replaceEndOfLineWith: function replaceEndOfLineWith(t, e) {\n      var s = [],\n          i = !0,\n          r = !1,\n          a = void 0;\n\n      try {\n        for (var n, o = t.split(\"\\n\")[Symbol.iterator](); !(i = (n = o.next()).done); i = !0) {\n          var h = n.value;\n          0 !== s.length && s.push(e), s.push(h);\n        }\n      } catch (t) {\n        r = !0, a = t;\n      } finally {\n        try {\n          i || null == o.return || o.return();\n        } finally {\n          if (r) throw a;\n        }\n      }\n\n      return s;\n    },\n    getStringWidth: function getStringWidth(t) {\n      return t ? D.test(t) ? f(t) : t.length : 0;\n    },\n    getMaxContinuousCount: function getMaxContinuousCount(t, e) {\n      var s = t.match(new RegExp(\"(\".concat(y(e), \")+\"), \"g\"));\n      return null === s ? 0 : s.reduce(function (t, s) {\n        return Math.max(t, s.length / e.length);\n      }, 0);\n    },\n    getMinNotPresentContinuousCount: function getMinNotPresentContinuousCount(t, e) {\n      var s = t.match(new RegExp(\"(\".concat(y(e), \")+\"), \"g\"));\n      if (null === s) return 0;\n      var i = new Map(),\n          r = 0,\n          a = !0,\n          n = !1,\n          o = void 0;\n\n      try {\n        for (var h, u = s[Symbol.iterator](); !(a = (h = u.next()).done); a = !0) {\n          var p = h.value.length / e.length;\n          i.set(p, !0), p > r && (r = p);\n        }\n      } catch (t) {\n        n = !0, o = t;\n      } finally {\n        try {\n          a || null == u.return || u.return();\n        } finally {\n          if (n) throw o;\n        }\n      }\n\n      for (var c = 1; c < r; c++) {\n        if (!i.get(c)) return c;\n      }\n\n      return r + 1;\n    },\n    getPrecedence: I,\n    shouldFlatten: function shouldFlatten(t, e) {\n      return !(I(e) !== I(t) || \"**\" === t || L[t] && L[e] || \"%\" === e && O[t] || \"%\" === t && O[e] || e !== t && O[e] && O[t] || M[t] && M[e]);\n    },\n    isBitwiseOperator: function isBitwiseOperator(t) {\n      return !!M[t] || \"|\" === t || \"^\" === t || \"&\" === t;\n    },\n    isExportDeclaration: x,\n    getParentExportDeclaration: function getParentExportDeclaration(t) {\n      var e = t.getParentNode();\n      return \"declaration\" === t.getName() && x(e) ? e : null;\n    },\n    getPenultimate: function getPenultimate(t) {\n      return t.length > 1 ? t[t.length - 2] : null;\n    },\n    getLast: u,\n    getNextNonSpaceNonCommentCharacterIndexWithStartIndex: k,\n    getNextNonSpaceNonCommentCharacterIndex: F,\n    getNextNonSpaceNonCommentCharacter: function getNextNonSpaceNonCommentCharacter(t, e, s) {\n      return t.charAt(F(t, e, s));\n    },\n    skip: v,\n    skipWhitespace: P,\n    skipSpaces: g,\n    skipToLineEnd: b,\n    skipEverythingButNewLine: C,\n    skipInlineComment: w,\n    skipTrailingComment: E,\n    skipNewline: A,\n    isNextLineEmptyAfterIndex: N,\n    isNextLineEmpty: function isNextLineEmpty(t, e, s) {\n      return N(t, s(e));\n    },\n    isPreviousLineEmpty: function isPreviousLineEmpty(t, e, s) {\n      var i = s(e) - 1;\n      return i = A(t, i = g(t, i, {\n        backwards: !0\n      }), {\n        backwards: !0\n      }), (i = g(t, i, {\n        backwards: !0\n      })) !== A(t, i, {\n        backwards: !0\n      });\n    },\n    hasNewline: T,\n    hasNewlineInRange: function hasNewlineInRange(t, e, s) {\n      for (var i = e; i < s; ++i) {\n        if (\"\\n\" === t.charAt(i)) return !0;\n      }\n\n      return !1;\n    },\n    hasSpaces: function hasSpaces(t, e, s) {\n      return g(t, (s = s || {}).backwards ? e - 1 : e, s) !== e;\n    },\n    setLocStart: function setLocStart(t, e) {\n      t.range ? t.range[0] = e : t.start = e;\n    },\n    setLocEnd: function setLocEnd(t, e) {\n      t.range ? t.range[1] = e : t.end = e;\n    },\n    startsWithNoLookaheadToken: function t(e, s) {\n      switch ((e = function t(e) {\n        return e.left ? t(e.left) : e;\n      }(e)).type) {\n        case \"FunctionExpression\":\n        case \"ClassExpression\":\n        case \"DoExpression\":\n          return s;\n\n        case \"ObjectExpression\":\n          return !0;\n\n        case \"MemberExpression\":\n          return t(e.object, s);\n\n        case \"TaggedTemplateExpression\":\n          return \"FunctionExpression\" !== e.tag.type && t(e.tag, s);\n\n        case \"CallExpression\":\n          return \"FunctionExpression\" !== e.callee.type && t(e.callee, s);\n\n        case \"ConditionalExpression\":\n          return t(e.test, s);\n\n        case \"UpdateExpression\":\n          return !e.prefix && t(e.argument, s);\n\n        case \"BindExpression\":\n          return e.object && t(e.object, s);\n\n        case \"SequenceExpression\":\n          return t(e.expressions[0], s);\n\n        case \"TSAsExpression\":\n          return t(e.expression, s);\n\n        default:\n          return !1;\n      }\n    },\n    getAlignmentSize: R,\n    getIndentSize: function getIndentSize(t, e) {\n      var s = t.lastIndexOf(\"\\n\");\n      return -1 === s ? 0 : R(t.slice(s + 1).match(/^[ \\t]*/)[0], e);\n    },\n    getPreferredQuote: B,\n    printString: function printString(t, e, s) {\n      var i = t.slice(1, -1),\n          r = !i.includes('\"') && !i.includes(\"'\"),\n          a = \"json\" === e.parser ? '\"' : e.__isInHtmlAttribute ? \"'\" : B(t, e.singleQuote ? \"'\" : '\"');\n      return s ? r ? a + i + a : t : _(i, a, !(\"css\" === e.parser || \"less\" === e.parser || \"scss\" === e.parser || e.embeddedInHtml));\n    },\n    printNumber: function printNumber(t) {\n      return t.toLowerCase().replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\").replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\").replace(/^([+-])?\\./, \"$10.\").replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\").replace(/\\.(?=e|$)/, \"\");\n    },\n    hasIgnoreComment: function hasIgnoreComment(t) {\n      return j(t.getValue());\n    },\n    hasNodeIgnoreComment: j,\n    makeString: _,\n    matchAncestorTypes: function matchAncestorTypes(t, e, s) {\n      for (s = s || 0, e = e.slice(); e.length;) {\n        var i = t.getParentNode(s),\n            r = e.shift();\n        if (!i || i.type !== r) return !1;\n        s++;\n      }\n\n      return !0;\n    },\n    addLeadingComment: function addLeadingComment(t, e) {\n      e.leading = !0, e.trailing = !1, q(t, e);\n    },\n    addDanglingComment: function addDanglingComment(t, e) {\n      e.leading = !1, e.trailing = !1, q(t, e);\n    },\n    addTrailingComment: function addTrailingComment(t, e) {\n      e.leading = !1, e.trailing = !0, q(t, e);\n    },\n    isWithinParentArrayProperty: function isWithinParentArrayProperty(t, e) {\n      var s = t.getValue(),\n          i = t.getParentNode();\n      if (null == i) return !1;\n      if (!Array.isArray(i[e])) return !1;\n      var r = t.getName();\n      return i[e][r] === s;\n    }\n  }.getLast;\n\n  var V = function V(t, e) {\n    return function t(e, s) {\n      if (e && \"object\" === c(e)) if (Array.isArray(e)) {\n        var i = !0,\n            r = !1,\n            a = void 0;\n\n        try {\n          for (var n, o = e[Symbol.iterator](); !(i = (n = o.next()).done); i = !0) {\n            var h = n.value;\n            t(h, s);\n          }\n        } catch (t) {\n          r = !0, a = t;\n        } finally {\n          try {\n            i || null == o.return || o.return();\n          } finally {\n            if (r) throw a;\n          }\n        }\n      } else if (\"string\" == typeof e.type) {\n        for (var u = Object.keys(e), p = 0; p < u.length; p++) {\n          var l = u[p];\n          t(e[l], s);\n        }\n\n        s(e);\n      }\n    }(t, function (t) {\n      switch (t.type) {\n        case \"VariableDeclaration\":\n          var s = U(t.declarations);\n          s && s.init && function (t, s) {\n            var i;\n            \";\" !== e.originalText[(i = s, \"flow\" === e.parser ? i.range[1] : i.end)] && (\"flow\" === e.parser ? t.range = [t.range[0], s.range[1]] : t.end = s.end, t.loc = Object.assign({}, t.loc, {\n              end: t.loc.end\n            }));\n          }(t, s);\n      }\n    }), t;\n  },\n      W = s(function (t, e) {\n    function s(t) {\n      var e, s;\n\n      function i(e, s) {\n        try {\n          var a = t[e](s),\n              n = a.value,\n              o = n instanceof function (t) {\n            this.wrapped = t;\n          };\n\n          Promise.resolve(o ? n.wrapped : n).then(function (t) {\n            o ? i(\"next\", t) : r(a.done ? \"return\" : \"normal\", t);\n          }, function (t) {\n            i(\"throw\", t);\n          });\n        } catch (t) {\n          r(\"throw\", t);\n        }\n      }\n\n      function r(t, r) {\n        switch (t) {\n          case \"return\":\n            e.resolve({\n              value: r,\n              done: !0\n            });\n            break;\n\n          case \"throw\":\n            e.reject(r);\n            break;\n\n          default:\n            e.resolve({\n              value: r,\n              done: !1\n            });\n        }\n\n        (e = e.next) ? i(e.key, e.arg) : s = null;\n      }\n\n      this._invoke = function (t, r) {\n        return new Promise(function (a, n) {\n          var o = {\n            key: t,\n            arg: r,\n            resolve: a,\n            reject: n,\n            next: null\n          };\n          s ? s = s.next = o : (e = s = o, i(t, r));\n        });\n      }, \"function\" != typeof t.return && (this.return = void 0);\n    }\n\n    function i(t, e) {\n      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), \"function\" == typeof Symbol && Symbol.asyncIterator && (s.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    }), s.prototype.next = function (t) {\n      return this._invoke(\"next\", t);\n    }, s.prototype.throw = function (t) {\n      return this._invoke(\"throw\", t);\n    }, s.prototype.return = function (t) {\n      return this._invoke(\"return\", t);\n    };\n\n    var r = !0,\n        a = function a(t, e) {\n      void 0 === e && (e = {}), this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.rightAssociative = !!e.rightAssociative, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = 0 === e.binop ? 0 : e.binop || null, this.updateContext = null;\n    };\n\n    function n(t, e) {\n      return void 0 === e && (e = {}), new a(t, Object.assign({}, e, {\n        keyword: t\n      }));\n    }\n\n    function o(t, e) {\n      return new a(t, {\n        beforeExpr: r,\n        binop: e\n      });\n    }\n\n    var h = {\n      num: new a(\"num\", {\n        startsExpr: !0\n      }),\n      bigint: new a(\"bigint\", {\n        startsExpr: !0\n      }),\n      regexp: new a(\"regexp\", {\n        startsExpr: !0\n      }),\n      string: new a(\"string\", {\n        startsExpr: !0\n      }),\n      name: new a(\"name\", {\n        startsExpr: !0\n      }),\n      eof: new a(\"eof\"),\n      bracketL: new a(\"[\", {\n        beforeExpr: r,\n        startsExpr: !0\n      }),\n      bracketR: new a(\"]\"),\n      braceL: new a(\"{\", {\n        beforeExpr: r,\n        startsExpr: !0\n      }),\n      braceBarL: new a(\"{|\", {\n        beforeExpr: r,\n        startsExpr: !0\n      }),\n      braceR: new a(\"}\"),\n      braceBarR: new a(\"|}\"),\n      parenL: new a(\"(\", {\n        beforeExpr: r,\n        startsExpr: !0\n      }),\n      parenR: new a(\")\"),\n      comma: new a(\",\", {\n        beforeExpr: r\n      }),\n      semi: new a(\";\", {\n        beforeExpr: r\n      }),\n      colon: new a(\":\", {\n        beforeExpr: r\n      }),\n      doubleColon: new a(\"::\", {\n        beforeExpr: r\n      }),\n      dot: new a(\".\"),\n      question: new a(\"?\", {\n        beforeExpr: r\n      }),\n      questionDot: new a(\"?.\"),\n      arrow: new a(\"=>\", {\n        beforeExpr: r\n      }),\n      template: new a(\"template\"),\n      ellipsis: new a(\"...\", {\n        beforeExpr: r\n      }),\n      backQuote: new a(\"`\", {\n        startsExpr: !0\n      }),\n      dollarBraceL: new a(\"${\", {\n        beforeExpr: r,\n        startsExpr: !0\n      }),\n      at: new a(\"@\"),\n      hash: new a(\"#\"),\n      interpreterDirective: new a(\"#!...\"),\n      eq: new a(\"=\", {\n        beforeExpr: r,\n        isAssign: !0\n      }),\n      assign: new a(\"_=\", {\n        beforeExpr: r,\n        isAssign: !0\n      }),\n      incDec: new a(\"++/--\", {\n        prefix: !0,\n        postfix: !0,\n        startsExpr: !0\n      }),\n      bang: new a(\"!\", {\n        beforeExpr: r,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      tilde: new a(\"~\", {\n        beforeExpr: r,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      pipeline: new o(\"|>\", 0),\n      nullishCoalescing: new o(\"??\", 1),\n      logicalOR: new o(\"||\", 1),\n      logicalAND: new o(\"&&\", 2),\n      bitwiseOR: new o(\"|\", 3),\n      bitwiseXOR: new o(\"^\", 4),\n      bitwiseAND: new o(\"&\", 5),\n      equality: new o(\"==/!=\", 6),\n      relational: new o(\"</>\", 7),\n      bitShift: new o(\"<</>>\", 8),\n      plusMin: new a(\"+/-\", {\n        beforeExpr: r,\n        binop: 9,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      modulo: new o(\"%\", 10),\n      star: new o(\"*\", 10),\n      slash: new o(\"/\", 10),\n      exponent: new a(\"**\", {\n        beforeExpr: r,\n        binop: 11,\n        rightAssociative: !0\n      })\n    },\n        u = {\n      break: new n(\"break\"),\n      case: new n(\"case\", {\n        beforeExpr: r\n      }),\n      catch: new n(\"catch\"),\n      continue: new n(\"continue\"),\n      debugger: new n(\"debugger\"),\n      default: new n(\"default\", {\n        beforeExpr: r\n      }),\n      do: new n(\"do\", {\n        isLoop: !0,\n        beforeExpr: r\n      }),\n      else: new n(\"else\", {\n        beforeExpr: r\n      }),\n      finally: new n(\"finally\"),\n      for: new n(\"for\", {\n        isLoop: !0\n      }),\n      function: new n(\"function\", {\n        startsExpr: !0\n      }),\n      if: new n(\"if\"),\n      return: new n(\"return\", {\n        beforeExpr: r\n      }),\n      switch: new n(\"switch\"),\n      throw: new n(\"throw\", {\n        beforeExpr: r,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      try: new n(\"try\"),\n      var: new n(\"var\"),\n      let: new n(\"let\"),\n      const: new n(\"const\"),\n      while: new n(\"while\", {\n        isLoop: !0\n      }),\n      with: new n(\"with\"),\n      new: new n(\"new\", {\n        beforeExpr: r,\n        startsExpr: !0\n      }),\n      this: new n(\"this\", {\n        startsExpr: !0\n      }),\n      super: new n(\"super\", {\n        startsExpr: !0\n      }),\n      class: new n(\"class\", {\n        startsExpr: !0\n      }),\n      extends: new n(\"extends\", {\n        beforeExpr: r\n      }),\n      export: new n(\"export\"),\n      import: new n(\"import\", {\n        startsExpr: !0\n      }),\n      yield: new n(\"yield\", {\n        beforeExpr: r,\n        startsExpr: !0\n      }),\n      null: new n(\"null\", {\n        startsExpr: !0\n      }),\n      true: new n(\"true\", {\n        startsExpr: !0\n      }),\n      false: new n(\"false\", {\n        startsExpr: !0\n      }),\n      in: new n(\"in\", {\n        beforeExpr: r,\n        binop: 7\n      }),\n      instanceof: new n(\"instanceof\", {\n        beforeExpr: r,\n        binop: 7\n      }),\n      typeof: new n(\"typeof\", {\n        beforeExpr: r,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      void: new n(\"void\", {\n        beforeExpr: r,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      delete: new n(\"delete\", {\n        beforeExpr: r,\n        prefix: !0,\n        startsExpr: !0\n      })\n    };\n\n    function p(t) {\n      return null != t && \"Property\" === t.type && \"init\" === t.kind && !1 === t.method;\n    }\n\n    Object.keys(u).forEach(function (t) {\n      h[\"_\" + t] = u[t];\n    });\n    var c = /\\r\\n?|\\n|\\u2028|\\u2029/,\n        l = new RegExp(c.source, \"g\");\n\n    function d(t) {\n      switch (t) {\n        case 10:\n        case 13:\n        case 8232:\n        case 8233:\n          return !0;\n\n        default:\n          return !1;\n      }\n    }\n\n    var f = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n    function m(t) {\n      switch (t) {\n        case 9:\n        case 11:\n        case 12:\n        case 32:\n        case 160:\n        case 5760:\n        case 8192:\n        case 8193:\n        case 8194:\n        case 8195:\n        case 8196:\n        case 8197:\n        case 8198:\n        case 8199:\n        case 8200:\n        case 8201:\n        case 8202:\n        case 8239:\n        case 8287:\n        case 12288:\n        case 65279:\n          return !0;\n\n        default:\n          return !1;\n      }\n    }\n\n    var y = function y(t, e, s, i) {\n      this.token = t, this.isExpr = !!e, this.preserveSpace = !!s, this.override = i;\n    },\n        D = {\n      braceStatement: new y(\"{\", !1),\n      braceExpression: new y(\"{\", !0),\n      templateQuasi: new y(\"${\", !1),\n      parenStatement: new y(\"(\", !1),\n      parenExpression: new y(\"(\", !0),\n      template: new y(\"`\", !0, !0, function (t) {\n        return t.readTmplToken();\n      }),\n      functionExpression: new y(\"function\", !0),\n      functionStatement: new y(\"function\", !1)\n    };\n\n    function x(t) {\n      var e = t.split(\" \");\n      return function (t) {\n        return e.indexOf(t) >= 0;\n      };\n    }\n\n    h.parenR.updateContext = h.braceR.updateContext = function () {\n      if (1 !== this.state.context.length) {\n        var t = this.state.context.pop();\n        t === D.braceStatement && \"function\" === this.curContext().token && (t = this.state.context.pop()), this.state.exprAllowed = !t.isExpr;\n      } else this.state.exprAllowed = !0;\n    }, h.name.updateContext = function (t) {\n      var e = !1;\n      t !== h.dot && (\"of\" === this.state.value && !this.state.exprAllowed || \"yield\" === this.state.value && this.state.inGenerator) && (e = !0), this.state.exprAllowed = e, this.state.isIterator && (this.state.isIterator = !1);\n    }, h.braceL.updateContext = function (t) {\n      this.state.context.push(this.braceIsBlock(t) ? D.braceStatement : D.braceExpression), this.state.exprAllowed = !0;\n    }, h.dollarBraceL.updateContext = function () {\n      this.state.context.push(D.templateQuasi), this.state.exprAllowed = !0;\n    }, h.parenL.updateContext = function (t) {\n      var e = t === h._if || t === h._for || t === h._with || t === h._while;\n      this.state.context.push(e ? D.parenStatement : D.parenExpression), this.state.exprAllowed = !0;\n    }, h.incDec.updateContext = function () {}, h._function.updateContext = h._class.updateContext = function (t) {\n      !t.beforeExpr || t === h.semi || t === h._else || t === h._return && c.test(this.input.slice(this.state.lastTokEnd, this.state.start)) || (t === h.colon || t === h.braceL) && this.curContext() === D.b_stat ? this.state.context.push(D.functionStatement) : this.state.context.push(D.functionExpression), this.state.exprAllowed = !1;\n    }, h.backQuote.updateContext = function () {\n      this.curContext() === D.template ? this.state.context.pop() : this.state.context.push(D.template), this.state.exprAllowed = !1;\n    };\n    var v = {\n      6: x(\"enum await\"),\n      strict: x(\"implements interface let package private protected public static yield\"),\n      strictBind: x(\"eval arguments\")\n    },\n        P = x(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super\"),\n        g = \"ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿯ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞹꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ\",\n        b = \"‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿\",\n        C = new RegExp(\"[\" + g + \"]\"),\n        w = new RegExp(\"[\" + g + b + \"]\");\n    g = b = null;\n    var E = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 190, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 26, 230, 43, 117, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 68, 12, 0, 67, 12, 65, 1, 31, 6129, 15, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541],\n        A = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];\n\n    function T(t, e) {\n      for (var s = 65536, i = 0; i < e.length; i += 2) {\n        if ((s += e[i]) > t) return !1;\n        if ((s += e[i + 1]) >= t) return !0;\n      }\n\n      return !1;\n    }\n\n    function N(t) {\n      return t < 65 ? 36 === t : t <= 90 || (t < 97 ? 95 === t : t <= 122 || (t <= 65535 ? t >= 170 && C.test(String.fromCharCode(t)) : T(t, E)));\n    }\n\n    function k(t) {\n      return t < 48 ? 36 === t : t < 58 || !(t < 65) && (t <= 90 || (t < 97 ? 95 === t : t <= 122 || (t <= 65535 ? t >= 170 && w.test(String.fromCharCode(t)) : T(t, E) || T(t, A))));\n    }\n\n    var F = [\"any\", \"bool\", \"boolean\", \"empty\", \"false\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\", \"interface\", \"extends\", \"_\"];\n\n    function S(t) {\n      return \"type\" === t.importKind || \"typeof\" === t.importKind;\n    }\n\n    function I(t) {\n      return (t.type === h.name || !!t.type.keyword) && \"from\" !== t.value;\n    }\n\n    var L = {\n      const: \"declare export var\",\n      let: \"declare export var\",\n      type: \"export type\",\n      interface: \"export interface\"\n    };\n    var O = /\\*?\\s*@((?:no)?flow)\\b/,\n        M = {\n      quot: '\"',\n      amp: \"&\",\n      apos: \"'\",\n      lt: \"<\",\n      gt: \">\",\n      nbsp: \" \",\n      iexcl: \"¡\",\n      cent: \"¢\",\n      pound: \"£\",\n      curren: \"¤\",\n      yen: \"¥\",\n      brvbar: \"¦\",\n      sect: \"§\",\n      uml: \"¨\",\n      copy: \"©\",\n      ordf: \"ª\",\n      laquo: \"«\",\n      not: \"¬\",\n      shy: \"­\",\n      reg: \"®\",\n      macr: \"¯\",\n      deg: \"°\",\n      plusmn: \"±\",\n      sup2: \"²\",\n      sup3: \"³\",\n      acute: \"´\",\n      micro: \"µ\",\n      para: \"¶\",\n      middot: \"·\",\n      cedil: \"¸\",\n      sup1: \"¹\",\n      ordm: \"º\",\n      raquo: \"»\",\n      frac14: \"¼\",\n      frac12: \"½\",\n      frac34: \"¾\",\n      iquest: \"¿\",\n      Agrave: \"À\",\n      Aacute: \"Á\",\n      Acirc: \"Â\",\n      Atilde: \"Ã\",\n      Auml: \"Ä\",\n      Aring: \"Å\",\n      AElig: \"Æ\",\n      Ccedil: \"Ç\",\n      Egrave: \"È\",\n      Eacute: \"É\",\n      Ecirc: \"Ê\",\n      Euml: \"Ë\",\n      Igrave: \"Ì\",\n      Iacute: \"Í\",\n      Icirc: \"Î\",\n      Iuml: \"Ï\",\n      ETH: \"Ð\",\n      Ntilde: \"Ñ\",\n      Ograve: \"Ò\",\n      Oacute: \"Ó\",\n      Ocirc: \"Ô\",\n      Otilde: \"Õ\",\n      Ouml: \"Ö\",\n      times: \"×\",\n      Oslash: \"Ø\",\n      Ugrave: \"Ù\",\n      Uacute: \"Ú\",\n      Ucirc: \"Û\",\n      Uuml: \"Ü\",\n      Yacute: \"Ý\",\n      THORN: \"Þ\",\n      szlig: \"ß\",\n      agrave: \"à\",\n      aacute: \"á\",\n      acirc: \"â\",\n      atilde: \"ã\",\n      auml: \"ä\",\n      aring: \"å\",\n      aelig: \"æ\",\n      ccedil: \"ç\",\n      egrave: \"è\",\n      eacute: \"é\",\n      ecirc: \"ê\",\n      euml: \"ë\",\n      igrave: \"ì\",\n      iacute: \"í\",\n      icirc: \"î\",\n      iuml: \"ï\",\n      eth: \"ð\",\n      ntilde: \"ñ\",\n      ograve: \"ò\",\n      oacute: \"ó\",\n      ocirc: \"ô\",\n      otilde: \"õ\",\n      ouml: \"ö\",\n      divide: \"÷\",\n      oslash: \"ø\",\n      ugrave: \"ù\",\n      uacute: \"ú\",\n      ucirc: \"û\",\n      uuml: \"ü\",\n      yacute: \"ý\",\n      thorn: \"þ\",\n      yuml: \"ÿ\",\n      OElig: \"Œ\",\n      oelig: \"œ\",\n      Scaron: \"Š\",\n      scaron: \"š\",\n      Yuml: \"Ÿ\",\n      fnof: \"ƒ\",\n      circ: \"ˆ\",\n      tilde: \"˜\",\n      Alpha: \"Α\",\n      Beta: \"Β\",\n      Gamma: \"Γ\",\n      Delta: \"Δ\",\n      Epsilon: \"Ε\",\n      Zeta: \"Ζ\",\n      Eta: \"Η\",\n      Theta: \"Θ\",\n      Iota: \"Ι\",\n      Kappa: \"Κ\",\n      Lambda: \"Λ\",\n      Mu: \"Μ\",\n      Nu: \"Ν\",\n      Xi: \"Ξ\",\n      Omicron: \"Ο\",\n      Pi: \"Π\",\n      Rho: \"Ρ\",\n      Sigma: \"Σ\",\n      Tau: \"Τ\",\n      Upsilon: \"Υ\",\n      Phi: \"Φ\",\n      Chi: \"Χ\",\n      Psi: \"Ψ\",\n      Omega: \"Ω\",\n      alpha: \"α\",\n      beta: \"β\",\n      gamma: \"γ\",\n      delta: \"δ\",\n      epsilon: \"ε\",\n      zeta: \"ζ\",\n      eta: \"η\",\n      theta: \"θ\",\n      iota: \"ι\",\n      kappa: \"κ\",\n      lambda: \"λ\",\n      mu: \"μ\",\n      nu: \"ν\",\n      xi: \"ξ\",\n      omicron: \"ο\",\n      pi: \"π\",\n      rho: \"ρ\",\n      sigmaf: \"ς\",\n      sigma: \"σ\",\n      tau: \"τ\",\n      upsilon: \"υ\",\n      phi: \"φ\",\n      chi: \"χ\",\n      psi: \"ψ\",\n      omega: \"ω\",\n      thetasym: \"ϑ\",\n      upsih: \"ϒ\",\n      piv: \"ϖ\",\n      ensp: \" \",\n      emsp: \" \",\n      thinsp: \" \",\n      zwnj: \"‌\",\n      zwj: \"‍\",\n      lrm: \"‎\",\n      rlm: \"‏\",\n      ndash: \"–\",\n      mdash: \"—\",\n      lsquo: \"‘\",\n      rsquo: \"’\",\n      sbquo: \"‚\",\n      ldquo: \"“\",\n      rdquo: \"”\",\n      bdquo: \"„\",\n      dagger: \"†\",\n      Dagger: \"‡\",\n      bull: \"•\",\n      hellip: \"…\",\n      permil: \"‰\",\n      prime: \"′\",\n      Prime: \"″\",\n      lsaquo: \"‹\",\n      rsaquo: \"›\",\n      oline: \"‾\",\n      frasl: \"⁄\",\n      euro: \"€\",\n      image: \"ℑ\",\n      weierp: \"℘\",\n      real: \"ℜ\",\n      trade: \"™\",\n      alefsym: \"ℵ\",\n      larr: \"←\",\n      uarr: \"↑\",\n      rarr: \"→\",\n      darr: \"↓\",\n      harr: \"↔\",\n      crarr: \"↵\",\n      lArr: \"⇐\",\n      uArr: \"⇑\",\n      rArr: \"⇒\",\n      dArr: \"⇓\",\n      hArr: \"⇔\",\n      forall: \"∀\",\n      part: \"∂\",\n      exist: \"∃\",\n      empty: \"∅\",\n      nabla: \"∇\",\n      isin: \"∈\",\n      notin: \"∉\",\n      ni: \"∋\",\n      prod: \"∏\",\n      sum: \"∑\",\n      minus: \"−\",\n      lowast: \"∗\",\n      radic: \"√\",\n      prop: \"∝\",\n      infin: \"∞\",\n      ang: \"∠\",\n      and: \"∧\",\n      or: \"∨\",\n      cap: \"∩\",\n      cup: \"∪\",\n      int: \"∫\",\n      there4: \"∴\",\n      sim: \"∼\",\n      cong: \"≅\",\n      asymp: \"≈\",\n      ne: \"≠\",\n      equiv: \"≡\",\n      le: \"≤\",\n      ge: \"≥\",\n      sub: \"⊂\",\n      sup: \"⊃\",\n      nsub: \"⊄\",\n      sube: \"⊆\",\n      supe: \"⊇\",\n      oplus: \"⊕\",\n      otimes: \"⊗\",\n      perp: \"⊥\",\n      sdot: \"⋅\",\n      lceil: \"⌈\",\n      rceil: \"⌉\",\n      lfloor: \"⌊\",\n      rfloor: \"⌋\",\n      lang: \"〈\",\n      rang: \"〉\",\n      loz: \"◊\",\n      spades: \"♠\",\n      clubs: \"♣\",\n      hearts: \"♥\",\n      diams: \"♦\"\n    },\n        R = /^[\\da-fA-F]+$/,\n        B = /^\\d+$/;\n\n    function _(t) {\n      return !!t && (\"JSXOpeningFragment\" === t.type || \"JSXClosingFragment\" === t.type);\n    }\n\n    function j(t) {\n      if (\"JSXIdentifier\" === t.type) return t.name;\n      if (\"JSXNamespacedName\" === t.type) return t.namespace.name + \":\" + t.name.name;\n      if (\"JSXMemberExpression\" === t.type) return j(t.object) + \".\" + j(t.property);\n      throw new Error(\"Node had unexpected type: \" + t.type);\n    }\n\n    D.j_oTag = new y(\"<tag\", !1), D.j_cTag = new y(\"</tag\", !1), D.j_expr = new y(\"<tag>...</tag>\", !0, !0), h.jsxName = new a(\"jsxName\"), h.jsxText = new a(\"jsxText\", {\n      beforeExpr: !0\n    }), h.jsxTagStart = new a(\"jsxTagStart\", {\n      startsExpr: !0\n    }), h.jsxTagEnd = new a(\"jsxTagEnd\"), h.jsxTagStart.updateContext = function () {\n      this.state.context.push(D.j_expr), this.state.context.push(D.j_oTag), this.state.exprAllowed = !1;\n    }, h.jsxTagEnd.updateContext = function (t) {\n      var e = this.state.context.pop();\n      e === D.j_oTag && t === h.slash || e === D.j_cTag ? (this.state.context.pop(), this.state.exprAllowed = this.curContext() === D.j_expr) : this.state.exprAllowed = !0;\n    };\n    var q = {\n      sourceType: \"script\",\n      sourceFilename: void 0,\n      startLine: 1,\n      allowAwaitOutsideFunction: !1,\n      allowReturnOutsideFunction: !1,\n      allowImportExportEverywhere: !1,\n      allowSuperOutsideMethod: !1,\n      plugins: [],\n      strictMode: null,\n      ranges: !1,\n      tokens: !1\n    };\n\n    var U = function U(t, e) {\n      this.line = t, this.column = e;\n    },\n        V = function V(t, e) {\n      this.start = t, this.end = e;\n    };\n\n    function W(t) {\n      return t[t.length - 1];\n    }\n\n    var K = function (t) {\n      function e() {\n        return t.apply(this, arguments) || this;\n      }\n\n      return i(e, t), e.prototype.raise = function (t, e, s) {\n        var i = void 0 === s ? {} : s,\n            r = i.missingPluginNames,\n            a = i.code,\n            n = function (t, e) {\n          var s,\n              i = 1,\n              r = 0;\n\n          for (l.lastIndex = 0; (s = l.exec(t)) && s.index < e;) {\n            i++, r = l.lastIndex;\n          }\n\n          return new U(i, e - r);\n        }(this.input, t);\n\n        e += \" (\" + n.line + \":\" + n.column + \")\";\n        var o = new SyntaxError(e);\n        throw o.pos = t, o.loc = n, r && (o.missingPlugin = r), void 0 !== a && (o.code = a), o;\n      }, e;\n    }(function (t) {\n      function e() {\n        return t.apply(this, arguments) || this;\n      }\n\n      i(e, t);\n      var s = e.prototype;\n      return s.addComment = function (t) {\n        this.filename && (t.loc.filename = this.filename), this.state.trailingComments.push(t), this.state.leadingComments.push(t);\n      }, s.processComment = function (t) {\n        if (!(\"Program\" === t.type && t.body.length > 0)) {\n          var e,\n              s,\n              i,\n              r,\n              a,\n              n = this.state.commentStack;\n          if (this.state.trailingComments.length > 0) this.state.trailingComments[0].start >= t.end ? (i = this.state.trailingComments, this.state.trailingComments = []) : this.state.trailingComments.length = 0;else if (n.length > 0) {\n            var o = W(n);\n            o.trailingComments && o.trailingComments[0].start >= t.end && (i = o.trailingComments, delete o.trailingComments);\n          }\n\n          for (n.length > 0 && W(n).start >= t.start && (e = n.pop()); n.length > 0 && W(n).start >= t.start;) {\n            s = n.pop();\n          }\n\n          if (!s && e && (s = e), e && this.state.leadingComments.length > 0) {\n            var h = W(this.state.leadingComments);\n\n            if (\"ObjectProperty\" === e.type) {\n              if (h.start >= t.start && this.state.commentPreviousNode) {\n                for (a = 0; a < this.state.leadingComments.length; a++) {\n                  this.state.leadingComments[a].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(a, 1), a--);\n                }\n\n                this.state.leadingComments.length > 0 && (e.trailingComments = this.state.leadingComments, this.state.leadingComments = []);\n              }\n            } else if (\"CallExpression\" === t.type && t.arguments && t.arguments.length) {\n              var u = W(t.arguments);\n\n              if (u && h.start >= u.start && h.end <= t.end && this.state.commentPreviousNode) {\n                for (a = 0; a < this.state.leadingComments.length; a++) {\n                  this.state.leadingComments[a].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(a, 1), a--);\n                }\n\n                this.state.leadingComments.length > 0 && (u.trailingComments = this.state.leadingComments, this.state.leadingComments = []);\n              }\n            }\n          }\n\n          if (s) {\n            if (s.leadingComments) if (s !== t && s.leadingComments.length > 0 && W(s.leadingComments).end <= t.start) t.leadingComments = s.leadingComments, delete s.leadingComments;else for (r = s.leadingComments.length - 2; r >= 0; --r) {\n              if (s.leadingComments[r].end <= t.start) {\n                t.leadingComments = s.leadingComments.splice(0, r + 1);\n                break;\n              }\n            }\n          } else if (this.state.leadingComments.length > 0) if (W(this.state.leadingComments).end <= t.start) {\n            if (this.state.commentPreviousNode) for (a = 0; a < this.state.leadingComments.length; a++) {\n              this.state.leadingComments[a].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(a, 1), a--);\n            }\n            this.state.leadingComments.length > 0 && (t.leadingComments = this.state.leadingComments, this.state.leadingComments = []);\n          } else {\n            for (r = 0; r < this.state.leadingComments.length && !(this.state.leadingComments[r].end > t.start); r++) {\n              ;\n            }\n\n            var p = this.state.leadingComments.slice(0, r);\n            p.length && (t.leadingComments = p), 0 === (i = this.state.leadingComments.slice(r)).length && (i = null);\n          }\n\n          this.state.commentPreviousNode = t, i && (i.length && i[0].start >= t.start && W(i).end <= t.end ? t.innerComments = i : t.trailingComments = i), n.push(t);\n        }\n      }, e;\n    }(function () {\n      function t() {\n        this.sawUnambiguousESM = !1;\n      }\n\n      var e = t.prototype;\n      return e.isReservedWord = function (t) {\n        return \"await\" === t ? this.inModule : v[6](t);\n      }, e.hasPlugin = function (t) {\n        return Object.hasOwnProperty.call(this.plugins, t);\n      }, e.getPluginOption = function (t, e) {\n        if (this.hasPlugin(t)) return this.plugins[t][e];\n      }, t;\n    }())),\n        G = function () {\n      function t() {}\n\n      var e = t.prototype;\n      return e.init = function (t, e) {\n        this.strict = !1 !== t.strictMode && \"module\" === t.sourceType, this.input = e, this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.inMethod = !1, this.inFunction = !1, this.inParameters = !1, this.maybeInArrowParameters = !1, this.inGenerator = !1, this.inAsync = !1, this.inPipeline = !1, this.inPropertyName = !1, this.inType = !1, this.inClassProperty = !1, this.noAnonFunctionType = !1, this.hasFlowComment = !1, this.isIterator = !1, this.topicContext = {\n          maxNumOfResolvableTopics: 0,\n          maxTopicIndex: null\n        }, this.classLevel = 0, this.labels = [], this.decoratorStack = [[]], this.yieldOrAwaitInPossibleArrowParameters = null, this.tokens = [], this.comments = [], this.trailingComments = [], this.leadingComments = [], this.commentStack = [], this.commentPreviousNode = null, this.pos = this.lineStart = 0, this.curLine = t.startLine, this.type = h.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = [D.braceStatement], this.exprAllowed = !0, this.containsEsc = this.containsOctal = !1, this.octalPosition = null, this.invalidTemplateEscapePosition = null, this.exportedIdentifiers = [];\n      }, e.curPosition = function () {\n        return new U(this.curLine, this.pos - this.lineStart);\n      }, e.clone = function (e) {\n        var s = this,\n            i = new t();\n        return Object.keys(this).forEach(function (t) {\n          var r = s[t];\n          e && \"context\" !== t || !Array.isArray(r) || (r = r.slice()), i[t] = r;\n        }), i;\n      }, t;\n    }(),\n        X = function X(t) {\n      return t >= 48 && t <= 57;\n    },\n        J = {\n      decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],\n      hex: [46, 88, 95, 120]\n    },\n        H = {\n      bin: [48, 49]\n    };\n\n    H.oct = H.bin.concat([50, 51, 52, 53, 54, 55]), H.dec = H.oct.concat([56, 57]), H.hex = H.dec.concat([65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102]);\n\n    var z = function (t) {\n      function e() {\n        return t.apply(this, arguments) || this;\n      }\n\n      i(e, t);\n      var s = e.prototype;\n      return s.addExtra = function (t, e, s) {\n        t && ((t.extra = t.extra || {})[e] = s);\n      }, s.isRelational = function (t) {\n        return this.match(h.relational) && this.state.value === t;\n      }, s.isLookaheadRelational = function (t) {\n        var e = this.lookahead();\n        return e.type == h.relational && e.value == t;\n      }, s.expectRelational = function (t) {\n        this.isRelational(t) ? this.next() : this.unexpected(null, h.relational);\n      }, s.eatRelational = function (t) {\n        return !!this.isRelational(t) && (this.next(), !0);\n      }, s.isContextual = function (t) {\n        return this.match(h.name) && this.state.value === t && !this.state.containsEsc;\n      }, s.isLookaheadContextual = function (t) {\n        var e = this.lookahead();\n        return e.type === h.name && e.value === t;\n      }, s.eatContextual = function (t) {\n        return this.isContextual(t) && this.eat(h.name);\n      }, s.expectContextual = function (t, e) {\n        this.eatContextual(t) || this.unexpected(null, e);\n      }, s.canInsertSemicolon = function () {\n        return this.match(h.eof) || this.match(h.braceR) || this.hasPrecedingLineBreak();\n      }, s.hasPrecedingLineBreak = function () {\n        return c.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n      }, s.isLineTerminator = function () {\n        return this.eat(h.semi) || this.canInsertSemicolon();\n      }, s.semicolon = function () {\n        this.isLineTerminator() || this.unexpected(null, h.semi);\n      }, s.expect = function (t, e) {\n        this.eat(t) || this.unexpected(e, t);\n      }, s.unexpected = function (t, e) {\n        throw void 0 === e && (e = \"Unexpected token\"), \"string\" != typeof e && (e = 'Unexpected token, expected \"' + e.label + '\"'), this.raise(null != t ? t : this.state.start, e);\n      }, s.expectPlugin = function (t, e) {\n        if (!this.hasPlugin(t)) throw this.raise(null != e ? e : this.state.start, \"This experimental syntax requires enabling the parser plugin: '\" + t + \"'\", {\n          missingPluginNames: [t]\n        });\n        return !0;\n      }, s.expectOnePlugin = function (t, e) {\n        var s = this;\n        if (!t.some(function (t) {\n          return s.hasPlugin(t);\n        })) throw this.raise(null != e ? e : this.state.start, \"This experimental syntax requires enabling one of the following parser plugin(s): '\" + t.join(\", \") + \"'\", {\n          missingPluginNames: t\n        });\n      }, e;\n    }(function (t) {\n      function e(e, s) {\n        var i;\n        return (i = t.call(this) || this).state = new G(), i.state.init(e, s), i.isLookahead = !1, i;\n      }\n\n      i(e, t);\n      var s = e.prototype;\n      return s.next = function () {\n        this.options.tokens && !this.isLookahead && this.state.tokens.push(new function (t) {\n          this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new V(t.startLoc, t.endLoc);\n        }(this.state)), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();\n      }, s.eat = function (t) {\n        return !!this.match(t) && (this.next(), !0);\n      }, s.match = function (t) {\n        return this.state.type === t;\n      }, s.isKeyword = function (t) {\n        return P(t);\n      }, s.lookahead = function () {\n        var t = this.state;\n        this.state = t.clone(!0), this.isLookahead = !0, this.next(), this.isLookahead = !1;\n        var e = this.state;\n        return this.state = t, e;\n      }, s.setStrict = function (t) {\n        if (this.state.strict = t, this.match(h.num) || this.match(h.string)) {\n          for (this.state.pos = this.state.start; this.state.pos < this.state.lineStart;) {\n            this.state.lineStart = this.input.lastIndexOf(\"\\n\", this.state.lineStart - 2) + 1, --this.state.curLine;\n          }\n\n          this.nextToken();\n        }\n      }, s.curContext = function () {\n        return this.state.context[this.state.context.length - 1];\n      }, s.nextToken = function () {\n        var t = this.curContext();\n        t && t.preserveSpace || this.skipSpace(), this.state.containsOctal = !1, this.state.octalPosition = null, this.state.start = this.state.pos, this.state.startLoc = this.state.curPosition(), this.state.pos >= this.input.length ? this.finishToken(h.eof) : t.override ? t.override(this) : this.readToken(this.input.codePointAt(this.state.pos));\n      }, s.readToken = function (t) {\n        N(t) || 92 === t ? this.readWord() : this.getTokenFromCode(t);\n      }, s.pushComment = function (t, e, s, i, r, a) {\n        var n = {\n          type: t ? \"CommentBlock\" : \"CommentLine\",\n          value: e,\n          start: s,\n          end: i,\n          loc: new V(r, a)\n        };\n        this.isLookahead || (this.options.tokens && this.state.tokens.push(n), this.state.comments.push(n), this.addComment(n));\n      }, s.skipBlockComment = function () {\n        var t,\n            e = this.state.curPosition(),\n            s = this.state.pos,\n            i = this.input.indexOf(\"*/\", this.state.pos += 2);\n\n        for (-1 === i && this.raise(this.state.pos - 2, \"Unterminated comment\"), this.state.pos = i + 2, l.lastIndex = s; (t = l.exec(this.input)) && t.index < this.state.pos;) {\n          ++this.state.curLine, this.state.lineStart = t.index + t[0].length;\n        }\n\n        this.pushComment(!0, this.input.slice(s + 2, i), s, this.state.pos, e, this.state.curPosition());\n      }, s.skipLineComment = function (t) {\n        var e = this.state.pos,\n            s = this.state.curPosition(),\n            i = this.input.charCodeAt(this.state.pos += t);\n        if (this.state.pos < this.input.length) for (; 10 !== i && 13 !== i && 8232 !== i && 8233 !== i && ++this.state.pos < this.input.length;) {\n          i = this.input.charCodeAt(this.state.pos);\n        }\n        this.pushComment(!1, this.input.slice(e + t, this.state.pos), e, this.state.pos, s, this.state.curPosition());\n      }, s.skipSpace = function () {\n        t: for (; this.state.pos < this.input.length;) {\n          var t = this.input.charCodeAt(this.state.pos);\n\n          switch (t) {\n            case 13:\n              10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;\n\n            case 10:\n            case 8232:\n            case 8233:\n              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;\n              break;\n\n            case 47:\n              switch (this.input.charCodeAt(this.state.pos + 1)) {\n                case 42:\n                  this.skipBlockComment();\n                  break;\n\n                case 47:\n                  this.skipLineComment(2);\n                  break;\n\n                default:\n                  break t;\n              }\n\n              break;\n\n            default:\n              if (!m(t)) break t;\n              ++this.state.pos;\n          }\n        }\n      }, s.finishToken = function (t, e) {\n        this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();\n        var s = this.state.type;\n        this.state.type = t, this.state.value = e, this.updateContext(s);\n      }, s.readToken_numberSign = function () {\n        if (0 !== this.state.pos || !this.readToken_interpreter()) {\n          var t = this.state.pos + 1,\n              e = this.input.charCodeAt(t);\n          if (e >= 48 && e <= 57 && this.raise(this.state.pos, \"Unexpected digit after hash token\"), (this.hasPlugin(\"classPrivateProperties\") || this.hasPlugin(\"classPrivateMethods\")) && this.state.classLevel > 0) return ++this.state.pos, void this.finishToken(h.hash);\n          \"smart\" === this.getPluginOption(\"pipelineOperator\", \"proposal\") ? this.finishOp(h.hash, 1) : this.raise(this.state.pos, \"Unexpected character '#'\");\n        }\n      }, s.readToken_dot = function () {\n        var t = this.input.charCodeAt(this.state.pos + 1);\n        if (t >= 48 && t <= 57) this.readNumber(!0);else {\n          var e = this.input.charCodeAt(this.state.pos + 2);\n          46 === t && 46 === e ? (this.state.pos += 3, this.finishToken(h.ellipsis)) : (++this.state.pos, this.finishToken(h.dot));\n        }\n      }, s.readToken_slash = function () {\n        if (this.state.exprAllowed && !this.state.inType) return ++this.state.pos, void this.readRegexp();\n        61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(h.assign, 2) : this.finishOp(h.slash, 1);\n      }, s.readToken_interpreter = function () {\n        if (0 !== this.state.pos || this.state.input.length < 2) return !1;\n        var t = this.state.pos;\n        this.state.pos += 1;\n        var e = this.input.charCodeAt(this.state.pos);\n        if (33 !== e) return !1;\n\n        for (; 10 !== e && 13 !== e && 8232 !== e && 8233 !== e && ++this.state.pos < this.input.length;) {\n          e = this.input.charCodeAt(this.state.pos);\n        }\n\n        var s = this.input.slice(t + 2, this.state.pos);\n        return this.finishToken(h.interpreterDirective, s), !0;\n      }, s.readToken_mult_modulo = function (t) {\n        var e = 42 === t ? h.star : h.modulo,\n            s = 1,\n            i = this.input.charCodeAt(this.state.pos + 1),\n            r = this.state.exprAllowed;\n        42 === t && 42 === i && (s++, i = this.input.charCodeAt(this.state.pos + 2), e = h.exponent), 61 !== i || r || (s++, e = h.assign), this.finishOp(e, s);\n      }, s.readToken_pipe_amp = function (t) {\n        var e = this.input.charCodeAt(this.state.pos + 1);\n\n        if (e !== t) {\n          if (124 === t) {\n            if (62 === e) return void this.finishOp(h.pipeline, 2);\n            if (125 === e && this.hasPlugin(\"flow\")) return void this.finishOp(h.braceBarR, 2);\n          }\n\n          61 !== e ? this.finishOp(124 === t ? h.bitwiseOR : h.bitwiseAND, 1) : this.finishOp(h.assign, 2);\n        } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(h.assign, 3) : this.finishOp(124 === t ? h.logicalOR : h.logicalAND, 2);\n      }, s.readToken_caret = function () {\n        61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(h.assign, 2) : this.finishOp(h.bitwiseXOR, 1);\n      }, s.readToken_plus_min = function (t) {\n        var e = this.input.charCodeAt(this.state.pos + 1);\n        if (e === t) return 45 === e && !this.inModule && 62 === this.input.charCodeAt(this.state.pos + 2) && c.test(this.input.slice(this.state.lastTokEnd, this.state.pos)) ? (this.skipLineComment(3), this.skipSpace(), void this.nextToken()) : void this.finishOp(h.incDec, 2);\n        61 === e ? this.finishOp(h.assign, 2) : this.finishOp(h.plusMin, 1);\n      }, s.readToken_lt_gt = function (t) {\n        var e = this.input.charCodeAt(this.state.pos + 1),\n            s = 1;\n        return e === t ? (s = 62 === t && 62 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.state.pos + s) ? void this.finishOp(h.assign, s + 1) : void this.finishOp(h.bitShift, s)) : 33 !== e || 60 !== t || this.inModule || 45 !== this.input.charCodeAt(this.state.pos + 2) || 45 !== this.input.charCodeAt(this.state.pos + 3) ? (61 === e && (s = 2), void this.finishOp(h.relational, s)) : (this.skipLineComment(4), this.skipSpace(), void this.nextToken());\n      }, s.readToken_eq_excl = function (t) {\n        var e = this.input.charCodeAt(this.state.pos + 1);\n        if (61 !== e) return 61 === t && 62 === e ? (this.state.pos += 2, void this.finishToken(h.arrow)) : void this.finishOp(61 === t ? h.eq : h.bang, 1);\n        this.finishOp(h.equality, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);\n      }, s.readToken_question = function () {\n        var t = this.input.charCodeAt(this.state.pos + 1),\n            e = this.input.charCodeAt(this.state.pos + 2);\n        63 !== t || this.state.inType ? 46 !== t || e >= 48 && e <= 57 ? (++this.state.pos, this.finishToken(h.question)) : (this.state.pos += 2, this.finishToken(h.questionDot)) : 61 === e ? this.finishOp(h.assign, 3) : this.finishOp(h.nullishCoalescing, 2);\n      }, s.getTokenFromCode = function (t) {\n        switch (t) {\n          case 35:\n            return void this.readToken_numberSign();\n\n          case 46:\n            return void this.readToken_dot();\n\n          case 40:\n            return ++this.state.pos, void this.finishToken(h.parenL);\n\n          case 41:\n            return ++this.state.pos, void this.finishToken(h.parenR);\n\n          case 59:\n            return ++this.state.pos, void this.finishToken(h.semi);\n\n          case 44:\n            return ++this.state.pos, void this.finishToken(h.comma);\n\n          case 91:\n            return ++this.state.pos, void this.finishToken(h.bracketL);\n\n          case 93:\n            return ++this.state.pos, void this.finishToken(h.bracketR);\n\n          case 123:\n            return void (this.hasPlugin(\"flow\") && 124 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(h.braceBarL, 2) : (++this.state.pos, this.finishToken(h.braceL)));\n\n          case 125:\n            return ++this.state.pos, void this.finishToken(h.braceR);\n\n          case 58:\n            return void (this.hasPlugin(\"functionBind\") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(h.doubleColon, 2) : (++this.state.pos, this.finishToken(h.colon)));\n\n          case 63:\n            return void this.readToken_question();\n\n          case 64:\n            return ++this.state.pos, void this.finishToken(h.at);\n\n          case 96:\n            return ++this.state.pos, void this.finishToken(h.backQuote);\n\n          case 48:\n            var e = this.input.charCodeAt(this.state.pos + 1);\n            if (120 === e || 88 === e) return void this.readRadixNumber(16);\n            if (111 === e || 79 === e) return void this.readRadixNumber(8);\n            if (98 === e || 66 === e) return void this.readRadixNumber(2);\n\n          case 49:\n          case 50:\n          case 51:\n          case 52:\n          case 53:\n          case 54:\n          case 55:\n          case 56:\n          case 57:\n            return void this.readNumber(!1);\n\n          case 34:\n          case 39:\n            return void this.readString(t);\n\n          case 47:\n            return void this.readToken_slash();\n\n          case 37:\n          case 42:\n            return void this.readToken_mult_modulo(t);\n\n          case 124:\n          case 38:\n            return void this.readToken_pipe_amp(t);\n\n          case 94:\n            return void this.readToken_caret();\n\n          case 43:\n          case 45:\n            return void this.readToken_plus_min(t);\n\n          case 60:\n          case 62:\n            return void this.readToken_lt_gt(t);\n\n          case 61:\n          case 33:\n            return void this.readToken_eq_excl(t);\n\n          case 126:\n            return void this.finishOp(h.tilde, 1);\n        }\n\n        this.raise(this.state.pos, \"Unexpected character '\" + String.fromCodePoint(t) + \"'\");\n      }, s.finishOp = function (t, e) {\n        var s = this.input.slice(this.state.pos, this.state.pos + e);\n        this.state.pos += e, this.finishToken(t, s);\n      }, s.readRegexp = function () {\n        for (var t, e, s = this.state.pos;;) {\n          this.state.pos >= this.input.length && this.raise(s, \"Unterminated regular expression\");\n          var i = this.input.charAt(this.state.pos);\n          if (c.test(i) && this.raise(s, \"Unterminated regular expression\"), t) t = !1;else {\n            if (\"[\" === i) e = !0;else if (\"]\" === i && e) e = !1;else if (\"/\" === i && !e) break;\n            t = \"\\\\\" === i;\n          }\n          ++this.state.pos;\n        }\n\n        var r = this.input.slice(s, this.state.pos);\n        ++this.state.pos;\n\n        for (var a = \"\"; this.state.pos < this.input.length;) {\n          var n = this.input[this.state.pos],\n              o = this.input.codePointAt(this.state.pos);\n          if (\"gmsiyu\".indexOf(n) > -1) a.indexOf(n) > -1 && this.raise(this.state.pos + 1, \"Duplicate regular expression flag\"), ++this.state.pos, a += n;else {\n            if (!k(o) && 92 !== o) break;\n            this.raise(this.state.pos + 1, \"Invalid regular expression flag\");\n          }\n        }\n\n        this.finishToken(h.regexp, {\n          pattern: r,\n          flags: a\n        });\n      }, s.readInt = function (t, e) {\n        for (var s = this.state.pos, i = 16 === t ? J.hex : J.decBinOct, r = 16 === t ? H.hex : 10 === t ? H.dec : 8 === t ? H.oct : H.bin, a = 0, n = 0, o = null == e ? 1 / 0 : e; n < o; ++n) {\n          var h = this.input.charCodeAt(this.state.pos),\n              u = void 0;\n\n          if (this.hasPlugin(\"numericSeparator\")) {\n            var p = this.input.charCodeAt(this.state.pos - 1),\n                c = this.input.charCodeAt(this.state.pos + 1);\n\n            if (95 === h) {\n              -1 === r.indexOf(c) && this.raise(this.state.pos, \"Invalid or unexpected token\"), (i.indexOf(p) > -1 || i.indexOf(c) > -1 || Number.isNaN(c)) && this.raise(this.state.pos, \"Invalid or unexpected token\"), ++this.state.pos;\n              continue;\n            }\n          }\n\n          if ((u = h >= 97 ? h - 97 + 10 : h >= 65 ? h - 65 + 10 : X(h) ? h - 48 : 1 / 0) >= t) break;\n          ++this.state.pos, a = a * t + u;\n        }\n\n        return this.state.pos === s || null != e && this.state.pos - s !== e ? null : a;\n      }, s.readRadixNumber = function (t) {\n        var e = this.state.pos,\n            s = !1;\n        this.state.pos += 2;\n        var i = this.readInt(t);\n\n        if (null == i && this.raise(this.state.start + 2, \"Expected number in radix \" + t), this.hasPlugin(\"bigInt\") && 110 === this.input.charCodeAt(this.state.pos) && (++this.state.pos, s = !0), N(this.input.codePointAt(this.state.pos)) && this.raise(this.state.pos, \"Identifier directly after number\"), s) {\n          var r = this.input.slice(e, this.state.pos).replace(/[_n]/g, \"\");\n          this.finishToken(h.bigint, r);\n        } else this.finishToken(h.num, i);\n      }, s.readNumber = function (t) {\n        var e = this.state.pos,\n            s = !1,\n            i = !1;\n        t || null !== this.readInt(10) || this.raise(e, \"Invalid number\");\n        var r = this.state.pos - e >= 2 && 48 === this.input.charCodeAt(e);\n        r && (this.state.strict && this.raise(e, \"Legacy octal literals are not allowed in strict mode\"), /[89]/.test(this.input.slice(e, this.state.pos)) && (r = !1));\n        var a = this.input.charCodeAt(this.state.pos);\n        46 !== a || r || (++this.state.pos, this.readInt(10), s = !0, a = this.input.charCodeAt(this.state.pos)), 69 !== a && 101 !== a || r || (43 !== (a = this.input.charCodeAt(++this.state.pos)) && 45 !== a || ++this.state.pos, null === this.readInt(10) && this.raise(e, \"Invalid number\"), s = !0, a = this.input.charCodeAt(this.state.pos)), this.hasPlugin(\"bigInt\") && 110 === a && ((s || r) && this.raise(e, \"Invalid BigIntLiteral\"), ++this.state.pos, i = !0), N(this.input.codePointAt(this.state.pos)) && this.raise(this.state.pos, \"Identifier directly after number\");\n        var n = this.input.slice(e, this.state.pos).replace(/[_n]/g, \"\");\n        if (i) this.finishToken(h.bigint, n);else {\n          var o = r ? parseInt(n, 8) : parseFloat(n);\n          this.finishToken(h.num, o);\n        }\n      }, s.readCodePoint = function (t) {\n        var e;\n\n        if (123 === this.input.charCodeAt(this.state.pos)) {\n          var s = ++this.state.pos;\n          if (e = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, t), ++this.state.pos, null === e) --this.state.invalidTemplateEscapePosition;else if (e > 1114111) {\n            if (!t) return this.state.invalidTemplateEscapePosition = s - 2, null;\n            this.raise(s, \"Code point out of bounds\");\n          }\n        } else e = this.readHexChar(4, t);\n\n        return e;\n      }, s.readString = function (t) {\n        for (var e = \"\", s = ++this.state.pos;;) {\n          this.state.pos >= this.input.length && this.raise(this.state.start, \"Unterminated string constant\");\n          var i = this.input.charCodeAt(this.state.pos);\n          if (i === t) break;\n          92 === i ? (e += this.input.slice(s, this.state.pos), e += this.readEscapedChar(!1), s = this.state.pos) : 8232 === i || 8233 === i ? (++this.state.pos, ++this.state.curLine) : d(i) ? this.raise(this.state.start, \"Unterminated string constant\") : ++this.state.pos;\n        }\n\n        e += this.input.slice(s, this.state.pos++), this.finishToken(h.string, e);\n      }, s.readTmplToken = function () {\n        for (var t = \"\", e = this.state.pos, s = !1;;) {\n          this.state.pos >= this.input.length && this.raise(this.state.start, \"Unterminated template\");\n          var i = this.input.charCodeAt(this.state.pos);\n          if (96 === i || 36 === i && 123 === this.input.charCodeAt(this.state.pos + 1)) return this.state.pos === this.state.start && this.match(h.template) ? 36 === i ? (this.state.pos += 2, void this.finishToken(h.dollarBraceL)) : (++this.state.pos, void this.finishToken(h.backQuote)) : (t += this.input.slice(e, this.state.pos), void this.finishToken(h.template, s ? null : t));\n\n          if (92 === i) {\n            t += this.input.slice(e, this.state.pos);\n            var r = this.readEscapedChar(!0);\n            null === r ? s = !0 : t += r, e = this.state.pos;\n          } else if (d(i)) {\n            switch (t += this.input.slice(e, this.state.pos), ++this.state.pos, i) {\n              case 13:\n                10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;\n\n              case 10:\n                t += \"\\n\";\n                break;\n\n              default:\n                t += String.fromCharCode(i);\n            }\n\n            ++this.state.curLine, this.state.lineStart = this.state.pos, e = this.state.pos;\n          } else ++this.state.pos;\n        }\n      }, s.readEscapedChar = function (t) {\n        var e = !t,\n            s = this.input.charCodeAt(++this.state.pos);\n\n        switch (++this.state.pos, s) {\n          case 110:\n            return \"\\n\";\n\n          case 114:\n            return \"\\r\";\n\n          case 120:\n            var i = this.readHexChar(2, e);\n            return null === i ? null : String.fromCharCode(i);\n\n          case 117:\n            var r = this.readCodePoint(e);\n            return null === r ? null : String.fromCodePoint(r);\n\n          case 116:\n            return \"\\t\";\n\n          case 98:\n            return \"\\b\";\n\n          case 118:\n            return \"\\v\";\n\n          case 102:\n            return \"\\f\";\n\n          case 13:\n            10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;\n\n          case 10:\n            return this.state.lineStart = this.state.pos, ++this.state.curLine, \"\";\n\n          default:\n            if (s >= 48 && s <= 55) {\n              var a = this.state.pos - 1,\n                  n = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0],\n                  o = parseInt(n, 8);\n\n              if (o > 255 && (n = n.slice(0, -1), o = parseInt(n, 8)), o > 0) {\n                if (t) return this.state.invalidTemplateEscapePosition = a, null;\n                this.state.strict ? this.raise(a, \"Octal literal in strict mode\") : this.state.containsOctal || (this.state.containsOctal = !0, this.state.octalPosition = a);\n              }\n\n              return this.state.pos += n.length - 1, String.fromCharCode(o);\n            }\n\n            return String.fromCharCode(s);\n        }\n      }, s.readHexChar = function (t, e) {\n        var s = this.state.pos,\n            i = this.readInt(16, t);\n        return null === i && (e ? this.raise(s, \"Bad character escape sequence\") : (this.state.pos = s - 1, this.state.invalidTemplateEscapePosition = s - 1)), i;\n      }, s.readWord1 = function () {\n        this.state.containsEsc = !1;\n\n        for (var t = \"\", e = !0, s = this.state.pos; this.state.pos < this.input.length;) {\n          var i = this.input.codePointAt(this.state.pos);\n          if (k(i)) this.state.pos += i <= 65535 ? 1 : 2;else if (this.state.isIterator && 64 === i) this.state.pos += 1;else {\n            if (92 !== i) break;\n            this.state.containsEsc = !0, t += this.input.slice(s, this.state.pos);\n            var r = this.state.pos;\n            117 !== this.input.charCodeAt(++this.state.pos) && this.raise(this.state.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"), ++this.state.pos;\n            var a = this.readCodePoint(!0);\n            (e ? N : k)(a, !0) || this.raise(r, \"Invalid Unicode escape\"), t += String.fromCodePoint(a), s = this.state.pos;\n          }\n          e = !1;\n        }\n\n        return t + this.input.slice(s, this.state.pos);\n      }, s.isIterator = function (t) {\n        return \"@@iterator\" === t || \"@@asyncIterator\" === t;\n      }, s.readWord = function () {\n        var t = this.readWord1(),\n            e = h.name;\n        this.isKeyword(t) && (this.state.containsEsc && this.raise(this.state.pos, \"Escape sequence in keyword \" + t), e = u[t]), !this.state.isIterator || this.isIterator(t) && this.state.inType || this.raise(this.state.pos, \"Invalid identifier \" + t), this.finishToken(e, t);\n      }, s.braceIsBlock = function (t) {\n        var e = this.curContext();\n        return e === D.functionExpression || e === D.functionStatement || (t !== h.colon || e !== D.braceStatement && e !== D.braceExpression ? t === h._return || t === h._yield || t === h.name && this.state.exprAllowed ? c.test(this.input.slice(this.state.lastTokEnd, this.state.start)) : t === h._else || t === h.semi || t === h.eof || t === h.parenR || t === h.arrow || (t === h.braceL ? e === D.braceStatement : t !== h._var && t !== h._let && t !== h._const && (t === h.relational || !this.state.exprAllowed)) : !e.isExpr);\n      }, s.updateContext = function (t) {\n        var e,\n            s = this.state.type;\n        !s.keyword || t !== h.dot && t !== h.questionDot ? (e = s.updateContext) ? e.call(this, t) : this.state.exprAllowed = s.beforeExpr : this.state.exprAllowed = !1;\n      }, e;\n    }(K)),\n        Q = [\"leadingComments\", \"trailingComments\", \"innerComments\"],\n        $ = function () {\n      function t(t, e, s) {\n        this.type = \"\", this.start = e, this.end = 0, this.loc = new V(s), t && t.options.ranges && (this.range = [e, 0]), t && t.filename && (this.loc.filename = t.filename);\n      }\n\n      return t.prototype.__clone = function () {\n        var e = this,\n            s = new t();\n        return Object.keys(this).forEach(function (t) {\n          Q.indexOf(t) < 0 && (s[t] = e[t]);\n        }), s;\n      }, t;\n    }(),\n        Y = [],\n        Z = {\n      kind: \"loop\"\n    },\n        tt = {\n      kind: \"switch\"\n    },\n        et = function (t) {\n      function e(e, s) {\n        var i;\n        return e = function (t) {\n          var e = {};\n\n          for (var s in q) {\n            e[s] = t && null != t[s] ? t[s] : q[s];\n          }\n\n          return e;\n        }(e), (i = t.call(this, e, s) || this).options = e, i.inModule = \"module\" === i.options.sourceType, i.input = s, i.plugins = function (t) {\n          for (var e = Object.create(null), s = 0; s < t.length; s++) {\n            var i = t[s],\n                r = Array.isArray(i) ? i : [i, {}],\n                a = r[0],\n                n = r[1],\n                o = void 0 === n ? {} : n;\n            e[a] || (e[a] = o || {});\n          }\n\n          return e;\n        }(i.options.plugins), i.filename = e.sourceFilename, i;\n      }\n\n      return i(e, t), e.prototype.parse = function () {\n        var t = this.startNode(),\n            e = this.startNode();\n        return this.nextToken(), this.parseTopLevel(t, e);\n      }, e;\n    }(function (t) {\n      function e() {\n        return t.apply(this, arguments) || this;\n      }\n\n      i(e, t);\n      var s = e.prototype;\n      return s.parseTopLevel = function (t, e) {\n        return e.sourceType = this.options.sourceType, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, h.eof), t.program = this.finishNode(e, \"Program\"), t.comments = this.state.comments, this.options.tokens && (t.tokens = this.state.tokens), this.finishNode(t, \"File\");\n      }, s.stmtToDirective = function (t) {\n        var e = t.expression,\n            s = this.startNodeAt(e.start, e.loc.start),\n            i = this.startNodeAt(t.start, t.loc.start),\n            r = this.input.slice(e.start, e.end),\n            a = s.value = r.slice(1, -1);\n        return this.addExtra(s, \"raw\", r), this.addExtra(s, \"rawValue\", a), i.value = this.finishNodeAt(s, \"DirectiveLiteral\", e.end, e.loc.end), this.finishNodeAt(i, \"Directive\", t.end, t.loc.end);\n      }, s.parseInterpreterDirective = function () {\n        if (!this.match(h.interpreterDirective)) return null;\n        var t = this.startNode();\n        return t.value = this.state.value, this.next(), this.finishNode(t, \"InterpreterDirective\");\n      }, s.parseStatement = function (t, e) {\n        return this.match(h.at) && this.parseDecorators(!0), this.parseStatementContent(t, e);\n      }, s.parseStatementContent = function (t, e) {\n        var s = this.state.type,\n            i = this.startNode();\n\n        switch (s) {\n          case h._break:\n          case h._continue:\n            return this.parseBreakContinueStatement(i, s.keyword);\n\n          case h._debugger:\n            return this.parseDebuggerStatement(i);\n\n          case h._do:\n            return this.parseDoStatement(i);\n\n          case h._for:\n            return this.parseForStatement(i);\n\n          case h._function:\n            if (this.lookahead().type === h.dot) break;\n            return t || this.unexpected(), this.parseFunctionStatement(i);\n\n          case h._class:\n            return t || this.unexpected(), this.parseClass(i, !0);\n\n          case h._if:\n            return this.parseIfStatement(i);\n\n          case h._return:\n            return this.parseReturnStatement(i);\n\n          case h._switch:\n            return this.parseSwitchStatement(i);\n\n          case h._throw:\n            return this.parseThrowStatement(i);\n\n          case h._try:\n            return this.parseTryStatement(i);\n\n          case h._let:\n          case h._const:\n            t || this.unexpected();\n\n          case h._var:\n            return this.parseVarStatement(i, s);\n\n          case h._while:\n            return this.parseWhileStatement(i);\n\n          case h._with:\n            return this.parseWithStatement(i);\n\n          case h.braceL:\n            return this.parseBlock();\n\n          case h.semi:\n            return this.parseEmptyStatement(i);\n\n          case h._export:\n          case h._import:\n            var r,\n                a = this.lookahead();\n            if (a.type === h.parenL || a.type === h.dot) break;\n            return this.options.allowImportExportEverywhere || e || this.raise(this.state.start, \"'import' and 'export' may only appear at the top level\"), this.next(), s == h._import ? \"ImportDeclaration\" !== (r = this.parseImport(i)).type || r.importKind && \"value\" !== r.importKind || (this.sawUnambiguousESM = !0) : (\"ExportNamedDeclaration\" !== (r = this.parseExport(i)).type || r.exportKind && \"value\" !== r.exportKind) && (\"ExportAllDeclaration\" !== r.type || r.exportKind && \"value\" !== r.exportKind) && \"ExportDefaultDeclaration\" !== r.type || (this.sawUnambiguousESM = !0), this.assertModuleNodeAllowed(i), r;\n\n          case h.name:\n            if (this.isContextual(\"async\")) {\n              var n = this.state.clone();\n              if (this.next(), this.match(h._function) && !this.canInsertSemicolon()) return this.expect(h._function), this.parseFunction(i, !0, !1, !0);\n              this.state = n;\n            }\n\n        }\n\n        var o = this.state.value,\n            u = this.parseExpression();\n        return s === h.name && \"Identifier\" === u.type && this.eat(h.colon) ? this.parseLabeledStatement(i, o, u) : this.parseExpressionStatement(i, u);\n      }, s.assertModuleNodeAllowed = function (t) {\n        this.options.allowImportExportEverywhere || this.inModule || this.raise(t.start, \"'import' and 'export' may appear only with 'sourceType: \\\"module\\\"'\", {\n          code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n        });\n      }, s.takeDecorators = function (t) {\n        var e = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n        e.length && (t.decorators = e, this.resetStartLocationFromNode(t, e[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);\n      }, s.canHaveLeadingDecorator = function () {\n        return this.match(h._class);\n      }, s.parseDecorators = function (t) {\n        for (var e = this.state.decoratorStack[this.state.decoratorStack.length - 1]; this.match(h.at);) {\n          var s = this.parseDecorator();\n          e.push(s);\n        }\n\n        this.match(h._export) ? (t || this.unexpected(), this.hasPlugin(\"decorators\") && !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") && this.raise(this.state.start, \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\")) : this.canHaveLeadingDecorator() || this.raise(this.state.start, \"Leading decorators must be attached to a class declaration\");\n      }, s.parseDecorator = function () {\n        this.expectOnePlugin([\"decorators-legacy\", \"decorators\"]);\n        var t = this.startNode();\n\n        if (this.next(), this.hasPlugin(\"decorators\")) {\n          this.state.decoratorStack.push([]);\n          var e,\n              s = this.state.start,\n              i = this.state.startLoc;\n          if (this.eat(h.parenL)) e = this.parseExpression(), this.expect(h.parenR);else for (e = this.parseIdentifier(!1); this.eat(h.dot);) {\n            var r = this.startNodeAt(s, i);\n            r.object = e, r.property = this.parseIdentifier(!0), r.computed = !1, e = this.finishNode(r, \"MemberExpression\");\n          }\n          t.expression = this.parseMaybeDecoratorArguments(e), this.state.decoratorStack.pop();\n        } else t.expression = this.parseMaybeAssign();\n\n        return this.finishNode(t, \"Decorator\");\n      }, s.parseMaybeDecoratorArguments = function (t) {\n        if (this.eat(h.parenL)) {\n          var e = this.startNodeAtNode(t);\n          return e.callee = t, e.arguments = this.parseCallExpressionArguments(h.parenR, !1), this.toReferencedList(e.arguments), this.finishNode(e, \"CallExpression\");\n        }\n\n        return t;\n      }, s.parseBreakContinueStatement = function (t, e) {\n        var s,\n            i = \"break\" === e;\n\n        for (this.next(), this.isLineTerminator() ? t.label = null : this.match(h.name) ? (t.label = this.parseIdentifier(), this.semicolon()) : this.unexpected(), s = 0; s < this.state.labels.length; ++s) {\n          var r = this.state.labels[s];\n\n          if (null == t.label || r.name === t.label.name) {\n            if (null != r.kind && (i || \"loop\" === r.kind)) break;\n            if (t.label && i) break;\n          }\n        }\n\n        return s === this.state.labels.length && this.raise(t.start, \"Unsyntactic \" + e), this.finishNode(t, i ? \"BreakStatement\" : \"ContinueStatement\");\n      }, s.parseDebuggerStatement = function (t) {\n        return this.next(), this.semicolon(), this.finishNode(t, \"DebuggerStatement\");\n      }, s.parseDoStatement = function (t) {\n        var e = this;\n        return this.next(), this.state.labels.push(Z), t.body = this.withTopicForbiddingContext(function () {\n          return e.parseStatement(!1);\n        }), this.state.labels.pop(), this.expect(h._while), t.test = this.parseParenExpression(), this.eat(h.semi), this.finishNode(t, \"DoWhileStatement\");\n      }, s.parseForStatement = function (t) {\n        this.next(), this.state.labels.push(Z);\n        var e = !1;\n        if (this.state.inAsync && this.isContextual(\"await\") && (e = !0, this.next()), this.expect(h.parenL), this.match(h.semi)) return e && this.unexpected(), this.parseFor(t, null);\n\n        if (this.match(h._var) || this.match(h._let) || this.match(h._const)) {\n          var s = this.startNode(),\n              i = this.state.type;\n\n          if (this.next(), this.parseVar(s, !0, i), this.finishNode(s, \"VariableDeclaration\"), (this.match(h._in) || this.isContextual(\"of\")) && 1 === s.declarations.length) {\n            var r = s.declarations[0],\n                a = i === h._var && r.init && \"ObjectPattern\" != r.id.type && \"ArrayPattern\" != r.id.type && !this.isContextual(\"of\");\n            if (this.state.strict && a) this.raise(this.state.start, \"for-in initializer in strict mode\");else if (a || !r.init) return this.parseForIn(t, s, e);\n          }\n\n          return e && this.unexpected(), this.parseFor(t, s);\n        }\n\n        var n = {\n          start: 0\n        },\n            o = this.parseExpression(!0, n);\n\n        if (this.match(h._in) || this.isContextual(\"of\")) {\n          var u = this.isContextual(\"of\") ? \"for-of statement\" : \"for-in statement\";\n          return this.toAssignable(o, void 0, u), this.checkLVal(o, void 0, void 0, u), this.parseForIn(t, o, e);\n        }\n\n        return n.start && this.unexpected(n.start), e && this.unexpected(), this.parseFor(t, o);\n      }, s.parseFunctionStatement = function (t) {\n        return this.next(), this.parseFunction(t, !0);\n      }, s.parseIfStatement = function (t) {\n        return this.next(), t.test = this.parseParenExpression(), t.consequent = this.parseStatement(!1), t.alternate = this.eat(h._else) ? this.parseStatement(!1) : null, this.finishNode(t, \"IfStatement\");\n      }, s.parseReturnStatement = function (t) {\n        return this.state.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.state.start, \"'return' outside of function\"), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, \"ReturnStatement\");\n      }, s.parseSwitchStatement = function (t) {\n        this.next(), t.discriminant = this.parseParenExpression();\n        var e,\n            s,\n            i = t.cases = [];\n\n        for (this.expect(h.braceL), this.state.labels.push(tt); !this.match(h.braceR);) {\n          if (this.match(h._case) || this.match(h._default)) {\n            var r = this.match(h._case);\n            e && this.finishNode(e, \"SwitchCase\"), i.push(e = this.startNode()), e.consequent = [], this.next(), r ? e.test = this.parseExpression() : (s && this.raise(this.state.lastTokStart, \"Multiple default clauses\"), s = !0, e.test = null), this.expect(h.colon);\n          } else e ? e.consequent.push(this.parseStatement(!0)) : this.unexpected();\n        }\n\n        return e && this.finishNode(e, \"SwitchCase\"), this.next(), this.state.labels.pop(), this.finishNode(t, \"SwitchStatement\");\n      }, s.parseThrowStatement = function (t) {\n        return this.next(), c.test(this.input.slice(this.state.lastTokEnd, this.state.start)) && this.raise(this.state.lastTokEnd, \"Illegal newline after throw\"), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, \"ThrowStatement\");\n      }, s.parseTryStatement = function (t) {\n        var e = this;\n\n        if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(h._catch)) {\n          var s = this.startNode();\n\n          if (this.next(), this.match(h.parenL)) {\n            this.expect(h.parenL), s.param = this.parseBindingAtom();\n            var i = Object.create(null);\n            this.checkLVal(s.param, !0, i, \"catch clause\"), this.expect(h.parenR);\n          } else s.param = null;\n\n          s.body = this.withTopicForbiddingContext(function () {\n            return e.parseBlock(!1);\n          }), t.handler = this.finishNode(s, \"CatchClause\");\n        }\n\n        return t.guardedHandlers = Y, t.finalizer = this.eat(h._finally) ? this.parseBlock() : null, t.handler || t.finalizer || this.raise(t.start, \"Missing catch or finally clause\"), this.finishNode(t, \"TryStatement\");\n      }, s.parseVarStatement = function (t, e) {\n        return this.next(), this.parseVar(t, !1, e), this.semicolon(), this.finishNode(t, \"VariableDeclaration\");\n      }, s.parseWhileStatement = function (t) {\n        var e = this;\n        return this.next(), t.test = this.parseParenExpression(), this.state.labels.push(Z), t.body = this.withTopicForbiddingContext(function () {\n          return e.parseStatement(!1);\n        }), this.state.labels.pop(), this.finishNode(t, \"WhileStatement\");\n      }, s.parseWithStatement = function (t) {\n        var e = this;\n        return this.state.strict && this.raise(this.state.start, \"'with' in strict mode\"), this.next(), t.object = this.parseParenExpression(), t.body = this.withTopicForbiddingContext(function () {\n          return e.parseStatement(!1);\n        }), this.finishNode(t, \"WithStatement\");\n      }, s.parseEmptyStatement = function (t) {\n        return this.next(), this.finishNode(t, \"EmptyStatement\");\n      }, s.parseLabeledStatement = function (t, e, s) {\n        for (var i = 0, r = this.state.labels; i < r.length; i++) {\n          r[i].name === e && this.raise(s.start, \"Label '\" + e + \"' is already declared\");\n        }\n\n        for (var a = this.state.type.isLoop ? \"loop\" : this.match(h._switch) ? \"switch\" : null, n = this.state.labels.length - 1; n >= 0; n--) {\n          var o = this.state.labels[n];\n          if (o.statementStart !== t.start) break;\n          o.statementStart = this.state.start, o.kind = a;\n        }\n\n        return this.state.labels.push({\n          name: e,\n          kind: a,\n          statementStart: this.state.start\n        }), t.body = this.parseStatement(!0), (\"ClassDeclaration\" == t.body.type || \"VariableDeclaration\" == t.body.type && \"var\" !== t.body.kind || \"FunctionDeclaration\" == t.body.type && (this.state.strict || t.body.generator || t.body.async)) && this.raise(t.body.start, \"Invalid labeled declaration\"), this.state.labels.pop(), t.label = s, this.finishNode(t, \"LabeledStatement\");\n      }, s.parseExpressionStatement = function (t, e) {\n        return t.expression = e, this.semicolon(), this.finishNode(t, \"ExpressionStatement\");\n      }, s.parseBlock = function (t) {\n        var e = this.startNode();\n        return this.expect(h.braceL), this.parseBlockBody(e, t, !1, h.braceR), this.finishNode(e, \"BlockStatement\");\n      }, s.isValidDirective = function (t) {\n        return \"ExpressionStatement\" === t.type && \"StringLiteral\" === t.expression.type && !t.expression.extra.parenthesized;\n      }, s.parseBlockBody = function (t, e, s, i) {\n        var r = t.body = [],\n            a = t.directives = [];\n        this.parseBlockOrModuleBlockBody(r, e ? a : void 0, s, i);\n      }, s.parseBlockOrModuleBlockBody = function (t, e, s, i) {\n        for (var r, a, n = !1; !this.eat(i);) {\n          n || !this.state.containsOctal || a || (a = this.state.octalPosition);\n          var o = this.parseStatement(!0, s);\n\n          if (e && !n && this.isValidDirective(o)) {\n            var h = this.stmtToDirective(o);\n            e.push(h), void 0 === r && \"use strict\" === h.value.value && (r = this.state.strict, this.setStrict(!0), a && this.raise(a, \"Octal literal in strict mode\"));\n          } else n = !0, t.push(o);\n        }\n\n        !1 === r && this.setStrict(!1);\n      }, s.parseFor = function (t, e) {\n        var s = this;\n        return t.init = e, this.expect(h.semi), t.test = this.match(h.semi) ? null : this.parseExpression(), this.expect(h.semi), t.update = this.match(h.parenR) ? null : this.parseExpression(), this.expect(h.parenR), t.body = this.withTopicForbiddingContext(function () {\n          return s.parseStatement(!1);\n        }), this.state.labels.pop(), this.finishNode(t, \"ForStatement\");\n      }, s.parseForIn = function (t, e, s) {\n        var i = this,\n            r = this.match(h._in) ? \"ForInStatement\" : \"ForOfStatement\";\n        return s ? this.eatContextual(\"of\") : this.next(), \"ForOfStatement\" === r && (t.await = !!s), t.left = e, t.right = this.parseExpression(), this.expect(h.parenR), t.body = this.withTopicForbiddingContext(function () {\n          return i.parseStatement(!1);\n        }), this.state.labels.pop(), this.finishNode(t, r);\n      }, s.parseVar = function (t, e, s) {\n        var i = t.declarations = [];\n\n        for (t.kind = s.keyword;;) {\n          var r = this.startNode();\n          if (this.parseVarHead(r), this.eat(h.eq) ? r.init = this.parseMaybeAssign(e) : (s !== h._const || this.match(h._in) || this.isContextual(\"of\") ? \"Identifier\" === r.id.type || e && (this.match(h._in) || this.isContextual(\"of\")) || this.raise(this.state.lastTokEnd, \"Complex binding patterns require an initialization value\") : this.hasPlugin(\"typescript\") || this.unexpected(), r.init = null), i.push(this.finishNode(r, \"VariableDeclarator\")), !this.eat(h.comma)) break;\n        }\n\n        return t;\n      }, s.parseVarHead = function (t) {\n        t.id = this.parseBindingAtom(), this.checkLVal(t.id, !0, void 0, \"variable declaration\");\n      }, s.parseFunction = function (t, e, s, i, r) {\n        var a = this,\n            n = this.state.inFunction,\n            o = this.state.inMethod,\n            u = this.state.inAsync,\n            p = this.state.inGenerator,\n            c = this.state.inClassProperty;\n        return this.state.inFunction = !0, this.state.inMethod = !1, this.state.inClassProperty = !1, this.initFunction(t, i), this.match(h.star) && (t.generator = !0, this.next()), !e || r || this.match(h.name) || this.match(h._yield) || this.unexpected(), e || (this.state.inAsync = i, this.state.inGenerator = t.generator), (this.match(h.name) || this.match(h._yield)) && (t.id = this.parseBindingIdentifier()), e && (this.state.inAsync = i, this.state.inGenerator = t.generator), this.parseFunctionParams(t), this.withTopicForbiddingContext(function () {\n          a.parseFunctionBodyAndFinish(t, e ? \"FunctionDeclaration\" : \"FunctionExpression\", s);\n        }), this.state.inFunction = n, this.state.inMethod = o, this.state.inAsync = u, this.state.inGenerator = p, this.state.inClassProperty = c, t;\n      }, s.parseFunctionParams = function (t, e) {\n        var s = this.state.inParameters;\n        this.state.inParameters = !0, this.expect(h.parenL), t.params = this.parseBindingList(h.parenR, !1, e), this.state.inParameters = s;\n      }, s.parseClass = function (t, e, s) {\n        return this.next(), this.takeDecorators(t), this.parseClassId(t, e, s), this.parseClassSuper(t), this.parseClassBody(t), this.finishNode(t, e ? \"ClassDeclaration\" : \"ClassExpression\");\n      }, s.isClassProperty = function () {\n        return this.match(h.eq) || this.match(h.semi) || this.match(h.braceR);\n      }, s.isClassMethod = function () {\n        return this.match(h.parenL);\n      }, s.isNonstaticConstructor = function (t) {\n        return !(t.computed || t.static || \"constructor\" !== t.key.name && \"constructor\" !== t.key.value);\n      }, s.parseClassBody = function (t) {\n        var e = this,\n            s = this.state.strict;\n        this.state.strict = !0, this.state.classLevel++;\n        var i = {\n          hadConstructor: !1\n        },\n            r = [],\n            a = this.startNode();\n        a.body = [], this.expect(h.braceL), this.withTopicForbiddingContext(function () {\n          for (; !e.eat(h.braceR);) {\n            if (e.eat(h.semi)) r.length > 0 && e.raise(e.state.lastTokEnd, \"Decorators must not be followed by a semicolon\");else if (e.match(h.at)) r.push(e.parseDecorator());else {\n              var t = e.startNode();\n              r.length && (t.decorators = r, e.resetStartLocationFromNode(t, r[0]), r = []), e.parseClassMember(a, t, i), \"constructor\" === t.kind && t.decorators && t.decorators.length > 0 && e.raise(t.start, \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\");\n            }\n          }\n        }), r.length && this.raise(this.state.start, \"You have trailing decorators with no method\"), t.body = this.finishNode(a, \"ClassBody\"), this.state.classLevel--, this.state.strict = s;\n      }, s.parseClassMember = function (t, e, s) {\n        var i = !1,\n            r = this.state.containsEsc;\n\n        if (this.match(h.name) && \"static\" === this.state.value) {\n          var a = this.parseIdentifier(!0);\n\n          if (this.isClassMethod()) {\n            var n = e;\n            return n.kind = \"method\", n.computed = !1, n.key = a, n.static = !1, void this.pushClassMethod(t, n, !1, !1, !1);\n          }\n\n          if (this.isClassProperty()) {\n            var o = e;\n            return o.computed = !1, o.key = a, o.static = !1, void t.body.push(this.parseClassProperty(o));\n          }\n\n          if (r) throw this.unexpected();\n          i = !0;\n        }\n\n        this.parseClassMemberWithIsStatic(t, e, s, i);\n      }, s.parseClassMemberWithIsStatic = function (t, e, s, i) {\n        var r = e,\n            a = e,\n            n = e,\n            o = e,\n            u = r,\n            p = r;\n        if (e.static = i, this.eat(h.star)) return u.kind = \"method\", this.parseClassPropertyName(u), \"PrivateName\" === u.key.type ? void this.pushClassPrivateMethod(t, a, !0, !1) : (this.isNonstaticConstructor(r) && this.raise(r.key.start, \"Constructor can't be a generator\"), void this.pushClassMethod(t, r, !0, !1, !1));\n        var c = this.parseClassPropertyName(e),\n            l = \"PrivateName\" === c.type,\n            d = \"Identifier\" === c.type;\n\n        if (this.parsePostMemberNameModifiers(p), this.isClassMethod()) {\n          if (u.kind = \"method\", l) return void this.pushClassPrivateMethod(t, a, !1, !1);\n          var f = this.isNonstaticConstructor(r);\n          f && (r.kind = \"constructor\", r.decorators && this.raise(r.start, \"You can't attach decorators to a class constructor\"), s.hadConstructor && !this.hasPlugin(\"typescript\") && this.raise(c.start, \"Duplicate constructor in the same class\"), s.hadConstructor = !0), this.pushClassMethod(t, r, !1, !1, f);\n        } else if (this.isClassProperty()) l ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n);else if (d && \"async\" === c.name && !this.isLineTerminator()) {\n          var m = this.eat(h.star);\n          u.kind = \"method\", this.parseClassPropertyName(u), \"PrivateName\" === u.key.type ? this.pushClassPrivateMethod(t, a, m, !0) : (this.isNonstaticConstructor(r) && this.raise(r.key.start, \"Constructor can't be an async function\"), this.pushClassMethod(t, r, m, !0, !1));\n        } else !d || \"get\" !== c.name && \"set\" !== c.name || this.isLineTerminator() && this.match(h.star) ? this.isLineTerminator() ? l ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n) : this.unexpected() : (u.kind = c.name, this.parseClassPropertyName(r), \"PrivateName\" === u.key.type ? this.pushClassPrivateMethod(t, a, !1, !1) : (this.isNonstaticConstructor(r) && this.raise(r.key.start, \"Constructor can't have get/set modifier\"), this.pushClassMethod(t, r, !1, !1, !1)), this.checkGetterSetterParams(r));\n      }, s.parseClassPropertyName = function (t) {\n        var e = this.parsePropertyName(t);\n        return t.computed || !t.static || \"prototype\" !== e.name && \"prototype\" !== e.value || this.raise(e.start, \"Classes may not have static property named prototype\"), \"PrivateName\" === e.type && \"constructor\" === e.id.name && this.raise(e.start, \"Classes may not have a private field named '#constructor'\"), e;\n      }, s.pushClassProperty = function (t, e) {\n        this.isNonstaticConstructor(e) && this.raise(e.key.start, \"Classes may not have a non-static field named 'constructor'\"), t.body.push(this.parseClassProperty(e));\n      }, s.pushClassPrivateProperty = function (t, e) {\n        this.expectPlugin(\"classPrivateProperties\", e.key.start), t.body.push(this.parseClassPrivateProperty(e));\n      }, s.pushClassMethod = function (t, e, s, i, r) {\n        t.body.push(this.parseMethod(e, s, i, r, \"ClassMethod\"));\n      }, s.pushClassPrivateMethod = function (t, e, s, i) {\n        this.expectPlugin(\"classPrivateMethods\", e.key.start), t.body.push(this.parseMethod(e, s, i, !1, \"ClassPrivateMethod\"));\n      }, s.parsePostMemberNameModifiers = function (t) {}, s.parseAccessModifier = function () {}, s.parseClassPrivateProperty = function (t) {\n        var e = this.state.inMethod;\n        return this.state.inMethod = !1, this.state.inClassProperty = !0, t.value = this.eat(h.eq) ? this.parseMaybeAssign() : null, this.semicolon(), this.state.inClassProperty = !1, this.state.inMethod = e, this.finishNode(t, \"ClassPrivateProperty\");\n      }, s.parseClassProperty = function (t) {\n        t.typeAnnotation || this.expectPlugin(\"classProperties\");\n        var e = this.state.inMethod;\n        return this.state.inMethod = !1, this.state.inClassProperty = !0, this.match(h.eq) ? (this.expectPlugin(\"classProperties\"), this.next(), t.value = this.parseMaybeAssign()) : t.value = null, this.semicolon(), this.state.inClassProperty = !1, this.state.inMethod = e, this.finishNode(t, \"ClassProperty\");\n      }, s.parseClassId = function (t, e, s) {\n        this.match(h.name) ? t.id = this.parseIdentifier() : s || !e ? t.id = null : this.unexpected(null, \"A class name is required\");\n      }, s.parseClassSuper = function (t) {\n        t.superClass = this.eat(h._extends) ? this.parseExprSubscripts() : null;\n      }, s.parseExport = function (t) {\n        if (this.shouldParseExportStar()) {\n          if (this.parseExportStar(t), \"ExportAllDeclaration\" === t.type) return t;\n        } else if (this.isExportDefaultSpecifier()) {\n          this.expectPlugin(\"exportDefaultFrom\");\n          var e = this.startNode();\n          e.exported = this.parseIdentifier(!0);\n          var s = [this.finishNode(e, \"ExportDefaultSpecifier\")];\n\n          if (t.specifiers = s, this.match(h.comma) && this.lookahead().type === h.star) {\n            this.expect(h.comma);\n            var i = this.startNode();\n            this.expect(h.star), this.expectContextual(\"as\"), i.exported = this.parseIdentifier(), s.push(this.finishNode(i, \"ExportNamespaceSpecifier\"));\n          } else this.parseExportSpecifiersMaybe(t);\n\n          this.parseExportFrom(t, !0);\n        } else {\n          if (this.eat(h._default)) return t.declaration = this.parseExportDefaultExpression(), this.checkExport(t, !0, !0), this.finishNode(t, \"ExportDefaultDeclaration\");\n\n          if (this.shouldParseExportDeclaration()) {\n            if (this.isContextual(\"async\")) {\n              var r = this.lookahead();\n              r.type !== h._function && this.unexpected(r.start, 'Unexpected token, expected \"function\"');\n            }\n\n            t.specifiers = [], t.source = null, t.declaration = this.parseExportDeclaration(t);\n          } else t.declaration = null, t.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(t);\n        }\n\n        return this.checkExport(t, !0), this.finishNode(t, \"ExportNamedDeclaration\");\n      }, s.isAsyncFunction = function () {\n        if (!this.isContextual(\"async\")) return !1;\n        var t = this.state,\n            e = t.input,\n            s = t.pos;\n        f.lastIndex = s;\n        var i = f.exec(e);\n        if (!i || !i.length) return !1;\n        var r = s + i[0].length;\n        return !(c.test(e.slice(s, r)) || \"function\" !== e.slice(r, r + 8) || r + 8 !== e.length && k(e.charAt(r + 8)));\n      }, s.parseExportDefaultExpression = function () {\n        var t = this.startNode(),\n            e = this.isAsyncFunction();\n        if (this.eat(h._function) || e) return e && (this.eatContextual(\"async\"), this.expect(h._function)), this.parseFunction(t, !0, !1, e, !0);\n        if (this.match(h._class)) return this.parseClass(t, !0, !0);\n        if (this.match(h.at)) return this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") && this.unexpected(this.state.start, \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax\"), this.parseDecorators(!1), this.parseClass(t, !0, !0);\n        if (this.match(h._let) || this.match(h._const) || this.match(h._var)) return this.raise(this.state.start, \"Only expressions, functions or classes are allowed as the `default` export.\");\n        var s = this.parseMaybeAssign();\n        return this.semicolon(), s;\n      }, s.parseExportDeclaration = function (t) {\n        return this.parseStatement(!0);\n      }, s.isExportDefaultSpecifier = function () {\n        if (this.match(h.name)) return \"async\" !== this.state.value;\n        if (!this.match(h._default)) return !1;\n        var t = this.lookahead();\n        return t.type === h.comma || t.type === h.name && \"from\" === t.value;\n      }, s.parseExportSpecifiersMaybe = function (t) {\n        this.eat(h.comma) && (t.specifiers = t.specifiers.concat(this.parseExportSpecifiers()));\n      }, s.parseExportFrom = function (t, e) {\n        this.eatContextual(\"from\") ? (t.source = this.match(h.string) ? this.parseExprAtom() : this.unexpected(), this.checkExport(t)) : e ? this.unexpected() : t.source = null, this.semicolon();\n      }, s.shouldParseExportStar = function () {\n        return this.match(h.star);\n      }, s.parseExportStar = function (t) {\n        this.expect(h.star), this.isContextual(\"as\") ? this.parseExportNamespace(t) : (this.parseExportFrom(t, !0), this.finishNode(t, \"ExportAllDeclaration\"));\n      }, s.parseExportNamespace = function (t) {\n        this.expectPlugin(\"exportNamespaceFrom\");\n        var e = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);\n        this.next(), e.exported = this.parseIdentifier(!0), t.specifiers = [this.finishNode(e, \"ExportNamespaceSpecifier\")], this.parseExportSpecifiersMaybe(t), this.parseExportFrom(t, !0);\n      }, s.shouldParseExportDeclaration = function () {\n        if (this.match(h.at) && (this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]), this.hasPlugin(\"decorators\"))) {\n          if (!this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) return !0;\n          this.unexpected(this.state.start, \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax\");\n        }\n\n        return \"var\" === this.state.type.keyword || \"const\" === this.state.type.keyword || \"let\" === this.state.type.keyword || \"function\" === this.state.type.keyword || \"class\" === this.state.type.keyword || this.isAsyncFunction();\n      }, s.checkExport = function (t, e, s) {\n        if (e) if (s) this.checkDuplicateExports(t, \"default\");else if (t.specifiers && t.specifiers.length) for (var i = 0, r = t.specifiers; i < r.length; i++) {\n          var a = r[i];\n          this.checkDuplicateExports(a, a.exported.name);\n        } else if (t.declaration) if (\"FunctionDeclaration\" === t.declaration.type || \"ClassDeclaration\" === t.declaration.type) {\n          var n = t.declaration.id;\n          if (!n) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(t, n.name);\n        } else if (\"VariableDeclaration\" === t.declaration.type) for (var o = 0, h = t.declaration.declarations; o < h.length; o++) {\n          var u = h[o];\n          this.checkDeclaration(u.id);\n        }\n\n        if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length) {\n          var p = t.declaration && (\"ClassDeclaration\" === t.declaration.type || \"ClassExpression\" === t.declaration.type);\n          if (!t.declaration || !p) throw this.raise(t.start, \"You can only use decorators on an export when exporting a class\");\n          this.takeDecorators(t.declaration);\n        }\n      }, s.checkDeclaration = function (t) {\n        if (\"ObjectPattern\" === t.type) for (var e = 0, s = t.properties; e < s.length; e++) {\n          var i = s[e];\n          this.checkDeclaration(i);\n        } else if (\"ArrayPattern\" === t.type) for (var r = 0, a = t.elements; r < a.length; r++) {\n          var n = a[r];\n          n && this.checkDeclaration(n);\n        } else \"ObjectProperty\" === t.type ? this.checkDeclaration(t.value) : \"RestElement\" === t.type ? this.checkDeclaration(t.argument) : \"Identifier\" === t.type && this.checkDuplicateExports(t, t.name);\n      }, s.checkDuplicateExports = function (t, e) {\n        this.state.exportedIdentifiers.indexOf(e) > -1 && this.raiseDuplicateExportError(t, e), this.state.exportedIdentifiers.push(e);\n      }, s.raiseDuplicateExportError = function (t, e) {\n        throw this.raise(t.start, \"default\" === e ? \"Only one default export allowed per module.\" : \"`\" + e + \"` has already been exported. Exported identifiers must be unique.\");\n      }, s.parseExportSpecifiers = function () {\n        var t,\n            e = [],\n            s = !0;\n\n        for (this.expect(h.braceL); !this.eat(h.braceR);) {\n          if (s) s = !1;else if (this.expect(h.comma), this.eat(h.braceR)) break;\n          var i = this.match(h._default);\n          i && !t && (t = !0);\n          var r = this.startNode();\n          r.local = this.parseIdentifier(i), r.exported = this.eatContextual(\"as\") ? this.parseIdentifier(!0) : r.local.__clone(), e.push(this.finishNode(r, \"ExportSpecifier\"));\n        }\n\n        return t && !this.isContextual(\"from\") && this.unexpected(), e;\n      }, s.parseImport = function (t) {\n        return this.match(h.string) ? (t.specifiers = [], t.source = this.parseExprAtom()) : (t.specifiers = [], this.parseImportSpecifiers(t), this.expectContextual(\"from\"), t.source = this.match(h.string) ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(t, \"ImportDeclaration\");\n      }, s.shouldParseDefaultImport = function (t) {\n        return this.match(h.name);\n      }, s.parseImportSpecifierLocal = function (t, e, s, i) {\n        e.local = this.parseIdentifier(), this.checkLVal(e.local, !0, void 0, i), t.specifiers.push(this.finishNode(e, s));\n      }, s.parseImportSpecifiers = function (t) {\n        var e = !0;\n\n        if (!this.shouldParseDefaultImport(t) || (this.parseImportSpecifierLocal(t, this.startNode(), \"ImportDefaultSpecifier\", \"default import specifier\"), this.eat(h.comma))) {\n          if (this.match(h.star)) {\n            var s = this.startNode();\n            return this.next(), this.expectContextual(\"as\"), void this.parseImportSpecifierLocal(t, s, \"ImportNamespaceSpecifier\", \"import namespace specifier\");\n          }\n\n          for (this.expect(h.braceL); !this.eat(h.braceR);) {\n            if (e) e = !1;else if (this.eat(h.colon) && this.unexpected(null, \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\"), this.expect(h.comma), this.eat(h.braceR)) break;\n            this.parseImportSpecifier(t);\n          }\n        }\n      }, s.parseImportSpecifier = function (t) {\n        var e = this.startNode();\n        e.imported = this.parseIdentifier(!0), this.eatContextual(\"as\") ? e.local = this.parseIdentifier() : (this.checkReservedWord(e.imported.name, e.start, !0, !0), e.local = e.imported.__clone()), this.checkLVal(e.local, !0, void 0, \"import specifier\"), t.specifiers.push(this.finishNode(e, \"ImportSpecifier\"));\n      }, e;\n    }(function (t) {\n      function e() {\n        return t.apply(this, arguments) || this;\n      }\n\n      i(e, t);\n      var s = e.prototype;\n      return s.checkPropClash = function (t, e) {\n        if (!t.computed && !t.kind) {\n          var s = t.key;\n          \"__proto__\" === (\"Identifier\" === s.type ? s.name : String(s.value)) && (e.proto && this.raise(s.start, \"Redefinition of __proto__ property\"), e.proto = !0);\n        }\n      }, s.getExpression = function () {\n        this.nextToken();\n        var t = this.parseExpression();\n        return this.match(h.eof) || this.unexpected(), t.comments = this.state.comments, t;\n      }, s.parseExpression = function (t, e) {\n        var s = this.state.start,\n            i = this.state.startLoc,\n            r = this.parseMaybeAssign(t, e);\n\n        if (this.match(h.comma)) {\n          var a = this.startNodeAt(s, i);\n\n          for (a.expressions = [r]; this.eat(h.comma);) {\n            a.expressions.push(this.parseMaybeAssign(t, e));\n          }\n\n          return this.toReferencedList(a.expressions), this.finishNode(a, \"SequenceExpression\");\n        }\n\n        return r;\n      }, s.parseMaybeAssign = function (t, e, s, i) {\n        var r,\n            a = this.state.start,\n            n = this.state.startLoc;\n\n        if (this.match(h._yield) && this.state.inGenerator) {\n          var o = this.parseYield();\n          return s && (o = s.call(this, o, a, n)), o;\n        }\n\n        e ? r = !1 : (e = {\n          start: 0\n        }, r = !0), (this.match(h.parenL) || this.match(h.name) || this.match(h._yield)) && (this.state.potentialArrowAt = this.state.start);\n        var u = this.parseMaybeConditional(t, e, i);\n\n        if (s && (u = s.call(this, u, a, n)), this.state.type.isAssign) {\n          var p,\n              c = this.startNodeAt(a, n),\n              l = this.state.value;\n          if (c.operator = l, \"??=\" === l && (this.expectPlugin(\"nullishCoalescingOperator\"), this.expectPlugin(\"logicalAssignment\")), \"||=\" !== l && \"&&=\" !== l || this.expectPlugin(\"logicalAssignment\"), c.left = this.match(h.eq) ? this.toAssignable(u, void 0, \"assignment expression\") : u, e.start = 0, this.checkLVal(u, void 0, void 0, \"assignment expression\"), u.extra && u.extra.parenthesized) \"ObjectPattern\" === u.type ? p = \"`({a}) = 0` use `({a} = 0)`\" : \"ArrayPattern\" === u.type && (p = \"`([a]) = 0` use `([a] = 0)`\"), p && this.raise(u.start, \"You're trying to assign to a parenthesized expression, eg. instead of \" + p);\n          return this.next(), c.right = this.parseMaybeAssign(t), this.finishNode(c, \"AssignmentExpression\");\n        }\n\n        return r && e.start && this.unexpected(e.start), u;\n      }, s.parseMaybeConditional = function (t, e, s) {\n        var i = this.state.start,\n            r = this.state.startLoc,\n            a = this.state.potentialArrowAt,\n            n = this.parseExprOps(t, e);\n        return \"ArrowFunctionExpression\" === n.type && n.start === a ? n : e && e.start ? n : this.parseConditional(n, t, i, r, s);\n      }, s.parseConditional = function (t, e, s, i, r) {\n        if (this.eat(h.question)) {\n          var a = this.startNodeAt(s, i);\n          return a.test = t, a.consequent = this.parseMaybeAssign(), this.expect(h.colon), a.alternate = this.parseMaybeAssign(e), this.finishNode(a, \"ConditionalExpression\");\n        }\n\n        return t;\n      }, s.parseExprOps = function (t, e) {\n        var s = this.state.start,\n            i = this.state.startLoc,\n            r = this.state.potentialArrowAt,\n            a = this.parseMaybeUnary(e);\n        return \"ArrowFunctionExpression\" === a.type && a.start === r ? a : e && e.start ? a : this.parseExprOp(a, s, i, -1, t);\n      }, s.parseExprOp = function (t, e, s, i, r) {\n        var a = this.state.type.binop;\n\n        if (!(null == a || r && this.match(h._in)) && a > i) {\n          var n = this.startNodeAt(e, s),\n              o = this.state.value;\n          n.left = t, n.operator = o, \"**\" !== o || \"UnaryExpression\" !== t.type || t.extra && t.extra.parenthesized || this.raise(t.argument.start, \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\");\n          var u = this.state.type;\n          if (u === h.pipeline ? (this.expectPlugin(\"pipelineOperator\"), this.state.inPipeline = !0, this.checkPipelineAtInfixOperator(t, e)) : u === h.nullishCoalescing && this.expectPlugin(\"nullishCoalescingOperator\"), this.next(), u === h.pipeline && \"minimal\" === this.getPluginOption(\"pipelineOperator\", \"proposal\") && this.match(h.name) && \"await\" === this.state.value && this.state.inAsync) throw this.raise(this.state.start, 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal');\n          return n.right = this.parseExprOpRightExpr(u, a, r), this.finishNode(n, u === h.logicalOR || u === h.logicalAND || u === h.nullishCoalescing ? \"LogicalExpression\" : \"BinaryExpression\"), this.parseExprOp(n, e, s, i, r);\n        }\n\n        return t;\n      }, s.parseExprOpRightExpr = function (t, e, s) {\n        var i = this;\n\n        switch (t) {\n          case h.pipeline:\n            if (\"smart\" === this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n              var r = this.state.start,\n                  a = this.state.startLoc;\n              return this.withTopicPermittingContext(function () {\n                return i.parseSmartPipelineBody(i.parseExprOpBaseRightExpr(t, e, s), r, a);\n              });\n            }\n\n          default:\n            return this.parseExprOpBaseRightExpr(t, e, s);\n        }\n      }, s.parseExprOpBaseRightExpr = function (t, e, s) {\n        var i = this.state.start,\n            r = this.state.startLoc;\n        return this.parseExprOp(this.parseMaybeUnary(), i, r, t.rightAssociative ? e - 1 : e, s);\n      }, s.parseMaybeUnary = function (t) {\n        if (this.state.type.prefix) {\n          var e = this.startNode(),\n              s = this.match(h.incDec);\n          if (e.operator = this.state.value, e.prefix = !0, \"throw\" === e.operator && this.expectPlugin(\"throwExpressions\"), this.next(), e.argument = this.parseMaybeUnary(), t && t.start && this.unexpected(t.start), s) this.checkLVal(e.argument, void 0, void 0, \"prefix operation\");else if (this.state.strict && \"delete\" === e.operator) {\n            var i = e.argument;\n            \"Identifier\" === i.type ? this.raise(e.start, \"Deleting local variable in strict mode\") : \"MemberExpression\" === i.type && \"PrivateName\" === i.property.type && this.raise(e.start, \"Deleting a private field is not allowed\");\n          }\n          return this.finishNode(e, s ? \"UpdateExpression\" : \"UnaryExpression\");\n        }\n\n        var r = this.state.start,\n            a = this.state.startLoc,\n            n = this.parseExprSubscripts(t);\n        if (t && t.start) return n;\n\n        for (; this.state.type.postfix && !this.canInsertSemicolon();) {\n          var o = this.startNodeAt(r, a);\n          o.operator = this.state.value, o.prefix = !1, o.argument = n, this.checkLVal(n, void 0, void 0, \"postfix operation\"), this.next(), n = this.finishNode(o, \"UpdateExpression\");\n        }\n\n        return n;\n      }, s.parseExprSubscripts = function (t) {\n        var e = this.state.start,\n            s = this.state.startLoc,\n            i = this.state.potentialArrowAt,\n            r = this.parseExprAtom(t);\n        return \"ArrowFunctionExpression\" === r.type && r.start === i ? r : t && t.start ? r : this.parseSubscripts(r, e, s);\n      }, s.parseSubscripts = function (t, e, s, i) {\n        var r = {\n          optionalChainMember: !1,\n          stop: !1\n        };\n\n        do {\n          t = this.parseSubscript(t, e, s, i, r);\n        } while (!r.stop);\n\n        return t;\n      }, s.parseSubscript = function (t, e, s, i, r) {\n        if (!i && this.eat(h.doubleColon)) {\n          var a = this.startNodeAt(e, s);\n          return a.object = t, a.callee = this.parseNoCallExpr(), r.stop = !0, this.parseSubscripts(this.finishNode(a, \"BindExpression\"), e, s, i);\n        }\n\n        if (this.match(h.questionDot)) {\n          if (this.expectPlugin(\"optionalChaining\"), r.optionalChainMember = !0, i && this.lookahead().type == h.parenL) return r.stop = !0, t;\n          this.next();\n          var n = this.startNodeAt(e, s);\n          if (this.eat(h.bracketL)) return n.object = t, n.property = this.parseExpression(), n.computed = !0, n.optional = !0, this.expect(h.bracketR), this.finishNode(n, \"OptionalMemberExpression\");\n\n          if (this.eat(h.parenL)) {\n            var o = this.atPossibleAsync(t);\n            return n.callee = t, n.arguments = this.parseCallExpressionArguments(h.parenR, o), n.optional = !0, this.finishNode(n, \"OptionalCallExpression\");\n          }\n\n          return n.object = t, n.property = this.parseIdentifier(!0), n.computed = !1, n.optional = !0, this.finishNode(n, \"OptionalMemberExpression\");\n        }\n\n        if (this.eat(h.dot)) {\n          var u = this.startNodeAt(e, s);\n          return u.object = t, u.property = this.parseMaybePrivateName(), u.computed = !1, r.optionalChainMember ? (u.optional = !1, this.finishNode(u, \"OptionalMemberExpression\")) : this.finishNode(u, \"MemberExpression\");\n        }\n\n        if (this.eat(h.bracketL)) {\n          var p = this.startNodeAt(e, s);\n          return p.object = t, p.property = this.parseExpression(), p.computed = !0, this.expect(h.bracketR), r.optionalChainMember ? (p.optional = !1, this.finishNode(p, \"OptionalMemberExpression\")) : this.finishNode(p, \"MemberExpression\");\n        }\n\n        if (!i && this.match(h.parenL)) {\n          var c = this.state.maybeInArrowParameters,\n              l = this.state.yieldOrAwaitInPossibleArrowParameters;\n          this.state.maybeInArrowParameters = !0, this.state.yieldOrAwaitInPossibleArrowParameters = null;\n          var d = this.atPossibleAsync(t);\n          this.next();\n          var f = this.startNodeAt(e, s);\n          f.callee = t;\n          var m = {\n            start: -1\n          };\n          return f.arguments = this.parseCallExpressionArguments(h.parenR, d, m), r.optionalChainMember ? this.finishOptionalCallExpression(f) : this.finishCallExpression(f), d && this.shouldParseAsyncArrow() ? (r.stop = !0, m.start > -1 && this.raise(m.start, \"A trailing comma is not permitted after the rest element\"), f = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e, s), f), this.state.yieldOrAwaitInPossibleArrowParameters = l) : (this.toReferencedListDeep(f.arguments), this.state.yieldOrAwaitInPossibleArrowParameters = this.state.yieldOrAwaitInPossibleArrowParameters || l), this.state.maybeInArrowParameters = c, f;\n        }\n\n        return this.match(h.backQuote) ? this.parseTaggedTemplateExpression(e, s, t, r) : (r.stop = !0, t);\n      }, s.parseTaggedTemplateExpression = function (t, e, s, i, r) {\n        var a = this.startNodeAt(t, e);\n        return a.tag = s, a.quasi = this.parseTemplate(!0), r && (a.typeParameters = r), i.optionalChainMember && this.raise(t, \"Tagged Template Literals are not allowed in optionalChain\"), this.finishNode(a, \"TaggedTemplateExpression\");\n      }, s.atPossibleAsync = function (t) {\n        return !this.state.containsEsc && this.state.potentialArrowAt === t.start && \"Identifier\" === t.type && \"async\" === t.name && !this.canInsertSemicolon();\n      }, s.finishCallExpression = function (t) {\n        if (\"Import\" === t.callee.type) {\n          1 !== t.arguments.length && this.raise(t.start, \"import() requires exactly one argument\");\n          var e = t.arguments[0];\n          e && \"SpreadElement\" === e.type && this.raise(e.start, \"... is not allowed in import()\");\n        }\n\n        return this.finishNode(t, \"CallExpression\");\n      }, s.finishOptionalCallExpression = function (t) {\n        if (\"Import\" === t.callee.type) {\n          1 !== t.arguments.length && this.raise(t.start, \"import() requires exactly one argument\");\n          var e = t.arguments[0];\n          e && \"SpreadElement\" === e.type && this.raise(e.start, \"... is not allowed in import()\");\n        }\n\n        return this.finishNode(t, \"OptionalCallExpression\");\n      }, s.parseCallExpressionArguments = function (t, e, s) {\n        for (var i, r = [], a = !0; !this.eat(t);) {\n          if (a) a = !1;else if (this.expect(h.comma), this.eat(t)) break;\n          this.match(h.parenL) && !i && (i = this.state.start), r.push(this.parseExprListItem(!1, e ? {\n            start: 0\n          } : void 0, e ? {\n            start: 0\n          } : void 0, e ? s : void 0));\n        }\n\n        return e && i && this.shouldParseAsyncArrow() && this.unexpected(), r;\n      }, s.shouldParseAsyncArrow = function () {\n        return this.match(h.arrow);\n      }, s.parseAsyncArrowFromCallExpression = function (t, e) {\n        return this.expect(h.arrow), this.parseArrowExpression(t, e.arguments, !0), t;\n      }, s.parseNoCallExpr = function () {\n        var t = this.state.start,\n            e = this.state.startLoc;\n        return this.parseSubscripts(this.parseExprAtom(), t, e, !0);\n      }, s.parseExprAtom = function (t) {\n        this.state.type === h.slash && this.readRegexp();\n        var e,\n            s = this.state.potentialArrowAt === this.state.start;\n\n        switch (this.state.type) {\n          case h._super:\n            return this.state.inMethod || this.state.inClassProperty || this.options.allowSuperOutsideMethod || this.raise(this.state.start, \"super is only allowed in object methods and classes\"), e = this.startNode(), this.next(), this.match(h.parenL) || this.match(h.bracketL) || this.match(h.dot) || this.unexpected(), this.match(h.parenL) && \"constructor\" !== this.state.inMethod && !this.options.allowSuperOutsideMethod && this.raise(e.start, \"super() is only valid inside a class constructor. Make sure the method name is spelled exactly as 'constructor'.\"), this.finishNode(e, \"Super\");\n\n          case h._import:\n            return this.lookahead().type === h.dot ? this.parseImportMetaProperty() : (this.expectPlugin(\"dynamicImport\"), e = this.startNode(), this.next(), this.match(h.parenL) || this.unexpected(null, h.parenL), this.finishNode(e, \"Import\"));\n\n          case h._this:\n            return e = this.startNode(), this.next(), this.finishNode(e, \"ThisExpression\");\n\n          case h._yield:\n            this.state.inGenerator && this.unexpected();\n\n          case h.name:\n            e = this.startNode();\n            var i = \"await\" === this.state.value && (this.state.inAsync || !this.state.inFunction && this.options.allowAwaitOutsideFunction),\n                r = this.state.containsEsc,\n                a = this.shouldAllowYieldIdentifier(),\n                n = this.parseIdentifier(i || a);\n\n            if (\"await\" === n.name) {\n              if (this.state.inAsync || this.inModule || !this.state.inFunction && this.options.allowAwaitOutsideFunction) return this.parseAwait(e);\n            } else {\n              if (!r && \"async\" === n.name && this.match(h._function) && !this.canInsertSemicolon()) return this.next(), this.parseFunction(e, !1, !1, !0);\n\n              if (s && !this.canInsertSemicolon() && \"async\" === n.name && this.match(h.name)) {\n                var o = this.state.yieldOrAwaitInPossibleArrowParameters,\n                    u = this.state.inAsync;\n                this.state.yieldOrAwaitInPossibleArrowParameters = null, this.state.inAsync = !0;\n                var p = [this.parseIdentifier()];\n                return this.expect(h.arrow), this.parseArrowExpression(e, p, !0), this.state.yieldOrAwaitInPossibleArrowParameters = o, this.state.inAsync = u, e;\n              }\n            }\n\n            if (s && !this.canInsertSemicolon() && this.eat(h.arrow)) {\n              var c = this.state.yieldOrAwaitInPossibleArrowParameters;\n              return this.state.yieldOrAwaitInPossibleArrowParameters = null, this.parseArrowExpression(e, [n]), this.state.yieldOrAwaitInPossibleArrowParameters = c, e;\n            }\n\n            return n;\n\n          case h._do:\n            this.expectPlugin(\"doExpressions\");\n            var l = this.startNode();\n            this.next();\n            var d = this.state.inFunction,\n                f = this.state.labels;\n            return this.state.labels = [], this.state.inFunction = !1, l.body = this.parseBlock(!1), this.state.inFunction = d, this.state.labels = f, this.finishNode(l, \"DoExpression\");\n\n          case h.regexp:\n            var m = this.state.value;\n            return (e = this.parseLiteral(m.value, \"RegExpLiteral\")).pattern = m.pattern, e.flags = m.flags, e;\n\n          case h.num:\n            return this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n          case h.bigint:\n            return this.parseLiteral(this.state.value, \"BigIntLiteral\");\n\n          case h.string:\n            return this.parseLiteral(this.state.value, \"StringLiteral\");\n\n          case h._null:\n            return e = this.startNode(), this.next(), this.finishNode(e, \"NullLiteral\");\n\n          case h._true:\n          case h._false:\n            return this.parseBooleanLiteral();\n\n          case h.parenL:\n            return this.parseParenAndDistinguishExpression(s);\n\n          case h.bracketL:\n            return e = this.startNode(), this.next(), e.elements = this.parseExprList(h.bracketR, !0, t), this.state.maybeInArrowParameters || this.toReferencedList(e.elements), this.finishNode(e, \"ArrayExpression\");\n\n          case h.braceL:\n            return this.parseObj(!1, t);\n\n          case h._function:\n            return this.parseFunctionExpression();\n\n          case h.at:\n            this.parseDecorators();\n\n          case h._class:\n            return e = this.startNode(), this.takeDecorators(e), this.parseClass(e, !1);\n\n          case h._new:\n            return this.parseNew();\n\n          case h.backQuote:\n            return this.parseTemplate(!1);\n\n          case h.doubleColon:\n            e = this.startNode(), this.next(), e.object = null;\n            var y = e.callee = this.parseNoCallExpr();\n            if (\"MemberExpression\" === y.type) return this.finishNode(e, \"BindExpression\");\n            throw this.raise(y.start, \"Binding should be performed on object property.\");\n\n          case h.hash:\n            if (this.state.inPipeline) {\n              if (e = this.startNode(), \"smart\" !== this.getPluginOption(\"pipelineOperator\", \"proposal\") && this.raise(e.start, \"Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.\"), this.next(), this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) return this.registerTopicReference(), this.finishNode(e, \"PipelinePrimaryTopicReference\");\n              throw this.raise(e.start, \"Topic reference was used in a lexical context without topic binding\");\n            }\n\n          default:\n            throw this.unexpected();\n        }\n      }, s.parseBooleanLiteral = function () {\n        var t = this.startNode();\n        return t.value = this.match(h._true), this.next(), this.finishNode(t, \"BooleanLiteral\");\n      }, s.parseMaybePrivateName = function () {\n        if (this.match(h.hash)) {\n          this.expectOnePlugin([\"classPrivateProperties\", \"classPrivateMethods\"]);\n          var t = this.startNode(),\n              e = this.state.end;\n          this.next();\n          var s = this.state.start;\n          return 0 != s - e && this.raise(s, \"Unexpected space between # and identifier\"), t.id = this.parseIdentifier(!0), this.finishNode(t, \"PrivateName\");\n        }\n\n        return this.parseIdentifier(!0);\n      }, s.parseFunctionExpression = function () {\n        var t = this.startNode(),\n            e = this.startNode();\n        return this.next(), e = this.createIdentifier(e, \"function\"), this.state.inGenerator && this.eat(h.dot) ? this.parseMetaProperty(t, e, \"sent\") : this.parseFunction(t, !1);\n      }, s.parseMetaProperty = function (t, e, s) {\n        t.meta = e, \"function\" === e.name && \"sent\" === s && (this.isContextual(s) ? this.expectPlugin(\"functionSent\") : this.hasPlugin(\"functionSent\") || this.unexpected());\n        var i = this.state.containsEsc;\n        return t.property = this.parseIdentifier(!0), (t.property.name !== s || i) && this.raise(t.property.start, \"The only valid meta property for \" + e.name + \" is \" + e.name + \".\" + s), this.finishNode(t, \"MetaProperty\");\n      }, s.parseImportMetaProperty = function () {\n        var t = this.startNode(),\n            e = this.parseIdentifier(!0);\n        return this.expect(h.dot), \"import\" === e.name && (this.isContextual(\"meta\") ? this.expectPlugin(\"importMeta\") : this.hasPlugin(\"importMeta\") || this.raise(e.start, \"Dynamic imports require a parameter: import('a.js')\")), this.inModule || this.raise(e.start, \"import.meta may appear only with 'sourceType: \\\"module\\\"'\", {\n          code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n        }), this.sawUnambiguousESM = !0, this.parseMetaProperty(t, e, \"meta\");\n      }, s.parseLiteral = function (t, e, s, i) {\n        s = s || this.state.start, i = i || this.state.startLoc;\n        var r = this.startNodeAt(s, i);\n        return this.addExtra(r, \"rawValue\", t), this.addExtra(r, \"raw\", this.input.slice(s, this.state.end)), r.value = t, this.next(), this.finishNode(r, e);\n      }, s.parseParenExpression = function () {\n        this.expect(h.parenL);\n        var t = this.parseExpression();\n        return this.expect(h.parenR), t;\n      }, s.parseParenAndDistinguishExpression = function (t) {\n        var e,\n            s = this.state.start,\n            i = this.state.startLoc;\n        this.expect(h.parenL);\n        var r = this.state.maybeInArrowParameters,\n            a = this.state.yieldOrAwaitInPossibleArrowParameters;\n        this.state.maybeInArrowParameters = !0, this.state.yieldOrAwaitInPossibleArrowParameters = null;\n\n        for (var n, o, u = this.state.start, p = this.state.startLoc, c = [], l = {\n          start: 0\n        }, d = {\n          start: 0\n        }, f = !0; !this.match(h.parenR);) {\n          if (f) f = !1;else if (this.expect(h.comma, d.start || null), this.match(h.parenR)) {\n            o = this.state.start;\n            break;\n          }\n\n          if (this.match(h.ellipsis)) {\n            var m = this.state.start,\n                y = this.state.startLoc;\n\n            if (n = this.state.start, c.push(this.parseParenItem(this.parseRest(), m, y)), this.match(h.comma)) {\n              var D = this.lookahead().type === h.parenR ? \"A trailing comma is not permitted after the rest element\" : \"Rest parameter must be last formal parameter\";\n              this.raise(this.state.start, D);\n            }\n\n            break;\n          }\n\n          c.push(this.parseMaybeAssign(!1, l, this.parseParenItem, d));\n        }\n\n        var x = this.state.start,\n            v = this.state.startLoc;\n        this.expect(h.parenR), this.state.maybeInArrowParameters = r;\n        var P = this.startNodeAt(s, i);\n\n        if (t && this.shouldParseArrow() && (P = this.parseArrow(P))) {\n          for (var g = 0; g < c.length; g++) {\n            var b = c[g];\n            b.extra && b.extra.parenthesized && this.unexpected(b.extra.parenStart);\n          }\n\n          return this.parseArrowExpression(P, c), this.state.yieldOrAwaitInPossibleArrowParameters = a, P;\n        }\n\n        return this.state.yieldOrAwaitInPossibleArrowParameters = this.state.yieldOrAwaitInPossibleArrowParameters || a, c.length || this.unexpected(this.state.lastTokStart), o && this.unexpected(o), n && this.unexpected(n), l.start && this.unexpected(l.start), d.start && this.unexpected(d.start), this.toReferencedListDeep(c, !0), c.length > 1 ? ((e = this.startNodeAt(u, p)).expressions = c, this.finishNodeAt(e, \"SequenceExpression\", x, v)) : e = c[0], this.addExtra(e, \"parenthesized\", !0), this.addExtra(e, \"parenStart\", s), e;\n      }, s.shouldParseArrow = function () {\n        return !this.canInsertSemicolon();\n      }, s.parseArrow = function (t) {\n        if (this.eat(h.arrow)) return t;\n      }, s.parseParenItem = function (t, e, s) {\n        return t;\n      }, s.parseNew = function () {\n        var t = this.startNode(),\n            e = this.parseIdentifier(!0);\n\n        if (this.eat(h.dot)) {\n          var s = this.parseMetaProperty(t, e, \"target\");\n\n          if (!this.state.inFunction && !this.state.inClassProperty) {\n            var i = \"new.target can only be used in functions\";\n            this.hasPlugin(\"classProperties\") && (i += \" or class properties\"), this.raise(s.start, i);\n          }\n\n          return s;\n        }\n\n        return t.callee = this.parseNoCallExpr(), \"OptionalMemberExpression\" !== t.callee.type && \"OptionalCallExpression\" !== t.callee.type || this.raise(this.state.lastTokEnd, \"constructors in/after an Optional Chain are not allowed\"), this.eat(h.questionDot) && this.raise(this.state.start, \"constructors in/after an Optional Chain are not allowed\"), this.parseNewArguments(t), this.finishNode(t, \"NewExpression\");\n      }, s.parseNewArguments = function (t) {\n        if (this.eat(h.parenL)) {\n          var e = this.parseExprList(h.parenR);\n          this.toReferencedList(e), t.arguments = e;\n        } else t.arguments = [];\n      }, s.parseTemplateElement = function (t) {\n        var e = this.startNode();\n        return null === this.state.value && (t ? this.state.invalidTemplateEscapePosition = null : this.raise(this.state.invalidTemplateEscapePosition || 0, \"Invalid escape sequence in template\")), e.value = {\n          raw: this.input.slice(this.state.start, this.state.end).replace(/\\r\\n?/g, \"\\n\"),\n          cooked: this.state.value\n        }, this.next(), e.tail = this.match(h.backQuote), this.finishNode(e, \"TemplateElement\");\n      }, s.parseTemplate = function (t) {\n        var e = this.startNode();\n        this.next(), e.expressions = [];\n        var s = this.parseTemplateElement(t);\n\n        for (e.quasis = [s]; !s.tail;) {\n          this.expect(h.dollarBraceL), e.expressions.push(this.parseExpression()), this.expect(h.braceR), e.quasis.push(s = this.parseTemplateElement(t));\n        }\n\n        return this.next(), this.finishNode(e, \"TemplateLiteral\");\n      }, s.parseObj = function (t, e) {\n        var s = [],\n            i = Object.create(null),\n            r = !0,\n            a = this.startNode();\n        a.properties = [], this.next();\n\n        for (var n = null; !this.eat(h.braceR);) {\n          if (r) r = !1;else if (this.expect(h.comma), this.eat(h.braceR)) break;\n          if (this.match(h.at)) if (this.hasPlugin(\"decorators\")) this.raise(this.state.start, \"Stage 2 decorators disallow object literal property decorators\");else for (; this.match(h.at);) {\n            s.push(this.parseDecorator());\n          }\n          var o = this.startNode(),\n              u = !1,\n              p = !1,\n              c = void 0,\n              l = void 0;\n\n          if (s.length && (o.decorators = s, s = []), this.match(h.ellipsis)) {\n            if (o = this.parseSpread(t ? {\n              start: 0\n            } : void 0), t && this.toAssignable(o, !0, \"object pattern\"), a.properties.push(o), !t) continue;\n            var d = this.state.start;\n            if (null !== n) this.unexpected(n, \"Cannot have multiple rest elements when destructuring\");else {\n              if (this.eat(h.braceR)) break;\n\n              if (!this.match(h.comma) || this.lookahead().type !== h.braceR) {\n                n = d;\n                continue;\n              }\n\n              this.unexpected(d, \"A trailing comma is not permitted after the rest element\");\n            }\n          }\n\n          o.method = !1, (t || e) && (c = this.state.start, l = this.state.startLoc), t || (u = this.eat(h.star));\n          var f = this.state.containsEsc;\n\n          if (!t && this.isContextual(\"async\")) {\n            u && this.unexpected();\n            var m = this.parseIdentifier();\n            this.match(h.colon) || this.match(h.parenL) || this.match(h.braceR) || this.match(h.eq) || this.match(h.comma) ? (o.key = m, o.computed = !1) : (p = !0, u = this.eat(h.star), this.parsePropertyName(o));\n          } else this.parsePropertyName(o);\n\n          this.parseObjPropValue(o, c, l, u, p, t, e, f), this.checkPropClash(o, i), o.shorthand && this.addExtra(o, \"shorthand\", !0), a.properties.push(o);\n        }\n\n        return null !== n && this.unexpected(n, \"The rest element has to be the last element when destructuring\"), s.length && this.raise(this.state.start, \"You have trailing decorators with no property\"), this.finishNode(a, t ? \"ObjectPattern\" : \"ObjectExpression\");\n      }, s.isGetterOrSetterMethod = function (t, e) {\n        return !e && !t.computed && \"Identifier\" === t.key.type && (\"get\" === t.key.name || \"set\" === t.key.name) && (this.match(h.string) || this.match(h.num) || this.match(h.bracketL) || this.match(h.name) || !!this.state.type.keyword);\n      }, s.checkGetterSetterParams = function (t) {\n        var e = \"get\" === t.kind ? 0 : 1,\n            s = t.start;\n        t.params.length !== e && (\"get\" === t.kind ? this.raise(s, \"getter must not have any formal parameters\") : this.raise(s, \"setter must have exactly one formal parameter\")), \"set\" === t.kind && \"RestElement\" === t.params[0].type && this.raise(s, \"setter function argument must not be a rest parameter\");\n      }, s.parseObjectMethod = function (t, e, s, i, r) {\n        return s || e || this.match(h.parenL) ? (i && this.unexpected(), t.kind = \"method\", t.method = !0, this.parseMethod(t, e, s, !1, \"ObjectMethod\")) : !r && this.isGetterOrSetterMethod(t, i) ? ((e || s) && this.unexpected(), t.kind = t.key.name, this.parsePropertyName(t), this.parseMethod(t, !1, !1, !1, \"ObjectMethod\"), this.checkGetterSetterParams(t), t) : void 0;\n      }, s.parseObjectProperty = function (t, e, s, i, r) {\n        return t.shorthand = !1, this.eat(h.colon) ? (t.value = i ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(!1, r), this.finishNode(t, \"ObjectProperty\")) : t.computed || \"Identifier\" !== t.key.type ? void 0 : (this.checkReservedWord(t.key.name, t.key.start, !0, !0), i ? t.value = this.parseMaybeDefault(e, s, t.key.__clone()) : this.match(h.eq) && r ? (r.start || (r.start = this.state.start), t.value = this.parseMaybeDefault(e, s, t.key.__clone())) : t.value = t.key.__clone(), t.shorthand = !0, this.finishNode(t, \"ObjectProperty\"));\n      }, s.parseObjPropValue = function (t, e, s, i, r, a, n, o) {\n        var h = this.parseObjectMethod(t, i, r, a, o) || this.parseObjectProperty(t, e, s, a, n);\n        return h || this.unexpected(), h;\n      }, s.parsePropertyName = function (t) {\n        if (this.eat(h.bracketL)) t.computed = !0, t.key = this.parseMaybeAssign(), this.expect(h.bracketR);else {\n          var e = this.state.inPropertyName;\n          this.state.inPropertyName = !0, t.key = this.match(h.num) || this.match(h.string) ? this.parseExprAtom() : this.parseMaybePrivateName(), \"PrivateName\" !== t.key.type && (t.computed = !1), this.state.inPropertyName = e;\n        }\n        return t.key;\n      }, s.initFunction = function (t, e) {\n        t.id = null, t.generator = !1, t.async = !!e;\n      }, s.parseMethod = function (t, e, s, i, r) {\n        var a = this.state.inFunction,\n            n = this.state.inMethod,\n            o = this.state.inAsync,\n            h = this.state.inGenerator;\n        this.state.inFunction = !0, this.state.inMethod = t.kind || !0, this.state.inAsync = s, this.state.inGenerator = e, this.initFunction(t, s), t.generator = !!e;\n        var u = i;\n        return this.parseFunctionParams(t, u), this.parseFunctionBodyAndFinish(t, r), this.state.inFunction = a, this.state.inMethod = n, this.state.inAsync = o, this.state.inGenerator = h, t;\n      }, s.parseArrowExpression = function (t, e, s) {\n        var i = this.state.yieldOrAwaitInPossibleArrowParameters;\n        i && (\"YieldExpression\" === i.type ? this.raise(i.start, \"yield is not allowed in the parameters of an arrow function inside a generator\") : this.raise(i.start, \"await is not allowed in the parameters of an arrow function inside an async function\"));\n        var r = this.state.inFunction;\n        this.state.inFunction = !0, this.initFunction(t, s), e && this.setArrowFunctionParameters(t, e);\n        var a = this.state.inAsync,\n            n = this.state.inGenerator,\n            o = this.state.maybeInArrowParameters;\n        return this.state.inAsync = s, this.state.inGenerator = !1, this.state.maybeInArrowParameters = !1, this.parseFunctionBody(t, !0), this.state.inAsync = a, this.state.inGenerator = n, this.state.inFunction = r, this.state.maybeInArrowParameters = o, this.finishNode(t, \"ArrowFunctionExpression\");\n      }, s.setArrowFunctionParameters = function (t, e) {\n        t.params = this.toAssignableList(e, !0, \"arrow function parameters\");\n      }, s.isStrictBody = function (t) {\n        if (\"BlockStatement\" === t.body.type && t.body.directives.length) for (var e = 0, s = t.body.directives; e < s.length; e++) {\n          if (\"use strict\" === s[e].value.value) return !0;\n        }\n        return !1;\n      }, s.parseFunctionBodyAndFinish = function (t, e, s) {\n        this.parseFunctionBody(t, s), this.finishNode(t, e);\n      }, s.parseFunctionBody = function (t, e) {\n        var s = e && !this.match(h.braceL),\n            i = this.state.inParameters;\n        if (this.state.inParameters = !1, s) t.body = this.parseMaybeAssign();else {\n          var r = this.state.inGenerator,\n              a = this.state.inFunction,\n              n = this.state.labels;\n          this.state.inGenerator = t.generator, this.state.inFunction = !0, this.state.labels = [], t.body = this.parseBlock(!0), this.state.inFunction = a, this.state.inGenerator = r, this.state.labels = n;\n        }\n        this.checkFunctionNameAndParams(t, e), this.state.inParameters = i;\n      }, s.checkFunctionNameAndParams = function (t, e) {\n        var s = this.isStrictBody(t),\n            i = this.state.strict || s || e,\n            r = this.state.strict;\n\n        if (s && (this.state.strict = s), i) {\n          var a = Object.create(null);\n          t.id && this.checkLVal(t.id, !0, void 0, \"function name\");\n\n          for (var n = 0, o = t.params; n < o.length; n++) {\n            var h = o[n];\n            s && \"Identifier\" !== h.type && this.raise(h.start, \"Non-simple parameter in strict mode\"), this.checkLVal(h, !0, a, \"function parameter list\");\n          }\n        }\n\n        this.state.strict = r;\n      }, s.parseExprList = function (t, e, s) {\n        for (var i = [], r = !0; !this.eat(t);) {\n          if (r) r = !1;else if (this.expect(h.comma), this.eat(t)) break;\n          i.push(this.parseExprListItem(e, s));\n        }\n\n        return i;\n      }, s.parseExprListItem = function (t, e, s, i) {\n        var r;\n        if (t && this.match(h.comma)) r = null;else if (this.match(h.ellipsis)) {\n          var a = this.state.start,\n              n = this.state.startLoc;\n          r = this.parseParenItem(this.parseSpread(e, s), a, n), i && this.match(h.comma) && (i.start = this.state.start);\n        } else r = this.parseMaybeAssign(!1, e, this.parseParenItem, s);\n        return r;\n      }, s.parseIdentifier = function (t) {\n        var e = this.startNode(),\n            s = this.parseIdentifierName(e.start, t);\n        return this.createIdentifier(e, s);\n      }, s.createIdentifier = function (t, e) {\n        return t.name = e, t.loc.identifierName = e, this.finishNode(t, \"Identifier\");\n      }, s.parseIdentifierName = function (t, e) {\n        var s;\n        if (e || this.checkReservedWord(this.state.value, this.state.start, !!this.state.type.keyword, !1), this.match(h.name)) s = this.state.value;else {\n          if (!this.state.type.keyword) throw this.unexpected();\n          \"class\" !== (s = this.state.type.keyword) && \"function\" !== s || this.state.lastTokEnd === this.state.lastTokStart + 1 && 46 === this.input.charCodeAt(this.state.lastTokStart) || this.state.context.pop();\n        }\n        return !e && \"await\" === s && this.state.inAsync && this.raise(t, \"invalid use of await inside of an async function\"), this.next(), s;\n      }, s.checkReservedWord = function (t, e, s, i) {\n        this.state.strict && (v.strict(t) || i && v.strictBind(t)) && this.raise(e, t + \" is a reserved word in strict mode\"), this.state.inGenerator && \"yield\" === t && this.raise(e, \"yield is a reserved word inside generator functions\"), this.state.inClassProperty && \"arguments\" === t && this.raise(e, \"'arguments' is not allowed in class field initializer\"), (this.isReservedWord(t) || s && this.isKeyword(t)) && this.raise(e, t + \" is a reserved word\");\n      }, s.parseAwait = function (t) {\n        return this.state.inAsync || !this.state.inFunction && this.options.allowAwaitOutsideFunction || this.unexpected(), this.state.inParameters && this.raise(t.start, \"await is not allowed in async function parameters\"), this.match(h.star) && this.raise(t.start, \"await* has been removed from the async functions proposal. Use Promise.all() instead.\"), this.state.maybeInArrowParameters && !this.state.yieldOrAwaitInPossibleArrowParameters && (this.state.yieldOrAwaitInPossibleArrowParameters = t), t.argument = this.parseMaybeUnary(), this.finishNode(t, \"AwaitExpression\");\n      }, s.parseYield = function () {\n        var t = this.startNode();\n        return this.state.inParameters && this.raise(t.start, \"yield is not allowed in generator parameters\"), this.state.maybeInArrowParameters && !this.state.yieldOrAwaitInPossibleArrowParameters && (this.state.yieldOrAwaitInPossibleArrowParameters = t), this.next(), this.match(h.semi) || this.canInsertSemicolon() || !this.match(h.star) && !this.state.type.startsExpr ? (t.delegate = !1, t.argument = null) : (t.delegate = this.eat(h.star), t.argument = this.parseMaybeAssign()), this.finishNode(t, \"YieldExpression\");\n      }, s.checkPipelineAtInfixOperator = function (t, e) {\n        if (\"smart\" === this.getPluginOption(\"pipelineOperator\", \"proposal\") && \"SequenceExpression\" === t.type) throw this.raise(e, \"Pipeline head should not be a comma-separated sequence expression\");\n      }, s.parseSmartPipelineBody = function (t, e, s) {\n        var i = this.checkSmartPipelineBodyStyle(t);\n        return this.checkSmartPipelineBodyEarlyErrors(t, i, e), this.parseSmartPipelineBodyInStyle(t, i, e, s);\n      }, s.checkSmartPipelineBodyEarlyErrors = function (t, e, s) {\n        if (this.match(h.arrow)) throw this.raise(this.state.start, 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized');\n        if (\"PipelineTopicExpression\" === e && \"SequenceExpression\" === t.type) throw this.raise(s, \"Pipeline body may not be a comma-separated sequence expression\");\n      }, s.parseSmartPipelineBodyInStyle = function (t, e, s, i) {\n        var r = this.startNodeAt(s, i);\n\n        switch (e) {\n          case \"PipelineBareFunction\":\n            r.callee = t;\n            break;\n\n          case \"PipelineBareConstructor\":\n            r.callee = t.callee;\n            break;\n\n          case \"PipelineBareAwaitedFunction\":\n            r.callee = t.argument;\n            break;\n\n          case \"PipelineTopicExpression\":\n            if (!this.topicReferenceWasUsedInCurrentTopicContext()) throw this.raise(s, \"Pipeline is in topic style but does not use topic reference\");\n            r.expression = t;\n            break;\n\n          default:\n            throw this.raise(s, \"Unknown pipeline style \" + e);\n        }\n\n        return this.finishNode(r, e);\n      }, s.checkSmartPipelineBodyStyle = function (t) {\n        return t.type, this.isSimpleReference(t) ? \"PipelineBareFunction\" : \"PipelineTopicExpression\";\n      }, s.isSimpleReference = function (t) {\n        switch (t.type) {\n          case \"MemberExpression\":\n            return !t.computed && this.isSimpleReference(t.object);\n\n          case \"Identifier\":\n            return !0;\n\n          default:\n            return !1;\n        }\n      }, s.withTopicPermittingContext = function (t) {\n        var e = this.state.topicContext;\n        this.state.topicContext = {\n          maxNumOfResolvableTopics: 1,\n          maxTopicIndex: null\n        };\n\n        try {\n          return t();\n        } finally {\n          this.state.topicContext = e;\n        }\n      }, s.withTopicForbiddingContext = function (t) {\n        var e = this.state.topicContext;\n        this.state.topicContext = {\n          maxNumOfResolvableTopics: 0,\n          maxTopicIndex: null\n        };\n\n        try {\n          return t();\n        } finally {\n          this.state.topicContext = e;\n        }\n      }, s.registerTopicReference = function () {\n        this.state.topicContext.maxTopicIndex = 0;\n      }, s.primaryTopicReferenceIsAllowedInCurrentTopicContext = function () {\n        return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n      }, s.topicReferenceWasUsedInCurrentTopicContext = function () {\n        return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;\n      }, e;\n    }(function (t) {\n      function e() {\n        return t.apply(this, arguments) || this;\n      }\n\n      i(e, t);\n      var s = e.prototype;\n      return s.toAssignable = function (t, e, s) {\n        if (t) switch (t.type) {\n          case \"Identifier\":\n          case \"ObjectPattern\":\n          case \"ArrayPattern\":\n          case \"AssignmentPattern\":\n            break;\n\n          case \"ObjectExpression\":\n            t.type = \"ObjectPattern\";\n\n            for (var i = 0; i < t.properties.length; i++) {\n              var r = t.properties[i],\n                  a = i === t.properties.length - 1;\n              this.toAssignableObjectExpressionProp(r, e, a);\n            }\n\n            break;\n\n          case \"ObjectProperty\":\n            this.toAssignable(t.value, e, s);\n            break;\n\n          case \"SpreadElement\":\n            this.checkToRestConversion(t), t.type = \"RestElement\";\n            var n = t.argument;\n            this.toAssignable(n, e, s);\n            break;\n\n          case \"ArrayExpression\":\n            t.type = \"ArrayPattern\", this.toAssignableList(t.elements, e, s);\n            break;\n\n          case \"AssignmentExpression\":\n            \"=\" === t.operator ? (t.type = \"AssignmentPattern\", delete t.operator) : this.raise(t.left.end, \"Only '=' operator can be used for specifying default value.\");\n            break;\n\n          case \"MemberExpression\":\n            if (!e) break;\n\n          default:\n            var o = \"Invalid left-hand side\" + (s ? \" in \" + s : \"expression\");\n            this.raise(t.start, o);\n        }\n        return t;\n      }, s.toAssignableObjectExpressionProp = function (t, e, s) {\n        if (\"ObjectMethod\" === t.type) {\n          var i = \"get\" === t.kind || \"set\" === t.kind ? \"Object pattern can't contain getter or setter\" : \"Object pattern can't contain methods\";\n          this.raise(t.key.start, i);\n        } else \"SpreadElement\" !== t.type || s ? this.toAssignable(t, e, \"object destructuring pattern\") : this.raise(t.start, \"The rest element has to be the last element when destructuring\");\n      }, s.toAssignableList = function (t, e, s) {\n        var i = t.length;\n\n        if (i) {\n          var r = t[i - 1];\n          if (r && \"RestElement\" === r.type) --i;else if (r && \"SpreadElement\" === r.type) {\n            r.type = \"RestElement\";\n            var a = r.argument;\n            this.toAssignable(a, e, s), -1 === [\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\"].indexOf(a.type) && this.unexpected(a.start), --i;\n          }\n        }\n\n        for (var n = 0; n < i; n++) {\n          var o = t[n];\n          o && \"SpreadElement\" === o.type && this.raise(o.start, \"The rest element has to be the last element when destructuring\"), o && this.toAssignable(o, e, s);\n        }\n\n        return t;\n      }, s.toReferencedList = function (t, e) {\n        return t;\n      }, s.toReferencedListDeep = function (t, e) {\n        this.toReferencedList(t, e);\n\n        for (var s = 0; s < t.length; s++) {\n          var i = t[s];\n          i && \"ArrayExpression\" === i.type && this.toReferencedListDeep(i.elements);\n        }\n\n        return t;\n      }, s.parseSpread = function (t, e) {\n        var s = this.startNode();\n        return this.next(), s.argument = this.parseMaybeAssign(!1, t, void 0, e), this.finishNode(s, \"SpreadElement\");\n      }, s.parseRest = function () {\n        var t = this.startNode();\n        return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, \"RestElement\");\n      }, s.shouldAllowYieldIdentifier = function () {\n        return this.match(h._yield) && !this.state.strict && !this.state.inGenerator;\n      }, s.parseBindingIdentifier = function () {\n        return this.parseIdentifier(this.shouldAllowYieldIdentifier());\n      }, s.parseBindingAtom = function () {\n        switch (this.state.type) {\n          case h._yield:\n          case h.name:\n            return this.parseBindingIdentifier();\n\n          case h.bracketL:\n            var t = this.startNode();\n            return this.next(), t.elements = this.parseBindingList(h.bracketR, !0), this.finishNode(t, \"ArrayPattern\");\n\n          case h.braceL:\n            return this.parseObj(!0);\n\n          default:\n            throw this.unexpected();\n        }\n      }, s.parseBindingList = function (t, e, s) {\n        for (var i = [], r = !0; !this.eat(t);) {\n          if (r ? r = !1 : this.expect(h.comma), e && this.match(h.comma)) i.push(null);else {\n            if (this.eat(t)) break;\n\n            if (this.match(h.ellipsis)) {\n              if (i.push(this.parseAssignableListItemTypes(this.parseRest())), this.state.inFunction && this.state.inParameters && this.match(h.comma)) {\n                var a = this.lookahead().type === h.parenR ? \"A trailing comma is not permitted after the rest element\" : \"Rest parameter must be last formal parameter\";\n                this.raise(this.state.start, a);\n              } else this.expect(t);\n\n              break;\n            }\n\n            var n = [];\n\n            for (this.match(h.at) && this.hasPlugin(\"decorators\") && this.raise(this.state.start, \"Stage 2 decorators cannot be used to decorate parameters\"); this.match(h.at);) {\n              n.push(this.parseDecorator());\n            }\n\n            i.push(this.parseAssignableListItem(s, n));\n          }\n        }\n\n        return i;\n      }, s.parseAssignableListItem = function (t, e) {\n        var s = this.parseMaybeDefault();\n        this.parseAssignableListItemTypes(s);\n        var i = this.parseMaybeDefault(s.start, s.loc.start, s);\n        return e.length && (s.decorators = e), i;\n      }, s.parseAssignableListItemTypes = function (t) {\n        return t;\n      }, s.parseMaybeDefault = function (t, e, s) {\n        if (e = e || this.state.startLoc, t = t || this.state.start, s = s || this.parseBindingAtom(), !this.eat(h.eq)) return s;\n        var i = this.startNodeAt(t, e);\n        return i.left = s, i.right = this.parseMaybeAssign(), this.finishNode(i, \"AssignmentPattern\");\n      }, s.checkLVal = function (t, e, s, i) {\n        switch (t.type) {\n          case \"Identifier\":\n            if (this.checkReservedWord(t.name, t.start, !1, !0), s) {\n              var r = \"_\" + t.name;\n              s[r] ? this.raise(t.start, \"Argument name clash in strict mode\") : s[r] = !0;\n            }\n\n            break;\n\n          case \"MemberExpression\":\n            e && this.raise(t.start, \"Binding member expression\");\n            break;\n\n          case \"ObjectPattern\":\n            for (var a = 0, n = t.properties; a < n.length; a++) {\n              var o = n[a];\n              \"ObjectProperty\" === o.type && (o = o.value), this.checkLVal(o, e, s, \"object destructuring pattern\");\n            }\n\n            break;\n\n          case \"ArrayPattern\":\n            for (var h = 0, u = t.elements; h < u.length; h++) {\n              var p = u[h];\n              p && this.checkLVal(p, e, s, \"array destructuring pattern\");\n            }\n\n            break;\n\n          case \"AssignmentPattern\":\n            this.checkLVal(t.left, e, s, \"assignment pattern\");\n            break;\n\n          case \"RestElement\":\n            this.checkLVal(t.argument, e, s, \"rest element\");\n            break;\n\n          default:\n            var c = (e ? \"Binding invalid\" : \"Invalid\") + \" left-hand side\" + (i ? \" in \" + i : \"expression\");\n            this.raise(t.start, c);\n        }\n      }, s.checkToRestConversion = function (t) {\n        -1 === [\"Identifier\", \"MemberExpression\"].indexOf(t.argument.type) && this.raise(t.argument.start, \"Invalid rest operator's argument\");\n      }, e;\n    }(function (t) {\n      function e() {\n        return t.apply(this, arguments) || this;\n      }\n\n      i(e, t);\n      var s = e.prototype;\n      return s.startNode = function () {\n        return new $(this, this.state.start, this.state.startLoc);\n      }, s.startNodeAt = function (t, e) {\n        return new $(this, t, e);\n      }, s.startNodeAtNode = function (t) {\n        return this.startNodeAt(t.start, t.loc.start);\n      }, s.finishNode = function (t, e) {\n        return this.finishNodeAt(t, e, this.state.lastTokEnd, this.state.lastTokEndLoc);\n      }, s.finishNodeAt = function (t, e, s, i) {\n        return t.type = e, t.end = s, t.loc.end = i, this.options.ranges && (t.range[1] = s), this.processComment(t), t;\n      }, s.resetStartLocationFromNode = function (t, e) {\n        t.start = e.start, t.loc.start = e.loc.start, this.options.ranges && (t.range[0] = e.range[0]);\n      }, e;\n    }(z)))));\n\n    function st(t) {\n      if (null == t) throw new Error(\"Unexpected \" + t + \" value.\");\n      return t;\n    }\n\n    function it(t) {\n      if (!t) throw new Error(\"Assert fail\");\n    }\n\n    function rt(t, e) {\n      return t.some(function (t) {\n        return Array.isArray(t) ? t[0] === e : t === e;\n      });\n    }\n\n    function at(t, e, s) {\n      var i = t.find(function (t) {\n        return Array.isArray(t) ? t[0] === e : t === e;\n      });\n      return i && Array.isArray(i) ? i[1][s] : null;\n    }\n\n    var nt = [\"minimal\", \"smart\"];\n    var ot = [\"estree\", \"jsx\", \"flow\", \"typescript\"],\n        ht = {\n      estree: function estree(t) {\n        return function (t) {\n          function e() {\n            return t.apply(this, arguments) || this;\n          }\n\n          i(e, t);\n          var s = e.prototype;\n          return s.estreeParseRegExpLiteral = function (t) {\n            var e = t.pattern,\n                s = t.flags,\n                i = null;\n\n            try {\n              i = new RegExp(e, s);\n            } catch (t) {}\n\n            var r = this.estreeParseLiteral(i);\n            return r.regex = {\n              pattern: e,\n              flags: s\n            }, r;\n          }, s.estreeParseLiteral = function (t) {\n            return this.parseLiteral(t, \"Literal\");\n          }, s.directiveToStmt = function (t) {\n            var e = t.value,\n                s = this.startNodeAt(t.start, t.loc.start),\n                i = this.startNodeAt(e.start, e.loc.start);\n            return i.value = e.value, i.raw = e.extra.raw, s.expression = this.finishNodeAt(i, \"Literal\", e.end, e.loc.end), s.directive = e.extra.raw.slice(1, -1), this.finishNodeAt(s, \"ExpressionStatement\", t.end, t.loc.end);\n          }, s.initFunction = function (e, s) {\n            t.prototype.initFunction.call(this, e, s), e.expression = !1;\n          }, s.checkDeclaration = function (e) {\n            p(e) ? this.checkDeclaration(e.value) : t.prototype.checkDeclaration.call(this, e);\n          }, s.checkGetterSetterParams = function (t) {\n            var e = t,\n                s = \"get\" === e.kind ? 0 : 1,\n                i = e.start;\n            e.value.params.length !== s && (\"get\" === e.kind ? this.raise(i, \"getter must not have any formal parameters\") : this.raise(i, \"setter must have exactly one formal parameter\")), \"set\" === e.kind && \"RestElement\" === e.value.params[0].type && this.raise(i, \"setter function argument must not be a rest parameter\");\n          }, s.checkLVal = function (e, s, i, r) {\n            var a = this;\n\n            switch (e.type) {\n              case \"ObjectPattern\":\n                e.properties.forEach(function (t) {\n                  a.checkLVal(\"Property\" === t.type ? t.value : t, s, i, \"object destructuring pattern\");\n                });\n                break;\n\n              default:\n                t.prototype.checkLVal.call(this, e, s, i, r);\n            }\n          }, s.checkPropClash = function (t, e) {\n            if (!t.computed && p(t)) {\n              var s = t.key;\n              \"__proto__\" === (\"Identifier\" === s.type ? s.name : String(s.value)) && (e.proto && this.raise(s.start, \"Redefinition of __proto__ property\"), e.proto = !0);\n            }\n          }, s.isStrictBody = function (t) {\n            if (\"BlockStatement\" === t.body.type && t.body.body.length > 0) for (var e = 0, s = t.body.body; e < s.length; e++) {\n              var i = s[e];\n              if (\"ExpressionStatement\" !== i.type || \"Literal\" !== i.expression.type) break;\n              if (\"use strict\" === i.expression.value) return !0;\n            }\n            return !1;\n          }, s.isValidDirective = function (t) {\n            return !(\"ExpressionStatement\" !== t.type || \"Literal\" !== t.expression.type || \"string\" != typeof t.expression.value || t.expression.extra && t.expression.extra.parenthesized);\n          }, s.stmtToDirective = function (e) {\n            var s = t.prototype.stmtToDirective.call(this, e),\n                i = e.expression.value;\n            return s.value.value = i, s;\n          }, s.parseBlockBody = function (e, s, i, r) {\n            var a = this;\n            t.prototype.parseBlockBody.call(this, e, s, i, r);\n            var n = e.directives.map(function (t) {\n              return a.directiveToStmt(t);\n            });\n            e.body = n.concat(e.body), delete e.directives;\n          }, s.pushClassMethod = function (t, e, s, i, r) {\n            this.parseMethod(e, s, i, r, \"MethodDefinition\"), e.typeParameters && (e.value.typeParameters = e.typeParameters, delete e.typeParameters), t.body.push(e);\n          }, s.parseExprAtom = function (e) {\n            switch (this.state.type) {\n              case h.regexp:\n                return this.estreeParseRegExpLiteral(this.state.value);\n\n              case h.num:\n              case h.string:\n                return this.estreeParseLiteral(this.state.value);\n\n              case h._null:\n                return this.estreeParseLiteral(null);\n\n              case h._true:\n                return this.estreeParseLiteral(!0);\n\n              case h._false:\n                return this.estreeParseLiteral(!1);\n\n              default:\n                return t.prototype.parseExprAtom.call(this, e);\n            }\n          }, s.parseLiteral = function (e, s, i, r) {\n            var a = t.prototype.parseLiteral.call(this, e, s, i, r);\n            return a.raw = a.extra.raw, delete a.extra, a;\n          }, s.parseFunctionBody = function (e, s) {\n            t.prototype.parseFunctionBody.call(this, e, s), e.expression = \"BlockStatement\" !== e.body.type;\n          }, s.parseMethod = function (e, s, i, r, a) {\n            var n = this.startNode();\n            return n.kind = e.kind, delete (n = t.prototype.parseMethod.call(this, n, s, i, r, \"FunctionExpression\")).kind, e.value = n, this.finishNode(e, a);\n          }, s.parseObjectMethod = function (e, s, i, r, a) {\n            var n = t.prototype.parseObjectMethod.call(this, e, s, i, r, a);\n            return n && (n.type = \"Property\", \"method\" === n.kind && (n.kind = \"init\"), n.shorthand = !1), n;\n          }, s.parseObjectProperty = function (e, s, i, r, a) {\n            var n = t.prototype.parseObjectProperty.call(this, e, s, i, r, a);\n            return n && (n.kind = \"init\", n.type = \"Property\"), n;\n          }, s.toAssignable = function (e, s, i) {\n            return p(e) ? (this.toAssignable(e.value, s, i), e) : t.prototype.toAssignable.call(this, e, s, i);\n          }, s.toAssignableObjectExpressionProp = function (e, s, i) {\n            \"get\" === e.kind || \"set\" === e.kind ? this.raise(e.key.start, \"Object pattern can't contain getter or setter\") : e.method ? this.raise(e.key.start, \"Object pattern can't contain methods\") : t.prototype.toAssignableObjectExpressionProp.call(this, e, s, i);\n          }, e;\n        }(t);\n      },\n      jsx: function jsx(t) {\n        return function (t) {\n          function e() {\n            return t.apply(this, arguments) || this;\n          }\n\n          i(e, t);\n          var s = e.prototype;\n          return s.jsxReadToken = function () {\n            for (var t = \"\", e = this.state.pos;;) {\n              this.state.pos >= this.input.length && this.raise(this.state.start, \"Unterminated JSX contents\");\n              var s = this.input.charCodeAt(this.state.pos);\n\n              switch (s) {\n                case 60:\n                case 123:\n                  return this.state.pos === this.state.start ? 60 === s && this.state.exprAllowed ? (++this.state.pos, this.finishToken(h.jsxTagStart)) : this.getTokenFromCode(s) : (t += this.input.slice(e, this.state.pos), this.finishToken(h.jsxText, t));\n\n                case 38:\n                  t += this.input.slice(e, this.state.pos), t += this.jsxReadEntity(), e = this.state.pos;\n                  break;\n\n                default:\n                  d(s) ? (t += this.input.slice(e, this.state.pos), t += this.jsxReadNewLine(!0), e = this.state.pos) : ++this.state.pos;\n              }\n            }\n          }, s.jsxReadNewLine = function (t) {\n            var e,\n                s = this.input.charCodeAt(this.state.pos);\n            return ++this.state.pos, 13 === s && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, e = t ? \"\\n\" : \"\\r\\n\") : e = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, e;\n          }, s.jsxReadString = function (t) {\n            for (var e = \"\", s = ++this.state.pos;;) {\n              this.state.pos >= this.input.length && this.raise(this.state.start, \"Unterminated string constant\");\n              var i = this.input.charCodeAt(this.state.pos);\n              if (i === t) break;\n              38 === i ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadEntity(), s = this.state.pos) : d(i) ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadNewLine(!1), s = this.state.pos) : ++this.state.pos;\n            }\n\n            return e += this.input.slice(s, this.state.pos++), this.finishToken(h.string, e);\n          }, s.jsxReadEntity = function () {\n            for (var t, e = \"\", s = 0, i = this.input[this.state.pos], r = ++this.state.pos; this.state.pos < this.input.length && s++ < 10;) {\n              if (\";\" === (i = this.input[this.state.pos++])) {\n                \"#\" === e[0] ? \"x\" === e[1] ? (e = e.substr(2), R.test(e) && (t = String.fromCodePoint(parseInt(e, 16)))) : (e = e.substr(1), B.test(e) && (t = String.fromCodePoint(parseInt(e, 10)))) : t = M[e];\n                break;\n              }\n\n              e += i;\n            }\n\n            return t || (this.state.pos = r, \"&\");\n          }, s.jsxReadWord = function () {\n            var t,\n                e = this.state.pos;\n\n            do {\n              t = this.input.charCodeAt(++this.state.pos);\n            } while (k(t) || 45 === t);\n\n            return this.finishToken(h.jsxName, this.input.slice(e, this.state.pos));\n          }, s.jsxParseIdentifier = function () {\n            var t = this.startNode();\n            return this.match(h.jsxName) ? t.name = this.state.value : this.state.type.keyword ? t.name = this.state.type.keyword : this.unexpected(), this.next(), this.finishNode(t, \"JSXIdentifier\");\n          }, s.jsxParseNamespacedName = function () {\n            var t = this.state.start,\n                e = this.state.startLoc,\n                s = this.jsxParseIdentifier();\n            if (!this.eat(h.colon)) return s;\n            var i = this.startNodeAt(t, e);\n            return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, \"JSXNamespacedName\");\n          }, s.jsxParseElementName = function () {\n            for (var t = this.state.start, e = this.state.startLoc, s = this.jsxParseNamespacedName(); this.eat(h.dot);) {\n              var i = this.startNodeAt(t, e);\n              i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, \"JSXMemberExpression\");\n            }\n\n            return s;\n          }, s.jsxParseAttributeValue = function () {\n            var t;\n\n            switch (this.state.type) {\n              case h.braceL:\n                if (\"JSXEmptyExpression\" === (t = this.jsxParseExpressionContainer()).expression.type) throw this.raise(t.start, \"JSX attributes must only be assigned a non-empty expression\");\n                return t;\n\n              case h.jsxTagStart:\n              case h.string:\n                return this.parseExprAtom();\n\n              default:\n                throw this.raise(this.state.start, \"JSX value should be either an expression or a quoted JSX text\");\n            }\n          }, s.jsxParseEmptyExpression = function () {\n            var t = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);\n            return this.finishNodeAt(t, \"JSXEmptyExpression\", this.state.start, this.state.startLoc);\n          }, s.jsxParseSpreadChild = function () {\n            var t = this.startNode();\n            return this.expect(h.braceL), this.expect(h.ellipsis), t.expression = this.parseExpression(), this.expect(h.braceR), this.finishNode(t, \"JSXSpreadChild\");\n          }, s.jsxParseExpressionContainer = function () {\n            var t = this.startNode();\n            return this.next(), this.match(h.braceR) ? t.expression = this.jsxParseEmptyExpression() : t.expression = this.parseExpression(), this.expect(h.braceR), this.finishNode(t, \"JSXExpressionContainer\");\n          }, s.jsxParseAttribute = function () {\n            var t = this.startNode();\n            return this.eat(h.braceL) ? (this.expect(h.ellipsis), t.argument = this.parseMaybeAssign(), this.expect(h.braceR), this.finishNode(t, \"JSXSpreadAttribute\")) : (t.name = this.jsxParseNamespacedName(), t.value = this.eat(h.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(t, \"JSXAttribute\"));\n          }, s.jsxParseOpeningElementAt = function (t, e) {\n            var s = this.startNodeAt(t, e);\n            return this.match(h.jsxTagEnd) ? (this.expect(h.jsxTagEnd), this.finishNode(s, \"JSXOpeningFragment\")) : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s));\n          }, s.jsxParseOpeningElementAfterName = function (t) {\n            for (var e = []; !this.match(h.slash) && !this.match(h.jsxTagEnd);) {\n              e.push(this.jsxParseAttribute());\n            }\n\n            return t.attributes = e, t.selfClosing = this.eat(h.slash), this.expect(h.jsxTagEnd), this.finishNode(t, \"JSXOpeningElement\");\n          }, s.jsxParseClosingElementAt = function (t, e) {\n            var s = this.startNodeAt(t, e);\n            return this.match(h.jsxTagEnd) ? (this.expect(h.jsxTagEnd), this.finishNode(s, \"JSXClosingFragment\")) : (s.name = this.jsxParseElementName(), this.expect(h.jsxTagEnd), this.finishNode(s, \"JSXClosingElement\"));\n          }, s.jsxParseElementAt = function (t, e) {\n            var s = this.startNodeAt(t, e),\n                i = [],\n                r = this.jsxParseOpeningElementAt(t, e),\n                a = null;\n\n            if (!r.selfClosing) {\n              t: for (;;) {\n                switch (this.state.type) {\n                  case h.jsxTagStart:\n                    if (t = this.state.start, e = this.state.startLoc, this.next(), this.eat(h.slash)) {\n                      a = this.jsxParseClosingElementAt(t, e);\n                      break t;\n                    }\n\n                    i.push(this.jsxParseElementAt(t, e));\n                    break;\n\n                  case h.jsxText:\n                    i.push(this.parseExprAtom());\n                    break;\n\n                  case h.braceL:\n                    this.lookahead().type === h.ellipsis ? i.push(this.jsxParseSpreadChild()) : i.push(this.jsxParseExpressionContainer());\n                    break;\n\n                  default:\n                    throw this.unexpected();\n                }\n              }\n\n              _(r) && !_(a) ? this.raise(a.start, \"Expected corresponding JSX closing tag for <>\") : !_(r) && _(a) ? this.raise(a.start, \"Expected corresponding JSX closing tag for <\" + j(r.name) + \">\") : _(r) || _(a) || j(a.name) !== j(r.name) && this.raise(a.start, \"Expected corresponding JSX closing tag for <\" + j(r.name) + \">\");\n            }\n\n            return _(r) ? (s.openingFragment = r, s.closingFragment = a) : (s.openingElement = r, s.closingElement = a), s.children = i, this.match(h.relational) && \"<\" === this.state.value && this.raise(this.state.start, \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"), _(r) ? this.finishNode(s, \"JSXFragment\") : this.finishNode(s, \"JSXElement\");\n          }, s.jsxParseElement = function () {\n            var t = this.state.start,\n                e = this.state.startLoc;\n            return this.next(), this.jsxParseElementAt(t, e);\n          }, s.parseExprAtom = function (e) {\n            return this.match(h.jsxText) ? this.parseLiteral(this.state.value, \"JSXText\") : this.match(h.jsxTagStart) ? this.jsxParseElement() : this.isRelational(\"<\") && 33 !== this.state.input.charCodeAt(this.state.pos) ? (this.finishToken(h.jsxTagStart), this.jsxParseElement()) : t.prototype.parseExprAtom.call(this, e);\n          }, s.readToken = function (e) {\n            if (this.state.inPropertyName) return t.prototype.readToken.call(this, e);\n            var s = this.curContext();\n            if (s === D.j_expr) return this.jsxReadToken();\n\n            if (s === D.j_oTag || s === D.j_cTag) {\n              if (N(e)) return this.jsxReadWord();\n              if (62 === e) return ++this.state.pos, this.finishToken(h.jsxTagEnd);\n              if ((34 === e || 39 === e) && s === D.j_oTag) return this.jsxReadString(e);\n            }\n\n            return 60 === e && this.state.exprAllowed && 33 !== this.state.input.charCodeAt(this.state.pos + 1) ? (++this.state.pos, this.finishToken(h.jsxTagStart)) : t.prototype.readToken.call(this, e);\n          }, s.updateContext = function (e) {\n            if (this.match(h.braceL)) {\n              var s = this.curContext();\n              s === D.j_oTag ? this.state.context.push(D.braceExpression) : s === D.j_expr ? this.state.context.push(D.templateQuasi) : t.prototype.updateContext.call(this, e), this.state.exprAllowed = !0;\n            } else {\n              if (!this.match(h.slash) || e !== h.jsxTagStart) return t.prototype.updateContext.call(this, e);\n              this.state.context.length -= 2, this.state.context.push(D.j_cTag), this.state.exprAllowed = !1;\n            }\n          }, e;\n        }(t);\n      },\n      flow: function flow(t) {\n        return function (t) {\n          function e(e, s) {\n            var i;\n            return (i = t.call(this, e, s) || this).flowPragma = void 0, i;\n          }\n\n          i(e, t);\n          var s = e.prototype;\n          return s.shouldParseTypes = function () {\n            return this.getPluginOption(\"flow\", \"all\") || \"flow\" === this.flowPragma;\n          }, s.addComment = function (e) {\n            if (void 0 === this.flowPragma) {\n              var s = O.exec(e.value);\n              if (s) {\n                if (\"flow\" === s[1]) this.flowPragma = \"flow\";else {\n                  if (\"noflow\" !== s[1]) throw new Error(\"Unexpected flow pragma\");\n                  this.flowPragma = \"noflow\";\n                }\n              } else this.flowPragma = null;\n            }\n\n            return t.prototype.addComment.call(this, e);\n          }, s.flowParseTypeInitialiser = function (t) {\n            var e = this.state.inType;\n            this.state.inType = !0, this.expect(t || h.colon);\n            var s = this.flowParseType();\n            return this.state.inType = e, s;\n          }, s.flowParsePredicate = function () {\n            var t = this.startNode(),\n                e = this.state.startLoc,\n                s = this.state.start;\n            this.expect(h.modulo);\n            var i = this.state.startLoc;\n            return this.expectContextual(\"checks\"), e.line === i.line && e.column === i.column - 1 || this.raise(s, \"Spaces between ´%´ and ´checks´ are not allowed here.\"), this.eat(h.parenL) ? (t.value = this.parseExpression(), this.expect(h.parenR), this.finishNode(t, \"DeclaredPredicate\")) : this.finishNode(t, \"InferredPredicate\");\n          }, s.flowParseTypeAndPredicateInitialiser = function () {\n            var t = this.state.inType;\n            this.state.inType = !0, this.expect(h.colon);\n            var e = null,\n                s = null;\n            return this.match(h.modulo) ? (this.state.inType = t, s = this.flowParsePredicate()) : (e = this.flowParseType(), this.state.inType = t, this.match(h.modulo) && (s = this.flowParsePredicate())), [e, s];\n          }, s.flowParseDeclareClass = function (t) {\n            return this.next(), this.flowParseInterfaceish(t, !0), this.finishNode(t, \"DeclareClass\");\n          }, s.flowParseDeclareFunction = function (t) {\n            this.next();\n            var e = t.id = this.parseIdentifier(),\n                s = this.startNode(),\n                i = this.startNode();\n            this.isRelational(\"<\") ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, this.expect(h.parenL);\n            var r = this.flowParseFunctionTypeParams();\n            s.params = r.params, s.rest = r.rest, this.expect(h.parenR);\n            var a = this.flowParseTypeAndPredicateInitialiser();\n            return s.returnType = a[0], t.predicate = a[1], i.typeAnnotation = this.finishNode(s, \"FunctionTypeAnnotation\"), e.typeAnnotation = this.finishNode(i, \"TypeAnnotation\"), this.finishNode(e, e.type), this.semicolon(), this.finishNode(t, \"DeclareFunction\");\n          }, s.flowParseDeclare = function (t, e) {\n            if (this.match(h._class)) return this.flowParseDeclareClass(t);\n            if (this.match(h._function)) return this.flowParseDeclareFunction(t);\n            if (this.match(h._var)) return this.flowParseDeclareVariable(t);\n            if (this.isContextual(\"module\")) return this.lookahead().type === h.dot ? this.flowParseDeclareModuleExports(t) : (e && this.unexpected(null, \"`declare module` cannot be used inside another `declare module`\"), this.flowParseDeclareModule(t));\n            if (this.isContextual(\"type\")) return this.flowParseDeclareTypeAlias(t);\n            if (this.isContextual(\"opaque\")) return this.flowParseDeclareOpaqueType(t);\n            if (this.isContextual(\"interface\")) return this.flowParseDeclareInterface(t);\n            if (this.match(h._export)) return this.flowParseDeclareExportDeclaration(t, e);\n            throw this.unexpected();\n          }, s.flowParseDeclareVariable = function (t) {\n            return this.next(), t.id = this.flowParseTypeAnnotatableIdentifier(!0), this.semicolon(), this.finishNode(t, \"DeclareVariable\");\n          }, s.flowParseDeclareModule = function (t) {\n            var e = this;\n            this.next(), this.match(h.string) ? t.id = this.parseExprAtom() : t.id = this.parseIdentifier();\n            var s = t.body = this.startNode(),\n                i = s.body = [];\n\n            for (this.expect(h.braceL); !this.match(h.braceR);) {\n              var r = this.startNode();\n\n              if (this.match(h._import)) {\n                var a = this.lookahead();\n                \"type\" !== a.value && \"typeof\" !== a.value && this.unexpected(null, \"Imports within a `declare module` body must always be `import type` or `import typeof`\"), this.next(), this.parseImport(r);\n              } else this.expectContextual(\"declare\", \"Only declares and type imports are allowed inside declare module\"), r = this.flowParseDeclare(r, !0);\n\n              i.push(r);\n            }\n\n            this.expect(h.braceR), this.finishNode(s, \"BlockStatement\");\n            var n = null,\n                o = !1,\n                u = \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module\";\n            return i.forEach(function (t) {\n              !function (t) {\n                return \"DeclareExportAllDeclaration\" === t.type || \"DeclareExportDeclaration\" === t.type && (!t.declaration || \"TypeAlias\" !== t.declaration.type && \"InterfaceDeclaration\" !== t.declaration.type);\n              }(t) ? \"DeclareModuleExports\" === t.type && (o && e.unexpected(t.start, \"Duplicate `declare module.exports` statement\"), \"ES\" === n && e.unexpected(t.start, u), n = \"CommonJS\", o = !0) : (\"CommonJS\" === n && e.unexpected(t.start, u), n = \"ES\");\n            }), t.kind = n || \"CommonJS\", this.finishNode(t, \"DeclareModule\");\n          }, s.flowParseDeclareExportDeclaration = function (t, e) {\n            if (this.expect(h._export), this.eat(h._default)) return this.match(h._function) || this.match(h._class) ? t.declaration = this.flowParseDeclare(this.startNode()) : (t.declaration = this.flowParseType(), this.semicolon()), t.default = !0, this.finishNode(t, \"DeclareExportDeclaration\");\n\n            if (this.match(h._const) || this.match(h._let) || (this.isContextual(\"type\") || this.isContextual(\"interface\")) && !e) {\n              var s = this.state.value,\n                  i = L[s];\n              this.unexpected(this.state.start, \"`declare export \" + s + \"` is not supported. Use `\" + i + \"` instead\");\n            }\n\n            if (this.match(h._var) || this.match(h._function) || this.match(h._class) || this.isContextual(\"opaque\")) return t.declaration = this.flowParseDeclare(this.startNode()), t.default = !1, this.finishNode(t, \"DeclareExportDeclaration\");\n            if (this.match(h.star) || this.match(h.braceL) || this.isContextual(\"interface\") || this.isContextual(\"type\") || this.isContextual(\"opaque\")) return \"ExportNamedDeclaration\" === (t = this.parseExport(t)).type && (t.type = \"ExportDeclaration\", t.default = !1, delete t.exportKind), t.type = \"Declare\" + t.type, t;\n            throw this.unexpected();\n          }, s.flowParseDeclareModuleExports = function (t) {\n            return this.expectContextual(\"module\"), this.expect(h.dot), this.expectContextual(\"exports\"), t.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(t, \"DeclareModuleExports\");\n          }, s.flowParseDeclareTypeAlias = function (t) {\n            return this.next(), this.flowParseTypeAlias(t), this.finishNode(t, \"DeclareTypeAlias\");\n          }, s.flowParseDeclareOpaqueType = function (t) {\n            return this.next(), this.flowParseOpaqueType(t, !0), this.finishNode(t, \"DeclareOpaqueType\");\n          }, s.flowParseDeclareInterface = function (t) {\n            return this.next(), this.flowParseInterfaceish(t), this.finishNode(t, \"DeclareInterface\");\n          }, s.flowParseInterfaceish = function (t, e) {\n            if (void 0 === e && (e = !1), t.id = this.flowParseRestrictedIdentifier(!e), this.isRelational(\"<\") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.extends = [], t.implements = [], t.mixins = [], this.eat(h._extends)) do {\n              t.extends.push(this.flowParseInterfaceExtends());\n            } while (!e && this.eat(h.comma));\n\n            if (this.isContextual(\"mixins\")) {\n              this.next();\n\n              do {\n                t.mixins.push(this.flowParseInterfaceExtends());\n              } while (this.eat(h.comma));\n            }\n\n            if (this.isContextual(\"implements\")) {\n              this.next();\n\n              do {\n                t.implements.push(this.flowParseInterfaceExtends());\n              } while (this.eat(h.comma));\n            }\n\n            t.body = this.flowParseObjectType({\n              allowStatic: e,\n              allowExact: !1,\n              allowSpread: !1,\n              allowProto: e,\n              allowInexact: !1\n            });\n          }, s.flowParseInterfaceExtends = function () {\n            var t = this.startNode();\n            return t.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational(\"<\") ? t.typeParameters = this.flowParseTypeParameterInstantiation() : t.typeParameters = null, this.finishNode(t, \"InterfaceExtends\");\n          }, s.flowParseInterface = function (t) {\n            return this.flowParseInterfaceish(t), this.finishNode(t, \"InterfaceDeclaration\");\n          }, s.checkNotUnderscore = function (t) {\n            if (\"_\" === t) throw this.unexpected(null, \"`_` is only allowed as a type argument to call or new\");\n          }, s.checkReservedType = function (t, e) {\n            F.indexOf(t) > -1 && this.raise(e, \"Cannot overwrite reserved type \" + t);\n          }, s.flowParseRestrictedIdentifier = function (t) {\n            return this.checkReservedType(this.state.value, this.state.start), this.parseIdentifier(t);\n          }, s.flowParseTypeAlias = function (t) {\n            return t.id = this.flowParseRestrictedIdentifier(), this.isRelational(\"<\") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.right = this.flowParseTypeInitialiser(h.eq), this.semicolon(), this.finishNode(t, \"TypeAlias\");\n          }, s.flowParseOpaqueType = function (t, e) {\n            return this.expectContextual(\"type\"), t.id = this.flowParseRestrictedIdentifier(!0), this.isRelational(\"<\") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.supertype = null, this.match(h.colon) && (t.supertype = this.flowParseTypeInitialiser(h.colon)), t.impltype = null, e || (t.impltype = this.flowParseTypeInitialiser(h.eq)), this.semicolon(), this.finishNode(t, \"OpaqueType\");\n          }, s.flowParseTypeParameter = function (t, e) {\n            if (void 0 === t && (t = !0), void 0 === e && (e = !1), !t && e) throw new Error(\"Cannot disallow a default value (`allowDefault`) while also requiring it (`requireDefault`).\");\n            var s = this.state.start,\n                i = this.startNode(),\n                r = this.flowParseVariance(),\n                a = this.flowParseTypeAnnotatableIdentifier();\n            return i.name = a.name, i.variance = r, i.bound = a.typeAnnotation, this.match(h.eq) ? t ? (this.eat(h.eq), i.default = this.flowParseType()) : this.unexpected() : e && this.unexpected(s, \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\"), this.finishNode(i, \"TypeParameter\");\n          }, s.flowParseTypeParameterDeclaration = function (t) {\n            void 0 === t && (t = !0);\n            var e = this.state.inType,\n                s = this.startNode();\n            s.params = [], this.state.inType = !0, this.isRelational(\"<\") || this.match(h.jsxTagStart) ? this.next() : this.unexpected();\n            var i = !1;\n\n            do {\n              var r = this.flowParseTypeParameter(t, i);\n              s.params.push(r), r.default && (i = !0), this.isRelational(\">\") || this.expect(h.comma);\n            } while (!this.isRelational(\">\"));\n\n            return this.expectRelational(\">\"), this.state.inType = e, this.finishNode(s, \"TypeParameterDeclaration\");\n          }, s.flowParseTypeParameterInstantiation = function () {\n            var t = this.startNode(),\n                e = this.state.inType;\n            t.params = [], this.state.inType = !0, this.expectRelational(\"<\");\n            var s = this.state.noAnonFunctionType;\n\n            for (this.state.noAnonFunctionType = !1; !this.isRelational(\">\");) {\n              t.params.push(this.flowParseType()), this.isRelational(\">\") || this.expect(h.comma);\n            }\n\n            return this.state.noAnonFunctionType = s, this.expectRelational(\">\"), this.state.inType = e, this.finishNode(t, \"TypeParameterInstantiation\");\n          }, s.flowParseTypeParameterInstantiationCallOrNew = function () {\n            var t = this.startNode(),\n                e = this.state.inType;\n\n            for (t.params = [], this.state.inType = !0, this.expectRelational(\"<\"); !this.isRelational(\">\");) {\n              t.params.push(this.flowParseTypeOrImplicitInstantiation()), this.isRelational(\">\") || this.expect(h.comma);\n            }\n\n            return this.expectRelational(\">\"), this.state.inType = e, this.finishNode(t, \"TypeParameterInstantiation\");\n          }, s.flowParseInterfaceType = function () {\n            var t = this.startNode();\n            if (this.expectContextual(\"interface\"), t.extends = [], this.eat(h._extends)) do {\n              t.extends.push(this.flowParseInterfaceExtends());\n            } while (this.eat(h.comma));\n            return t.body = this.flowParseObjectType({\n              allowStatic: !1,\n              allowExact: !1,\n              allowSpread: !1,\n              allowProto: !1,\n              allowInexact: !1\n            }), this.finishNode(t, \"InterfaceTypeAnnotation\");\n          }, s.flowParseObjectPropertyKey = function () {\n            return this.match(h.num) || this.match(h.string) ? this.parseExprAtom() : this.parseIdentifier(!0);\n          }, s.flowParseObjectTypeIndexer = function (t, e, s) {\n            return t.static = e, this.lookahead().type === h.colon ? (t.id = this.flowParseObjectPropertyKey(), t.key = this.flowParseTypeInitialiser()) : (t.id = null, t.key = this.flowParseType()), this.expect(h.bracketR), t.value = this.flowParseTypeInitialiser(), t.variance = s, this.finishNode(t, \"ObjectTypeIndexer\");\n          }, s.flowParseObjectTypeInternalSlot = function (t, e) {\n            return t.static = e, t.id = this.flowParseObjectPropertyKey(), this.expect(h.bracketR), this.expect(h.bracketR), this.isRelational(\"<\") || this.match(h.parenL) ? (t.method = !0, t.optional = !1, t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start))) : (t.method = !1, this.eat(h.question) && (t.optional = !0), t.value = this.flowParseTypeInitialiser()), this.finishNode(t, \"ObjectTypeInternalSlot\");\n          }, s.flowParseObjectTypeMethodish = function (t) {\n            for (t.params = [], t.rest = null, t.typeParameters = null, this.isRelational(\"<\") && (t.typeParameters = this.flowParseTypeParameterDeclaration(!1)), this.expect(h.parenL); !this.match(h.parenR) && !this.match(h.ellipsis);) {\n              t.params.push(this.flowParseFunctionTypeParam()), this.match(h.parenR) || this.expect(h.comma);\n            }\n\n            return this.eat(h.ellipsis) && (t.rest = this.flowParseFunctionTypeParam()), this.expect(h.parenR), t.returnType = this.flowParseTypeInitialiser(), this.finishNode(t, \"FunctionTypeAnnotation\");\n          }, s.flowParseObjectTypeCallProperty = function (t, e) {\n            var s = this.startNode();\n            return t.static = e, t.value = this.flowParseObjectTypeMethodish(s), this.finishNode(t, \"ObjectTypeCallProperty\");\n          }, s.flowParseObjectType = function (t) {\n            var e = t.allowStatic,\n                s = t.allowExact,\n                i = t.allowSpread,\n                r = t.allowProto,\n                a = t.allowInexact,\n                n = this.state.inType;\n            this.state.inType = !0;\n            var o,\n                u,\n                p = this.startNode();\n            p.callProperties = [], p.properties = [], p.indexers = [], p.internalSlots = [];\n            var c = !1;\n\n            for (s && this.match(h.braceBarL) ? (this.expect(h.braceBarL), o = h.braceBarR, u = !0) : (this.expect(h.braceL), o = h.braceR, u = !1), p.exact = u; !this.match(o);) {\n              var l = !1,\n                  d = null,\n                  f = this.startNode();\n\n              if (r && this.isContextual(\"proto\")) {\n                var m = this.lookahead();\n                m.type !== h.colon && m.type !== h.question && (this.next(), d = this.state.start, e = !1);\n              }\n\n              if (e && this.isContextual(\"static\")) {\n                var y = this.lookahead();\n                y.type !== h.colon && y.type !== h.question && (this.next(), l = !0);\n              }\n\n              var D = this.flowParseVariance();\n              if (this.eat(h.bracketL)) null != d && this.unexpected(d), this.eat(h.bracketL) ? (D && this.unexpected(D.start), p.internalSlots.push(this.flowParseObjectTypeInternalSlot(f, l))) : p.indexers.push(this.flowParseObjectTypeIndexer(f, l, D));else if (this.match(h.parenL) || this.isRelational(\"<\")) null != d && this.unexpected(d), D && this.unexpected(D.start), p.callProperties.push(this.flowParseObjectTypeCallProperty(f, l));else {\n                var x = \"init\";\n\n                if (this.isContextual(\"get\") || this.isContextual(\"set\")) {\n                  var v = this.lookahead();\n                  v.type !== h.name && v.type !== h.string && v.type !== h.num || (x = this.state.value, this.next());\n                }\n\n                var P = this.flowParseObjectTypeProperty(f, l, d, D, x, i, a);\n                null === P ? c = !0 : p.properties.push(P);\n              }\n              this.flowObjectTypeSemicolon();\n            }\n\n            this.expect(o), i && (p.inexact = c);\n            var g = this.finishNode(p, \"ObjectTypeAnnotation\");\n            return this.state.inType = n, g;\n          }, s.flowParseObjectTypeProperty = function (t, e, s, i, r, a, n) {\n            if (this.match(h.ellipsis)) {\n              a || this.unexpected(null, \"Spread operator cannot appear in class or interface definitions\"), null != s && this.unexpected(s), i && this.unexpected(i.start, \"Spread properties cannot have variance\"), this.expect(h.ellipsis);\n              var o = this.eat(h.comma) || this.eat(h.semi);\n\n              if (this.match(h.braceR)) {\n                if (n) return null;\n                this.unexpected(null, \"Explicit inexact syntax is only allowed inside inexact objects\");\n              }\n\n              return this.match(h.braceBarR) && this.unexpected(null, \"Explicit inexact syntax cannot appear inside an explicit exact object type\"), o && this.unexpected(null, \"Explicit inexact syntax must appear at the end of an inexact object\"), t.argument = this.flowParseType(), this.finishNode(t, \"ObjectTypeSpreadProperty\");\n            }\n\n            t.key = this.flowParseObjectPropertyKey(), t.static = e, t.proto = null != s, t.kind = r;\n            var u = !1;\n            return this.isRelational(\"<\") || this.match(h.parenL) ? (t.method = !0, null != s && this.unexpected(s), i && this.unexpected(i.start), t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start)), \"get\" !== r && \"set\" !== r || this.flowCheckGetterSetterParams(t)) : (\"init\" !== r && this.unexpected(), t.method = !1, this.eat(h.question) && (u = !0), t.value = this.flowParseTypeInitialiser(), t.variance = i), t.optional = u, this.finishNode(t, \"ObjectTypeProperty\");\n          }, s.flowCheckGetterSetterParams = function (t) {\n            var e = \"get\" === t.kind ? 0 : 1,\n                s = t.start;\n            t.value.params.length + (t.value.rest ? 1 : 0) !== e && (\"get\" === t.kind ? this.raise(s, \"getter must not have any formal parameters\") : this.raise(s, \"setter must have exactly one formal parameter\")), \"set\" === t.kind && t.value.rest && this.raise(s, \"setter function argument must not be a rest parameter\");\n          }, s.flowObjectTypeSemicolon = function () {\n            this.eat(h.semi) || this.eat(h.comma) || this.match(h.braceR) || this.match(h.braceBarR) || this.unexpected();\n          }, s.flowParseQualifiedTypeIdentifier = function (t, e, s) {\n            t = t || this.state.start, e = e || this.state.startLoc;\n\n            for (var i = s || this.parseIdentifier(); this.eat(h.dot);) {\n              var r = this.startNodeAt(t, e);\n              r.qualification = i, r.id = this.parseIdentifier(), i = this.finishNode(r, \"QualifiedTypeIdentifier\");\n            }\n\n            return i;\n          }, s.flowParseGenericType = function (t, e, s) {\n            var i = this.startNodeAt(t, e);\n            return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(t, e, s), this.isRelational(\"<\") && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, \"GenericTypeAnnotation\");\n          }, s.flowParseTypeofType = function () {\n            var t = this.startNode();\n            return this.expect(h._typeof), t.argument = this.flowParsePrimaryType(), this.finishNode(t, \"TypeofTypeAnnotation\");\n          }, s.flowParseTupleType = function () {\n            var t = this.startNode();\n\n            for (t.types = [], this.expect(h.bracketL); this.state.pos < this.input.length && !this.match(h.bracketR) && (t.types.push(this.flowParseType()), !this.match(h.bracketR));) {\n              this.expect(h.comma);\n            }\n\n            return this.expect(h.bracketR), this.finishNode(t, \"TupleTypeAnnotation\");\n          }, s.flowParseFunctionTypeParam = function () {\n            var t = null,\n                e = !1,\n                s = null,\n                i = this.startNode(),\n                r = this.lookahead();\n            return r.type === h.colon || r.type === h.question ? (t = this.parseIdentifier(), this.eat(h.question) && (e = !0), s = this.flowParseTypeInitialiser()) : s = this.flowParseType(), i.name = t, i.optional = e, i.typeAnnotation = s, this.finishNode(i, \"FunctionTypeParam\");\n          }, s.reinterpretTypeAsFunctionTypeParam = function (t) {\n            var e = this.startNodeAt(t.start, t.loc.start);\n            return e.name = null, e.optional = !1, e.typeAnnotation = t, this.finishNode(e, \"FunctionTypeParam\");\n          }, s.flowParseFunctionTypeParams = function (t) {\n            void 0 === t && (t = []);\n\n            for (var e = null; !this.match(h.parenR) && !this.match(h.ellipsis);) {\n              t.push(this.flowParseFunctionTypeParam()), this.match(h.parenR) || this.expect(h.comma);\n            }\n\n            return this.eat(h.ellipsis) && (e = this.flowParseFunctionTypeParam()), {\n              params: t,\n              rest: e\n            };\n          }, s.flowIdentToTypeAnnotation = function (t, e, s, i) {\n            switch (i.name) {\n              case \"any\":\n                return this.finishNode(s, \"AnyTypeAnnotation\");\n\n              case \"void\":\n                return this.finishNode(s, \"VoidTypeAnnotation\");\n\n              case \"bool\":\n              case \"boolean\":\n                return this.finishNode(s, \"BooleanTypeAnnotation\");\n\n              case \"mixed\":\n                return this.finishNode(s, \"MixedTypeAnnotation\");\n\n              case \"empty\":\n                return this.finishNode(s, \"EmptyTypeAnnotation\");\n\n              case \"number\":\n                return this.finishNode(s, \"NumberTypeAnnotation\");\n\n              case \"string\":\n                return this.finishNode(s, \"StringTypeAnnotation\");\n\n              default:\n                return this.checkNotUnderscore(i.name), this.flowParseGenericType(t, e, i);\n            }\n          }, s.flowParsePrimaryType = function () {\n            var t,\n                e,\n                s = this.state.start,\n                i = this.state.startLoc,\n                r = this.startNode(),\n                a = !1,\n                n = this.state.noAnonFunctionType;\n\n            switch (this.state.type) {\n              case h.name:\n                return this.isContextual(\"interface\") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(s, i, r, this.parseIdentifier());\n\n              case h.braceL:\n                return this.flowParseObjectType({\n                  allowStatic: !1,\n                  allowExact: !1,\n                  allowSpread: !0,\n                  allowProto: !1,\n                  allowInexact: !0\n                });\n\n              case h.braceBarL:\n                return this.flowParseObjectType({\n                  allowStatic: !1,\n                  allowExact: !0,\n                  allowSpread: !0,\n                  allowProto: !1,\n                  allowInexact: !1\n                });\n\n              case h.bracketL:\n                return this.flowParseTupleType();\n\n              case h.relational:\n                if (\"<\" === this.state.value) return r.typeParameters = this.flowParseTypeParameterDeclaration(!1), this.expect(h.parenL), t = this.flowParseFunctionTypeParams(), r.params = t.params, r.rest = t.rest, this.expect(h.parenR), this.expect(h.arrow), r.returnType = this.flowParseType(), this.finishNode(r, \"FunctionTypeAnnotation\");\n                break;\n\n              case h.parenL:\n                if (this.next(), !this.match(h.parenR) && !this.match(h.ellipsis)) if (this.match(h.name)) {\n                  var o = this.lookahead().type;\n                  a = o !== h.question && o !== h.colon;\n                } else a = !0;\n\n                if (a) {\n                  if (this.state.noAnonFunctionType = !1, e = this.flowParseType(), this.state.noAnonFunctionType = n, this.state.noAnonFunctionType || !(this.match(h.comma) || this.match(h.parenR) && this.lookahead().type === h.arrow)) return this.expect(h.parenR), e;\n                  this.eat(h.comma);\n                }\n\n                return t = e ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(e)]) : this.flowParseFunctionTypeParams(), r.params = t.params, r.rest = t.rest, this.expect(h.parenR), this.expect(h.arrow), r.returnType = this.flowParseType(), r.typeParameters = null, this.finishNode(r, \"FunctionTypeAnnotation\");\n\n              case h.string:\n                return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n              case h._true:\n              case h._false:\n                return r.value = this.match(h._true), this.next(), this.finishNode(r, \"BooleanLiteralTypeAnnotation\");\n\n              case h.plusMin:\n                if (\"-\" === this.state.value) return this.next(), this.match(h.num) || this.unexpected(null, 'Unexpected token, expected \"number\"'), this.parseLiteral(-this.state.value, \"NumberLiteralTypeAnnotation\", r.start, r.loc.start);\n                this.unexpected();\n\n              case h.num:\n                return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n\n              case h._null:\n                return this.next(), this.finishNode(r, \"NullLiteralTypeAnnotation\");\n\n              case h._this:\n                return this.next(), this.finishNode(r, \"ThisTypeAnnotation\");\n\n              case h.star:\n                return this.next(), this.finishNode(r, \"ExistsTypeAnnotation\");\n\n              default:\n                if (\"typeof\" === this.state.type.keyword) return this.flowParseTypeofType();\n            }\n\n            throw this.unexpected();\n          }, s.flowParsePostfixType = function () {\n            for (var t = this.state.start, e = this.state.startLoc, s = this.flowParsePrimaryType(); !this.canInsertSemicolon() && this.match(h.bracketL);) {\n              var i = this.startNodeAt(t, e);\n              i.elementType = s, this.expect(h.bracketL), this.expect(h.bracketR), s = this.finishNode(i, \"ArrayTypeAnnotation\");\n            }\n\n            return s;\n          }, s.flowParsePrefixType = function () {\n            var t = this.startNode();\n            return this.eat(h.question) ? (t.typeAnnotation = this.flowParsePrefixType(), this.finishNode(t, \"NullableTypeAnnotation\")) : this.flowParsePostfixType();\n          }, s.flowParseAnonFunctionWithoutParens = function () {\n            var t = this.flowParsePrefixType();\n\n            if (!this.state.noAnonFunctionType && this.eat(h.arrow)) {\n              var e = this.startNodeAt(t.start, t.loc.start);\n              return e.params = [this.reinterpretTypeAsFunctionTypeParam(t)], e.rest = null, e.returnType = this.flowParseType(), e.typeParameters = null, this.finishNode(e, \"FunctionTypeAnnotation\");\n            }\n\n            return t;\n          }, s.flowParseIntersectionType = function () {\n            var t = this.startNode();\n            this.eat(h.bitwiseAND);\n            var e = this.flowParseAnonFunctionWithoutParens();\n\n            for (t.types = [e]; this.eat(h.bitwiseAND);) {\n              t.types.push(this.flowParseAnonFunctionWithoutParens());\n            }\n\n            return 1 === t.types.length ? e : this.finishNode(t, \"IntersectionTypeAnnotation\");\n          }, s.flowParseUnionType = function () {\n            var t = this.startNode();\n            this.eat(h.bitwiseOR);\n            var e = this.flowParseIntersectionType();\n\n            for (t.types = [e]; this.eat(h.bitwiseOR);) {\n              t.types.push(this.flowParseIntersectionType());\n            }\n\n            return 1 === t.types.length ? e : this.finishNode(t, \"UnionTypeAnnotation\");\n          }, s.flowParseType = function () {\n            var t = this.state.inType;\n            this.state.inType = !0;\n            var e = this.flowParseUnionType();\n            return this.state.inType = t, this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType, e;\n          }, s.flowParseTypeOrImplicitInstantiation = function () {\n            if (this.state.type === h.name && \"_\" === this.state.value) {\n              var t = this.state.start,\n                  e = this.state.startLoc,\n                  s = this.parseIdentifier();\n              return this.flowParseGenericType(t, e, s);\n            }\n\n            return this.flowParseType();\n          }, s.flowParseTypeAnnotation = function () {\n            var t = this.startNode();\n            return t.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(t, \"TypeAnnotation\");\n          }, s.flowParseTypeAnnotatableIdentifier = function (t) {\n            var e = t ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n            return this.match(h.colon) && (e.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(e, e.type)), e;\n          }, s.typeCastToParameter = function (t) {\n            return t.expression.typeAnnotation = t.typeAnnotation, this.finishNodeAt(t.expression, t.expression.type, t.typeAnnotation.end, t.typeAnnotation.loc.end);\n          }, s.flowParseVariance = function () {\n            var t = null;\n            return this.match(h.plusMin) && (t = this.startNode(), \"+\" === this.state.value ? t.kind = \"plus\" : t.kind = \"minus\", this.next(), this.finishNode(t, \"Variance\")), t;\n          }, s.parseFunctionBody = function (e, s) {\n            var i = this;\n            return s ? this.forwardNoArrowParamsConversionAt(e, function () {\n              return t.prototype.parseFunctionBody.call(i, e, !0);\n            }) : t.prototype.parseFunctionBody.call(this, e, !1);\n          }, s.parseFunctionBodyAndFinish = function (e, s, i) {\n            if (!i && this.match(h.colon)) {\n              var r = this.startNode(),\n                  a = this.flowParseTypeAndPredicateInitialiser();\n              r.typeAnnotation = a[0], e.predicate = a[1], e.returnType = r.typeAnnotation ? this.finishNode(r, \"TypeAnnotation\") : null;\n            }\n\n            t.prototype.parseFunctionBodyAndFinish.call(this, e, s, i);\n          }, s.parseStatement = function (e, s) {\n            if (this.state.strict && this.match(h.name) && \"interface\" === this.state.value) {\n              var i = this.startNode();\n              return this.next(), this.flowParseInterface(i);\n            }\n\n            var r = t.prototype.parseStatement.call(this, e, s);\n            return void 0 !== this.flowPragma || this.isValidDirective(r) || (this.flowPragma = null), r;\n          }, s.parseExpressionStatement = function (e, s) {\n            if (\"Identifier\" === s.type) if (\"declare\" === s.name) {\n              if (this.match(h._class) || this.match(h.name) || this.match(h._function) || this.match(h._var) || this.match(h._export)) return this.flowParseDeclare(e);\n            } else if (this.match(h.name)) {\n              if (\"interface\" === s.name) return this.flowParseInterface(e);\n              if (\"type\" === s.name) return this.flowParseTypeAlias(e);\n              if (\"opaque\" === s.name) return this.flowParseOpaqueType(e, !1);\n            }\n            return t.prototype.parseExpressionStatement.call(this, e, s);\n          }, s.shouldParseExportDeclaration = function () {\n            return this.isContextual(\"type\") || this.isContextual(\"interface\") || this.isContextual(\"opaque\") || t.prototype.shouldParseExportDeclaration.call(this);\n          }, s.isExportDefaultSpecifier = function () {\n            return (!this.match(h.name) || \"type\" !== this.state.value && \"interface\" !== this.state.value && \"opaque\" != this.state.value) && t.prototype.isExportDefaultSpecifier.call(this);\n          }, s.parseConditional = function (e, s, i, r, a) {\n            var n = this;\n            if (!this.match(h.question)) return e;\n\n            if (a) {\n              var o = this.state.clone();\n\n              try {\n                return t.prototype.parseConditional.call(this, e, s, i, r);\n              } catch (t) {\n                if (t instanceof SyntaxError) return this.state = o, a.start = t.pos || this.state.start, e;\n                throw t;\n              }\n            }\n\n            this.expect(h.question);\n            var u = this.state.clone(),\n                p = this.state.noArrowAt,\n                c = this.startNodeAt(i, r),\n                l = this.tryParseConditionalConsequent(),\n                d = l.consequent,\n                f = l.failed,\n                m = this.getArrowLikeExpressions(d),\n                y = m[0],\n                D = m[1];\n\n            if (f || D.length > 0) {\n              var x = p.concat();\n\n              if (D.length > 0) {\n                this.state = u, this.state.noArrowAt = x;\n\n                for (var v = 0; v < D.length; v++) {\n                  x.push(D[v].start);\n                }\n\n                var P = this.tryParseConditionalConsequent();\n                d = P.consequent, f = P.failed;\n                var g = this.getArrowLikeExpressions(d);\n                y = g[0], D = g[1];\n              }\n\n              if (f && y.length > 1 && this.raise(u.start, \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\"), f && 1 === y.length) {\n                this.state = u, this.state.noArrowAt = x.concat(y[0].start);\n                var b = this.tryParseConditionalConsequent();\n                d = b.consequent, f = b.failed;\n              }\n\n              this.getArrowLikeExpressions(d, !0);\n            }\n\n            return this.state.noArrowAt = p, this.expect(h.colon), c.test = e, c.consequent = d, c.alternate = this.forwardNoArrowParamsConversionAt(c, function () {\n              return n.parseMaybeAssign(s, void 0, void 0, void 0);\n            }), this.finishNode(c, \"ConditionalExpression\");\n          }, s.tryParseConditionalConsequent = function () {\n            this.state.noArrowParamsConversionAt.push(this.state.start);\n            var t = this.parseMaybeAssign(),\n                e = !this.match(h.colon);\n            return this.state.noArrowParamsConversionAt.pop(), {\n              consequent: t,\n              failed: e\n            };\n          }, s.getArrowLikeExpressions = function (e, s) {\n            for (var i = this, r = [e], a = []; 0 !== r.length;) {\n              var n = r.pop();\n              \"ArrowFunctionExpression\" === n.type ? (n.typeParameters || !n.returnType ? (this.toAssignableList(n.params, !0, \"arrow function parameters\"), t.prototype.checkFunctionNameAndParams.call(this, n, !0)) : a.push(n), r.push(n.body)) : \"ConditionalExpression\" === n.type && (r.push(n.consequent), r.push(n.alternate));\n            }\n\n            if (s) {\n              for (var o = 0; o < a.length; o++) {\n                this.toAssignableList(e.params, !0, \"arrow function parameters\");\n              }\n\n              return [a, []];\n            }\n\n            return function (t, e) {\n              for (var s = [], i = [], r = 0; r < t.length; r++) {\n                (e(t[r], r, t) ? s : i).push(t[r]);\n              }\n\n              return [s, i];\n            }(a, function (t) {\n              try {\n                return i.toAssignableList(t.params, !0, \"arrow function parameters\"), !0;\n              } catch (t) {\n                return !1;\n              }\n            });\n          }, s.forwardNoArrowParamsConversionAt = function (t, e) {\n            var s;\n            return -1 !== this.state.noArrowParamsConversionAt.indexOf(t.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), s = e(), this.state.noArrowParamsConversionAt.pop()) : s = e(), s;\n          }, s.parseParenItem = function (e, s, i) {\n            if (e = t.prototype.parseParenItem.call(this, e, s, i), this.eat(h.question) && (e.optional = !0), this.match(h.colon)) {\n              var r = this.startNodeAt(s, i);\n              return r.expression = e, r.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r, \"TypeCastExpression\");\n            }\n\n            return e;\n          }, s.assertModuleNodeAllowed = function (e) {\n            \"ImportDeclaration\" === e.type && (\"type\" === e.importKind || \"typeof\" === e.importKind) || \"ExportNamedDeclaration\" === e.type && \"type\" === e.exportKind || \"ExportAllDeclaration\" === e.type && \"type\" === e.exportKind || t.prototype.assertModuleNodeAllowed.call(this, e);\n          }, s.parseExport = function (e) {\n            return \"ExportNamedDeclaration\" !== (e = t.prototype.parseExport.call(this, e)).type && \"ExportAllDeclaration\" !== e.type || (e.exportKind = e.exportKind || \"value\"), e;\n          }, s.parseExportDeclaration = function (e) {\n            if (this.isContextual(\"type\")) {\n              e.exportKind = \"type\";\n              var s = this.startNode();\n              return this.next(), this.match(h.braceL) ? (e.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(e), null) : this.flowParseTypeAlias(s);\n            }\n\n            if (this.isContextual(\"opaque\")) {\n              e.exportKind = \"type\";\n              var i = this.startNode();\n              return this.next(), this.flowParseOpaqueType(i, !1);\n            }\n\n            if (this.isContextual(\"interface\")) {\n              e.exportKind = \"type\";\n              var r = this.startNode();\n              return this.next(), this.flowParseInterface(r);\n            }\n\n            return t.prototype.parseExportDeclaration.call(this, e);\n          }, s.shouldParseExportStar = function () {\n            return t.prototype.shouldParseExportStar.call(this) || this.isContextual(\"type\") && this.lookahead().type === h.star;\n          }, s.parseExportStar = function (e) {\n            return this.eatContextual(\"type\") && (e.exportKind = \"type\"), t.prototype.parseExportStar.call(this, e);\n          }, s.parseExportNamespace = function (e) {\n            return \"type\" === e.exportKind && this.unexpected(), t.prototype.parseExportNamespace.call(this, e);\n          }, s.parseClassId = function (e, s, i) {\n            t.prototype.parseClassId.call(this, e, s, i), this.isRelational(\"<\") && (e.typeParameters = this.flowParseTypeParameterDeclaration());\n          }, s.isKeyword = function (e) {\n            return (!this.state.inType || \"void\" !== e) && t.prototype.isKeyword.call(this, e);\n          }, s.readToken = function (e) {\n            var s = this.input.charCodeAt(this.state.pos + 1);\n            return !this.state.inType || 62 !== e && 60 !== e ? function (t, e) {\n              return 64 === t && 64 === e;\n            }(e, s) ? (this.state.isIterator = !0, t.prototype.readWord.call(this)) : t.prototype.readToken.call(this, e) : this.finishOp(h.relational, 1);\n          }, s.toAssignable = function (e, s, i) {\n            return \"TypeCastExpression\" === e.type ? t.prototype.toAssignable.call(this, this.typeCastToParameter(e), s, i) : t.prototype.toAssignable.call(this, e, s, i);\n          }, s.toAssignableList = function (e, s, i) {\n            for (var r = 0; r < e.length; r++) {\n              var a = e[r];\n              a && \"TypeCastExpression\" === a.type && (e[r] = this.typeCastToParameter(a));\n            }\n\n            return t.prototype.toAssignableList.call(this, e, s, i);\n          }, s.toReferencedList = function (t, e) {\n            for (var s = 0; s < t.length; s++) {\n              var i = t[s];\n              !i || \"TypeCastExpression\" !== i.type || i.extra && i.extra.parenthesized || !(t.length > 1) && e || this.raise(i.typeAnnotation.start, \"The type cast expression is expected to be wrapped with parenthesis\");\n            }\n\n            return t;\n          }, s.checkLVal = function (e, s, i, r) {\n            if (\"TypeCastExpression\" !== e.type) return t.prototype.checkLVal.call(this, e, s, i, r);\n          }, s.parseClassProperty = function (e) {\n            return this.match(h.colon) && (e.typeAnnotation = this.flowParseTypeAnnotation()), t.prototype.parseClassProperty.call(this, e);\n          }, s.parseClassPrivateProperty = function (e) {\n            return this.match(h.colon) && (e.typeAnnotation = this.flowParseTypeAnnotation()), t.prototype.parseClassPrivateProperty.call(this, e);\n          }, s.isClassMethod = function () {\n            return this.isRelational(\"<\") || t.prototype.isClassMethod.call(this);\n          }, s.isClassProperty = function () {\n            return this.match(h.colon) || t.prototype.isClassProperty.call(this);\n          }, s.isNonstaticConstructor = function (e) {\n            return !this.match(h.colon) && t.prototype.isNonstaticConstructor.call(this, e);\n          }, s.pushClassMethod = function (e, s, i, r, a) {\n            s.variance && this.unexpected(s.variance.start), delete s.variance, this.isRelational(\"<\") && (s.typeParameters = this.flowParseTypeParameterDeclaration(!1)), t.prototype.pushClassMethod.call(this, e, s, i, r, a);\n          }, s.pushClassPrivateMethod = function (e, s, i, r) {\n            s.variance && this.unexpected(s.variance.start), delete s.variance, this.isRelational(\"<\") && (s.typeParameters = this.flowParseTypeParameterDeclaration()), t.prototype.pushClassPrivateMethod.call(this, e, s, i, r);\n          }, s.parseClassSuper = function (e) {\n            if (t.prototype.parseClassSuper.call(this, e), e.superClass && this.isRelational(\"<\") && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(\"implements\")) {\n              this.next();\n              var s = e.implements = [];\n\n              do {\n                var i = this.startNode();\n                i.id = this.flowParseRestrictedIdentifier(!0), this.isRelational(\"<\") ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.typeParameters = null, s.push(this.finishNode(i, \"ClassImplements\"));\n              } while (this.eat(h.comma));\n            }\n          }, s.parsePropertyName = function (e) {\n            var s = this.flowParseVariance(),\n                i = t.prototype.parsePropertyName.call(this, e);\n            return e.variance = s, i;\n          }, s.parseObjPropValue = function (e, s, i, r, a, n, o, u) {\n            var p;\n            e.variance && this.unexpected(e.variance.start), delete e.variance, this.isRelational(\"<\") && (p = this.flowParseTypeParameterDeclaration(!1), this.match(h.parenL) || this.unexpected()), t.prototype.parseObjPropValue.call(this, e, s, i, r, a, n, o, u), p && ((e.value || e).typeParameters = p);\n          }, s.parseAssignableListItemTypes = function (t) {\n            if (this.eat(h.question)) {\n              if (\"Identifier\" !== t.type) throw this.raise(t.start, \"A binding pattern parameter cannot be optional in an implementation signature.\");\n              t.optional = !0;\n            }\n\n            return this.match(h.colon) && (t.typeAnnotation = this.flowParseTypeAnnotation()), this.finishNode(t, t.type), t;\n          }, s.parseMaybeDefault = function (e, s, i) {\n            var r = t.prototype.parseMaybeDefault.call(this, e, s, i);\n            return \"AssignmentPattern\" === r.type && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(r.typeAnnotation.start, \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\"), r;\n          }, s.shouldParseDefaultImport = function (e) {\n            return S(e) ? I(this.state) : t.prototype.shouldParseDefaultImport.call(this, e);\n          }, s.parseImportSpecifierLocal = function (t, e, s, i) {\n            e.local = S(t) ? this.flowParseRestrictedIdentifier(!0) : this.parseIdentifier(), this.checkLVal(e.local, !0, void 0, i), t.specifiers.push(this.finishNode(e, s));\n          }, s.parseImportSpecifiers = function (e) {\n            e.importKind = \"value\";\n            var s = null;\n\n            if (this.match(h._typeof) ? s = \"typeof\" : this.isContextual(\"type\") && (s = \"type\"), s) {\n              var i = this.lookahead();\n              \"type\" === s && i.type === h.star && this.unexpected(i.start), (I(i) || i.type === h.braceL || i.type === h.star) && (this.next(), e.importKind = s);\n            }\n\n            t.prototype.parseImportSpecifiers.call(this, e);\n          }, s.parseImportSpecifier = function (t) {\n            var e = this.startNode(),\n                s = this.state.start,\n                i = this.parseIdentifier(!0),\n                r = null;\n            \"type\" === i.name ? r = \"type\" : \"typeof\" === i.name && (r = \"typeof\");\n            var a = !1;\n\n            if (this.isContextual(\"as\") && !this.isLookaheadContextual(\"as\")) {\n              var n = this.parseIdentifier(!0);\n              null === r || this.match(h.name) || this.state.type.keyword ? (e.imported = i, e.importKind = null, e.local = this.parseIdentifier()) : (e.imported = n, e.importKind = r, e.local = n.__clone());\n            } else null !== r && (this.match(h.name) || this.state.type.keyword) ? (e.imported = this.parseIdentifier(!0), e.importKind = r, this.eatContextual(\"as\") ? e.local = this.parseIdentifier() : (a = !0, e.local = e.imported.__clone())) : (a = !0, e.imported = i, e.importKind = null, e.local = e.imported.__clone());\n\n            var o = S(t),\n                u = S(e);\n            o && u && this.raise(s, \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements\"), (o || u) && this.checkReservedType(e.local.name, e.local.start), !a || o || u || this.checkReservedWord(e.local.name, e.start, !0, !0), this.checkLVal(e.local, !0, void 0, \"import specifier\"), t.specifiers.push(this.finishNode(e, \"ImportSpecifier\"));\n          }, s.parseFunctionParams = function (e) {\n            var s = e.kind;\n            \"get\" !== s && \"set\" !== s && this.isRelational(\"<\") && (e.typeParameters = this.flowParseTypeParameterDeclaration(!1)), t.prototype.parseFunctionParams.call(this, e);\n          }, s.parseVarHead = function (e) {\n            t.prototype.parseVarHead.call(this, e), this.match(h.colon) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(e.id, e.id.type));\n          }, s.parseAsyncArrowFromCallExpression = function (e, s) {\n            if (this.match(h.colon)) {\n              var i = this.state.noAnonFunctionType;\n              this.state.noAnonFunctionType = !0, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;\n            }\n\n            return t.prototype.parseAsyncArrowFromCallExpression.call(this, e, s);\n          }, s.shouldParseAsyncArrow = function () {\n            return this.match(h.colon) || t.prototype.shouldParseAsyncArrow.call(this);\n          }, s.parseMaybeAssign = function (e, s, i, r) {\n            var a = this,\n                n = null;\n\n            if (this.hasPlugin(\"jsx\") && (this.match(h.jsxTagStart) || this.isRelational(\"<\"))) {\n              var o = this.state.clone();\n\n              try {\n                return t.prototype.parseMaybeAssign.call(this, e, s, i, r);\n              } catch (t) {\n                if (!(t instanceof SyntaxError)) throw t;\n                this.state = o;\n                var u = this.state.context.length;\n                this.state.context[u - 1] === D.j_oTag && (this.state.context.length -= 2), n = t;\n              }\n            }\n\n            if (null != n || this.isRelational(\"<\")) {\n              var p, c;\n\n              try {\n                c = this.flowParseTypeParameterDeclaration(), (p = this.forwardNoArrowParamsConversionAt(c, function () {\n                  return t.prototype.parseMaybeAssign.call(a, e, s, i, r);\n                })).typeParameters = c, this.resetStartLocationFromNode(p, c);\n              } catch (t) {\n                throw n || t;\n              }\n\n              if (\"ArrowFunctionExpression\" === p.type) return p;\n              if (null != n) throw n;\n              this.raise(c.start, \"Expected an arrow function after this type parameter declaration\");\n            }\n\n            return t.prototype.parseMaybeAssign.call(this, e, s, i, r);\n          }, s.parseArrow = function (e) {\n            if (this.match(h.colon)) {\n              var s = this.state.clone();\n\n              try {\n                var i = this.state.noAnonFunctionType;\n                this.state.noAnonFunctionType = !0;\n                var r = this.startNode(),\n                    a = this.flowParseTypeAndPredicateInitialiser();\n                r.typeAnnotation = a[0], e.predicate = a[1], this.state.noAnonFunctionType = i, this.canInsertSemicolon() && this.unexpected(), this.match(h.arrow) || this.unexpected(), e.returnType = r.typeAnnotation ? this.finishNode(r, \"TypeAnnotation\") : null;\n              } catch (t) {\n                if (!(t instanceof SyntaxError)) throw t;\n                this.state = s;\n              }\n            }\n\n            return t.prototype.parseArrow.call(this, e);\n          }, s.shouldParseArrow = function () {\n            return this.match(h.colon) || t.prototype.shouldParseArrow.call(this);\n          }, s.setArrowFunctionParameters = function (e, s) {\n            -1 !== this.state.noArrowParamsConversionAt.indexOf(e.start) ? e.params = s : t.prototype.setArrowFunctionParameters.call(this, e, s);\n          }, s.checkFunctionNameAndParams = function (e, s) {\n            if (!s || -1 === this.state.noArrowParamsConversionAt.indexOf(e.start)) return t.prototype.checkFunctionNameAndParams.call(this, e, s);\n          }, s.parseParenAndDistinguishExpression = function (e) {\n            return t.prototype.parseParenAndDistinguishExpression.call(this, e && -1 === this.state.noArrowAt.indexOf(this.state.start));\n          }, s.parseSubscripts = function (e, s, i, r) {\n            if (\"Identifier\" === e.type && \"async\" === e.name && -1 !== this.state.noArrowAt.indexOf(s)) {\n              this.next();\n              var a = this.startNodeAt(s, i);\n              a.callee = e, a.arguments = this.parseCallExpressionArguments(h.parenR, !1), e = this.finishNode(a, \"CallExpression\");\n            } else if (\"Identifier\" === e.type && \"async\" === e.name && this.isRelational(\"<\")) {\n              var n,\n                  o = this.state.clone();\n\n              try {\n                var u = this.parseAsyncArrowWithTypeParameters(s, i);\n                if (u) return u;\n              } catch (t) {\n                n = t;\n              }\n\n              this.state = o;\n\n              try {\n                return t.prototype.parseSubscripts.call(this, e, s, i, r);\n              } catch (t) {\n                throw n || t;\n              }\n            }\n\n            return t.prototype.parseSubscripts.call(this, e, s, i, r);\n          }, s.parseSubscript = function (e, s, i, r, a) {\n            if (this.match(h.questionDot) && this.isLookaheadRelational(\"<\")) {\n              if (this.expectPlugin(\"optionalChaining\"), a.optionalChainMember = !0, r) return a.stop = !0, e;\n              this.next();\n              var n = this.startNodeAt(s, i);\n              return n.callee = e, n.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(h.parenL), n.arguments = this.parseCallExpressionArguments(h.parenR, !1), n.optional = !0, this.finishNode(n, \"OptionalCallExpression\");\n            }\n\n            if (!r && this.shouldParseTypes() && this.isRelational(\"<\")) {\n              var o = this.startNodeAt(s, i);\n              o.callee = e;\n              var u = this.state.clone();\n\n              try {\n                return o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(h.parenL), o.arguments = this.parseCallExpressionArguments(h.parenR, !1), a.optionalChainMember ? (o.optional = !1, this.finishNode(o, \"OptionalCallExpression\")) : this.finishNode(o, \"CallExpression\");\n              } catch (t) {\n                if (!(t instanceof SyntaxError)) throw t;\n                this.state = u;\n              }\n            }\n\n            return t.prototype.parseSubscript.call(this, e, s, i, r, a);\n          }, s.parseNewArguments = function (e) {\n            var s = null;\n\n            if (this.shouldParseTypes() && this.isRelational(\"<\")) {\n              var i = this.state.clone();\n\n              try {\n                s = this.flowParseTypeParameterInstantiationCallOrNew();\n              } catch (t) {\n                if (!(t instanceof SyntaxError)) throw t;\n                this.state = i;\n              }\n            }\n\n            e.typeArguments = s, t.prototype.parseNewArguments.call(this, e);\n          }, s.parseAsyncArrowWithTypeParameters = function (t, e) {\n            var s = this.startNodeAt(t, e);\n            if (this.parseFunctionParams(s), this.parseArrow(s)) return this.parseArrowExpression(s, void 0, !0);\n          }, s.readToken_mult_modulo = function (e) {\n            var s = this.input.charCodeAt(this.state.pos + 1);\n            if (42 === e && 47 === s && this.state.hasFlowComment) return this.state.hasFlowComment = !1, this.state.pos += 2, void this.nextToken();\n            t.prototype.readToken_mult_modulo.call(this, e);\n          }, s.skipBlockComment = function () {\n            return this.hasPlugin(\"flow\") && this.hasPlugin(\"flowComments\") && this.skipFlowComment() ? (this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = !0)) : this.hasPlugin(\"flow\") && this.state.hasFlowComment ? (-1 === (e = this.input.indexOf(\"*-/\", this.state.pos += 2)) && this.raise(this.state.pos - 2, \"Unterminated comment\"), void (this.state.pos = e + 3)) : void t.prototype.skipBlockComment.call(this);\n            var e;\n          }, s.skipFlowComment = function () {\n            var t = this.input.charCodeAt(this.state.pos + 2),\n                e = this.input.charCodeAt(this.state.pos + 3);\n            return 58 === t && 58 === e ? 4 : \"flow-include\" === this.input.slice(this.state.pos + 2, 14) ? 14 : 58 === t && 58 !== e && 2;\n          }, s.hasFlowCommentCompletion = function () {\n            -1 === this.input.indexOf(\"*/\", this.state.pos) && this.raise(this.state.pos, \"Unterminated comment\");\n          }, e;\n        }(t);\n      },\n      typescript: function typescript(t) {\n        return function (t) {\n          function e() {\n            return t.apply(this, arguments) || this;\n          }\n\n          i(e, t);\n          var s = e.prototype;\n          return s.tsIsIdentifier = function () {\n            return this.match(h.name);\n          }, s.tsNextTokenCanFollowModifier = function () {\n            return this.next(), !(this.hasPrecedingLineBreak() || this.match(h.parenL) || this.match(h.parenR) || this.match(h.colon) || this.match(h.eq) || this.match(h.question));\n          }, s.tsParseModifier = function (t) {\n            if (this.match(h.name)) {\n              var e = this.state.value;\n              return -1 !== t.indexOf(e) && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)) ? e : void 0;\n            }\n          }, s.tsIsListTerminator = function (t) {\n            switch (t) {\n              case \"EnumMembers\":\n              case \"TypeMembers\":\n                return this.match(h.braceR);\n\n              case \"HeritageClauseElement\":\n                return this.match(h.braceL);\n\n              case \"TupleElementTypes\":\n                return this.match(h.bracketR);\n\n              case \"TypeParametersOrArguments\":\n                return this.isRelational(\">\");\n            }\n\n            throw new Error(\"Unreachable\");\n          }, s.tsParseList = function (t, e) {\n            for (var s = []; !this.tsIsListTerminator(t);) {\n              s.push(e());\n            }\n\n            return s;\n          }, s.tsParseDelimitedList = function (t, e) {\n            return st(this.tsParseDelimitedListWorker(t, e, !0));\n          }, s.tsTryParseDelimitedList = function (t, e) {\n            return this.tsParseDelimitedListWorker(t, e, !1);\n          }, s.tsParseDelimitedListWorker = function (t, e, s) {\n            for (var i = []; !this.tsIsListTerminator(t);) {\n              var r = e();\n              if (null == r) return;\n\n              if (i.push(r), !this.eat(h.comma)) {\n                if (this.tsIsListTerminator(t)) break;\n                return void (s && this.expect(h.comma));\n              }\n            }\n\n            return i;\n          }, s.tsParseBracketedList = function (t, e, s, i) {\n            i || (s ? this.expect(h.bracketL) : this.expectRelational(\"<\"));\n            var r = this.tsParseDelimitedList(t, e);\n            return s ? this.expect(h.bracketR) : this.expectRelational(\">\"), r;\n          }, s.tsParseEntityName = function (t) {\n            for (var e = this.parseIdentifier(); this.eat(h.dot);) {\n              var s = this.startNodeAtNode(e);\n              s.left = e, s.right = this.parseIdentifier(t), e = this.finishNode(s, \"TSQualifiedName\");\n            }\n\n            return e;\n          }, s.tsParseTypeReference = function () {\n            var t = this.startNode();\n            return t.typeName = this.tsParseEntityName(!1), !this.hasPrecedingLineBreak() && this.isRelational(\"<\") && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, \"TSTypeReference\");\n          }, s.tsParseThisTypePredicate = function (t) {\n            this.next();\n            var e = this.startNode();\n            return e.parameterName = t, e.typeAnnotation = this.tsParseTypeAnnotation(!1), this.finishNode(e, \"TSTypePredicate\");\n          }, s.tsParseThisTypeNode = function () {\n            var t = this.startNode();\n            return this.next(), this.finishNode(t, \"TSThisType\");\n          }, s.tsParseTypeQuery = function () {\n            var t = this.startNode();\n            return this.expect(h._typeof), t.exprName = this.tsParseEntityName(!0), this.finishNode(t, \"TSTypeQuery\");\n          }, s.tsParseTypeParameter = function () {\n            var t = this.startNode();\n            return t.name = this.parseIdentifierName(t.start), t.constraint = this.tsEatThenParseType(h._extends), t.default = this.tsEatThenParseType(h.eq), this.finishNode(t, \"TSTypeParameter\");\n          }, s.tsTryParseTypeParameters = function () {\n            if (this.isRelational(\"<\")) return this.tsParseTypeParameters();\n          }, s.tsParseTypeParameters = function () {\n            var t = this.startNode();\n            return this.isRelational(\"<\") || this.match(h.jsxTagStart) ? this.next() : this.unexpected(), t.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this), !1, !0), this.finishNode(t, \"TSTypeParameterDeclaration\");\n          }, s.tsFillSignature = function (t, e) {\n            var s = t === h.arrow;\n            e.typeParameters = this.tsTryParseTypeParameters(), this.expect(h.parenL), e.parameters = this.tsParseBindingListForSignature(), s ? e.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t) : this.match(t) && (e.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t));\n          }, s.tsParseBindingListForSignature = function () {\n            var t = this;\n            return this.parseBindingList(h.parenR).map(function (e) {\n              if (\"Identifier\" !== e.type && \"RestElement\" !== e.type && \"ObjectPattern\" !== e.type) throw t.unexpected(e.start, \"Name in a signature must be an Identifier or ObjectPattern, instead got \" + e.type);\n              return e;\n            });\n          }, s.tsParseTypeMemberSemicolon = function () {\n            this.eat(h.comma) || this.semicolon();\n          }, s.tsParseSignatureMember = function (t) {\n            var e = this.startNode();\n            return \"TSConstructSignatureDeclaration\" === t && this.expect(h._new), this.tsFillSignature(h.colon, e), this.tsParseTypeMemberSemicolon(), this.finishNode(e, t);\n          }, s.tsIsUnambiguouslyIndexSignature = function () {\n            return this.next(), this.eat(h.name) && this.match(h.colon);\n          }, s.tsTryParseIndexSignature = function (t) {\n            if (this.match(h.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) {\n              this.expect(h.bracketL);\n              var e = this.parseIdentifier();\n              this.expect(h.colon), e.typeAnnotation = this.tsParseTypeAnnotation(!1), this.expect(h.bracketR), t.parameters = [e];\n              var s = this.tsTryParseTypeAnnotation();\n              return s && (t.typeAnnotation = s), this.tsParseTypeMemberSemicolon(), this.finishNode(t, \"TSIndexSignature\");\n            }\n          }, s.tsParsePropertyOrMethodSignature = function (t, e) {\n            this.parsePropertyName(t), this.eat(h.question) && (t.optional = !0);\n            var s = t;\n\n            if (e || !this.match(h.parenL) && !this.isRelational(\"<\")) {\n              var i = s;\n              e && (i.readonly = !0);\n              var r = this.tsTryParseTypeAnnotation();\n              return r && (i.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(i, \"TSPropertySignature\");\n            }\n\n            var a = s;\n            return this.tsFillSignature(h.colon, a), this.tsParseTypeMemberSemicolon(), this.finishNode(a, \"TSMethodSignature\");\n          }, s.tsParseTypeMember = function () {\n            if (this.match(h.parenL) || this.isRelational(\"<\")) return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\");\n            if (this.match(h._new) && this.tsLookAhead(this.tsIsStartOfConstructSignature.bind(this))) return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\");\n            var t = this.startNode(),\n                e = !!this.tsParseModifier([\"readonly\"]),\n                s = this.tsTryParseIndexSignature(t);\n            return s ? (e && (t.readonly = !0), s) : this.tsParsePropertyOrMethodSignature(t, e);\n          }, s.tsIsStartOfConstructSignature = function () {\n            return this.next(), this.match(h.parenL) || this.isRelational(\"<\");\n          }, s.tsParseTypeLiteral = function () {\n            var t = this.startNode();\n            return t.members = this.tsParseObjectTypeMembers(), this.finishNode(t, \"TSTypeLiteral\");\n          }, s.tsParseObjectTypeMembers = function () {\n            this.expect(h.braceL);\n            var t = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n            return this.expect(h.braceR), t;\n          }, s.tsIsStartOfMappedType = function () {\n            return this.next(), this.eat(h.plusMin) ? this.isContextual(\"readonly\") : (this.isContextual(\"readonly\") && this.next(), !!this.match(h.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(h._in))));\n          }, s.tsParseMappedTypeParameter = function () {\n            var t = this.startNode();\n            return t.name = this.parseIdentifierName(t.start), t.constraint = this.tsExpectThenParseType(h._in), this.finishNode(t, \"TSTypeParameter\");\n          }, s.tsParseMappedType = function () {\n            var t = this.startNode();\n            return this.expect(h.braceL), this.match(h.plusMin) ? (t.readonly = this.state.value, this.next(), this.expectContextual(\"readonly\")) : this.eatContextual(\"readonly\") && (t.readonly = !0), this.expect(h.bracketL), t.typeParameter = this.tsParseMappedTypeParameter(), this.expect(h.bracketR), this.match(h.plusMin) ? (t.optional = this.state.value, this.next(), this.expect(h.question)) : this.eat(h.question) && (t.optional = !0), t.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(h.braceR), this.finishNode(t, \"TSMappedType\");\n          }, s.tsParseTupleType = function () {\n            var t = this,\n                e = this.startNode();\n            e.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), !0, !1);\n            var s = !1;\n            return e.elementTypes.forEach(function (i, r) {\n              \"TSRestType\" === i.type ? r !== e.elementTypes.length - 1 && t.raise(i.start, \"A rest element must be last in a tuple type.\") : \"TSOptionalType\" === i.type ? s = !0 : s && t.raise(i.start, \"A required element cannot follow an optional element.\");\n            }), this.finishNode(e, \"TSTupleType\");\n          }, s.tsParseTupleElementType = function () {\n            if (this.match(h.ellipsis)) {\n              var t = this.startNode();\n              return this.next(), t.typeAnnotation = this.tsParseType(), this.finishNode(t, \"TSRestType\");\n            }\n\n            var e = this.tsParseType();\n\n            if (this.eat(h.question)) {\n              var s = this.startNodeAtNode(e);\n              return s.typeAnnotation = e, this.finishNode(s, \"TSOptionalType\");\n            }\n\n            return e;\n          }, s.tsParseParenthesizedType = function () {\n            var t = this.startNode();\n            return this.expect(h.parenL), t.typeAnnotation = this.tsParseType(), this.expect(h.parenR), this.finishNode(t, \"TSParenthesizedType\");\n          }, s.tsParseFunctionOrConstructorType = function (t) {\n            var e = this.startNode();\n            return \"TSConstructorType\" === t && this.expect(h._new), this.tsFillSignature(h.arrow, e), this.finishNode(e, t);\n          }, s.tsParseLiteralTypeNode = function () {\n            var t = this,\n                e = this.startNode();\n            return e.literal = function () {\n              switch (t.state.type) {\n                case h.num:\n                  return t.parseLiteral(t.state.value, \"NumericLiteral\");\n\n                case h.string:\n                  return t.parseLiteral(t.state.value, \"StringLiteral\");\n\n                case h._true:\n                case h._false:\n                  return t.parseBooleanLiteral();\n\n                default:\n                  throw t.unexpected();\n              }\n            }(), this.finishNode(e, \"TSLiteralType\");\n          }, s.tsParseNonArrayType = function () {\n            switch (this.state.type) {\n              case h.name:\n              case h._void:\n              case h._null:\n                var t = this.match(h._void) ? \"TSVoidKeyword\" : this.match(h._null) ? \"TSNullKeyword\" : function (t) {\n                  switch (t) {\n                    case \"any\":\n                      return \"TSAnyKeyword\";\n\n                    case \"boolean\":\n                      return \"TSBooleanKeyword\";\n\n                    case \"never\":\n                      return \"TSNeverKeyword\";\n\n                    case \"number\":\n                      return \"TSNumberKeyword\";\n\n                    case \"object\":\n                      return \"TSObjectKeyword\";\n\n                    case \"string\":\n                      return \"TSStringKeyword\";\n\n                    case \"symbol\":\n                      return \"TSSymbolKeyword\";\n\n                    case \"undefined\":\n                      return \"TSUndefinedKeyword\";\n\n                    case \"unknown\":\n                      return \"TSUnknownKeyword\";\n\n                    default:\n                      return;\n                  }\n                }(this.state.value);\n\n                if (void 0 !== t && this.lookahead().type !== h.dot) {\n                  var e = this.startNode();\n                  return this.next(), this.finishNode(e, t);\n                }\n\n                return this.tsParseTypeReference();\n\n              case h.string:\n              case h.num:\n              case h._true:\n              case h._false:\n                return this.tsParseLiteralTypeNode();\n\n              case h.plusMin:\n                if (\"-\" === this.state.value) {\n                  var s = this.startNode();\n                  if (this.next(), !this.match(h.num)) throw this.unexpected();\n                  return s.literal = this.parseLiteral(-this.state.value, \"NumericLiteral\", s.start, s.loc.start), this.finishNode(s, \"TSLiteralType\");\n                }\n\n                break;\n\n              case h._this:\n                var i = this.tsParseThisTypeNode();\n                return this.isContextual(\"is\") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(i) : i;\n\n              case h._typeof:\n                return this.tsParseTypeQuery();\n\n              case h.braceL:\n                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n\n              case h.bracketL:\n                return this.tsParseTupleType();\n\n              case h.parenL:\n                return this.tsParseParenthesizedType();\n            }\n\n            throw this.unexpected();\n          }, s.tsParseArrayTypeOrHigher = function () {\n            for (var t = this.tsParseNonArrayType(); !this.hasPrecedingLineBreak() && this.eat(h.bracketL);) {\n              if (this.match(h.bracketR)) {\n                var e = this.startNodeAtNode(t);\n                e.elementType = t, this.expect(h.bracketR), t = this.finishNode(e, \"TSArrayType\");\n              } else {\n                var s = this.startNodeAtNode(t);\n                s.objectType = t, s.indexType = this.tsParseType(), this.expect(h.bracketR), t = this.finishNode(s, \"TSIndexedAccessType\");\n              }\n            }\n\n            return t;\n          }, s.tsParseTypeOperator = function (t) {\n            var e = this.startNode();\n            return this.expectContextual(t), e.operator = t, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), this.finishNode(e, \"TSTypeOperator\");\n          }, s.tsParseInferType = function () {\n            var t = this.startNode();\n            this.expectContextual(\"infer\");\n            var e = this.startNode();\n            return e.name = this.parseIdentifierName(e.start), t.typeParameter = this.finishNode(e, \"TSTypeParameter\"), this.finishNode(t, \"TSInferType\");\n          }, s.tsParseTypeOperatorOrHigher = function () {\n            var t = this,\n                e = [\"keyof\", \"unique\"].find(function (e) {\n              return t.isContextual(e);\n            });\n            return e ? this.tsParseTypeOperator(e) : this.isContextual(\"infer\") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();\n          }, s.tsParseUnionOrIntersectionType = function (t, e, s) {\n            this.eat(s);\n            var i = e();\n\n            if (this.match(s)) {\n              for (var r = [i]; this.eat(s);) {\n                r.push(e());\n              }\n\n              var a = this.startNodeAtNode(i);\n              a.types = r, i = this.finishNode(a, t);\n            }\n\n            return i;\n          }, s.tsParseIntersectionTypeOrHigher = function () {\n            return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), h.bitwiseAND);\n          }, s.tsParseUnionTypeOrHigher = function () {\n            return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), h.bitwiseOR);\n          }, s.tsIsStartOfFunctionType = function () {\n            return !!this.isRelational(\"<\") || this.match(h.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n          }, s.tsSkipParameterStart = function () {\n            if (this.match(h.name) || this.match(h._this)) return this.next(), !0;\n\n            if (this.match(h.braceL)) {\n              var t = 1;\n\n              for (this.next(); t > 0;) {\n                this.match(h.braceL) ? ++t : this.match(h.braceR) && --t, this.next();\n              }\n\n              return !0;\n            }\n\n            return !1;\n          }, s.tsIsUnambiguouslyStartOfFunctionType = function () {\n            if (this.next(), this.match(h.parenR) || this.match(h.ellipsis)) return !0;\n\n            if (this.tsSkipParameterStart()) {\n              if (this.match(h.colon) || this.match(h.comma) || this.match(h.question) || this.match(h.eq)) return !0;\n              if (this.match(h.parenR) && (this.next(), this.match(h.arrow))) return !0;\n            }\n\n            return !1;\n          }, s.tsParseTypeOrTypePredicateAnnotation = function (t) {\n            var e = this;\n            return this.tsInType(function () {\n              var s = e.startNode();\n              e.expect(t);\n              var i = e.tsIsIdentifier() && e.tsTryParse(e.tsParseTypePredicatePrefix.bind(e));\n              if (!i) return e.tsParseTypeAnnotation(!1, s);\n              var r = e.tsParseTypeAnnotation(!1),\n                  a = e.startNodeAtNode(i);\n              return a.parameterName = i, a.typeAnnotation = r, s.typeAnnotation = e.finishNode(a, \"TSTypePredicate\"), e.finishNode(s, \"TSTypeAnnotation\");\n            });\n          }, s.tsTryParseTypeOrTypePredicateAnnotation = function () {\n            return this.match(h.colon) ? this.tsParseTypeOrTypePredicateAnnotation(h.colon) : void 0;\n          }, s.tsTryParseTypeAnnotation = function () {\n            return this.match(h.colon) ? this.tsParseTypeAnnotation() : void 0;\n          }, s.tsTryParseType = function () {\n            return this.tsEatThenParseType(h.colon);\n          }, s.tsParseTypePredicatePrefix = function () {\n            var t = this.parseIdentifier();\n            if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) return this.next(), t;\n          }, s.tsParseTypeAnnotation = function (t, e) {\n            var s = this;\n            return void 0 === t && (t = !0), void 0 === e && (e = this.startNode()), this.tsInType(function () {\n              t && s.expect(h.colon), e.typeAnnotation = s.tsParseType();\n            }), this.finishNode(e, \"TSTypeAnnotation\");\n          }, s.tsParseType = function () {\n            it(this.state.inType);\n            var t = this.tsParseNonConditionalType();\n            if (this.hasPrecedingLineBreak() || !this.eat(h._extends)) return t;\n            var e = this.startNodeAtNode(t);\n            return e.checkType = t, e.extendsType = this.tsParseNonConditionalType(), this.expect(h.question), e.trueType = this.tsParseType(), this.expect(h.colon), e.falseType = this.tsParseType(), this.finishNode(e, \"TSConditionalType\");\n          }, s.tsParseNonConditionalType = function () {\n            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType(\"TSFunctionType\") : this.match(h._new) ? this.tsParseFunctionOrConstructorType(\"TSConstructorType\") : this.tsParseUnionTypeOrHigher();\n          }, s.tsParseTypeAssertion = function () {\n            var t = this,\n                e = this.startNode();\n            return e.typeAnnotation = this.tsInType(function () {\n              return t.tsParseType();\n            }), this.expectRelational(\">\"), e.expression = this.parseMaybeUnary(), this.finishNode(e, \"TSTypeAssertion\");\n          }, s.tsParseHeritageClause = function () {\n            return this.tsParseDelimitedList(\"HeritageClauseElement\", this.tsParseExpressionWithTypeArguments.bind(this));\n          }, s.tsParseExpressionWithTypeArguments = function () {\n            var t = this.startNode();\n            return t.expression = this.tsParseEntityName(!1), this.isRelational(\"<\") && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, \"TSExpressionWithTypeArguments\");\n          }, s.tsParseInterfaceDeclaration = function (t) {\n            t.id = this.parseIdentifier(), t.typeParameters = this.tsTryParseTypeParameters(), this.eat(h._extends) && (t.extends = this.tsParseHeritageClause());\n            var e = this.startNode();\n            return e.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), t.body = this.finishNode(e, \"TSInterfaceBody\"), this.finishNode(t, \"TSInterfaceDeclaration\");\n          }, s.tsParseTypeAliasDeclaration = function (t) {\n            return t.id = this.parseIdentifier(), t.typeParameters = this.tsTryParseTypeParameters(), t.typeAnnotation = this.tsExpectThenParseType(h.eq), this.semicolon(), this.finishNode(t, \"TSTypeAliasDeclaration\");\n          }, s.tsInNoContext = function (t) {\n            var e = this.state.context;\n            this.state.context = [e[0]];\n\n            try {\n              return t();\n            } finally {\n              this.state.context = e;\n            }\n          }, s.tsInType = function (t) {\n            var e = this.state.inType;\n            this.state.inType = !0;\n\n            try {\n              return t();\n            } finally {\n              this.state.inType = e;\n            }\n          }, s.tsEatThenParseType = function (t) {\n            return this.match(t) ? this.tsNextThenParseType() : void 0;\n          }, s.tsExpectThenParseType = function (t) {\n            var e = this;\n            return this.tsDoThenParseType(function () {\n              return e.expect(t);\n            });\n          }, s.tsNextThenParseType = function () {\n            var t = this;\n            return this.tsDoThenParseType(function () {\n              return t.next();\n            });\n          }, s.tsDoThenParseType = function (t) {\n            var e = this;\n            return this.tsInType(function () {\n              return t(), e.tsParseType();\n            });\n          }, s.tsParseEnumMember = function () {\n            var t = this.startNode();\n            return t.id = this.match(h.string) ? this.parseLiteral(this.state.value, \"StringLiteral\") : this.parseIdentifier(!0), this.eat(h.eq) && (t.initializer = this.parseMaybeAssign()), this.finishNode(t, \"TSEnumMember\");\n          }, s.tsParseEnumDeclaration = function (t, e) {\n            return e && (t.const = !0), t.id = this.parseIdentifier(), this.expect(h.braceL), t.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this)), this.expect(h.braceR), this.finishNode(t, \"TSEnumDeclaration\");\n          }, s.tsParseModuleBlock = function () {\n            var t = this.startNode();\n            return this.expect(h.braceL), this.parseBlockOrModuleBlockBody(t.body = [], void 0, !0, h.braceR), this.finishNode(t, \"TSModuleBlock\");\n          }, s.tsParseModuleOrNamespaceDeclaration = function (t) {\n            if (t.id = this.parseIdentifier(), this.eat(h.dot)) {\n              var e = this.startNode();\n              this.tsParseModuleOrNamespaceDeclaration(e), t.body = e;\n            } else t.body = this.tsParseModuleBlock();\n\n            return this.finishNode(t, \"TSModuleDeclaration\");\n          }, s.tsParseAmbientExternalModuleDeclaration = function (t) {\n            return this.isContextual(\"global\") ? (t.global = !0, t.id = this.parseIdentifier()) : this.match(h.string) ? t.id = this.parseExprAtom() : this.unexpected(), this.match(h.braceL) ? t.body = this.tsParseModuleBlock() : this.semicolon(), this.finishNode(t, \"TSModuleDeclaration\");\n          }, s.tsParseImportEqualsDeclaration = function (t, e) {\n            return t.isExport = e || !1, t.id = this.parseIdentifier(), this.expect(h.eq), t.moduleReference = this.tsParseModuleReference(), this.semicolon(), this.finishNode(t, \"TSImportEqualsDeclaration\");\n          }, s.tsIsExternalModuleReference = function () {\n            return this.isContextual(\"require\") && this.lookahead().type === h.parenL;\n          }, s.tsParseModuleReference = function () {\n            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);\n          }, s.tsParseExternalModuleReference = function () {\n            var t = this.startNode();\n            if (this.expectContextual(\"require\"), this.expect(h.parenL), !this.match(h.string)) throw this.unexpected();\n            return t.expression = this.parseLiteral(this.state.value, \"StringLiteral\"), this.expect(h.parenR), this.finishNode(t, \"TSExternalModuleReference\");\n          }, s.tsLookAhead = function (t) {\n            var e = this.state.clone(),\n                s = t();\n            return this.state = e, s;\n          }, s.tsTryParseAndCatch = function (t) {\n            var e = this.state.clone();\n\n            try {\n              return t();\n            } catch (t) {\n              if (t instanceof SyntaxError) return void (this.state = e);\n              throw t;\n            }\n          }, s.tsTryParse = function (t) {\n            var e = this.state.clone(),\n                s = t();\n            return void 0 !== s && !1 !== s ? s : void (this.state = e);\n          }, s.nodeWithSamePosition = function (t, e) {\n            var s = this.startNodeAtNode(t);\n            return s.type = e, s.end = t.end, s.loc.end = t.loc.end, t.leadingComments && (s.leadingComments = t.leadingComments), t.trailingComments && (s.trailingComments = t.trailingComments), t.innerComments && (s.innerComments = t.innerComments), s;\n          }, s.tsTryParseDeclare = function (t) {\n            switch (this.state.type) {\n              case h._function:\n                return this.next(), this.parseFunction(t, !0);\n\n              case h._class:\n                return this.parseClass(t, !0, !1);\n\n              case h._const:\n                if (this.match(h._const) && this.isLookaheadContextual(\"enum\")) return this.expect(h._const), this.expectContextual(\"enum\"), this.tsParseEnumDeclaration(t, !0);\n\n              case h._var:\n              case h._let:\n                return this.parseVarStatement(t, this.state.type);\n\n              case h.name:\n                var e = this.state.value;\n                return \"global\" === e ? this.tsParseAmbientExternalModuleDeclaration(t) : this.tsParseDeclaration(t, e, !0);\n            }\n          }, s.tsTryParseExportDeclaration = function () {\n            return this.tsParseDeclaration(this.startNode(), this.state.value, !0);\n          }, s.tsParseExpressionStatement = function (t, e) {\n            switch (e.name) {\n              case \"declare\":\n                var s = this.tsTryParseDeclare(t);\n                if (s) return s.declare = !0, s;\n                break;\n\n              case \"global\":\n                if (this.match(h.braceL)) {\n                  var i = t;\n                  return i.global = !0, i.id = e, i.body = this.tsParseModuleBlock(), this.finishNode(i, \"TSModuleDeclaration\");\n                }\n\n                break;\n\n              default:\n                return this.tsParseDeclaration(t, e.name, !1);\n            }\n          }, s.tsParseDeclaration = function (t, e, s) {\n            switch (e) {\n              case \"abstract\":\n                if (s || this.match(h._class)) {\n                  var i = t;\n                  return i.abstract = !0, s && this.next(), this.parseClass(i, !0, !1);\n                }\n\n                break;\n\n              case \"enum\":\n                if (s || this.match(h.name)) return s && this.next(), this.tsParseEnumDeclaration(t, !1);\n                break;\n\n              case \"interface\":\n                if (s || this.match(h.name)) return s && this.next(), this.tsParseInterfaceDeclaration(t);\n                break;\n\n              case \"module\":\n                if (s && this.next(), this.match(h.string)) return this.tsParseAmbientExternalModuleDeclaration(t);\n                if (s || this.match(h.name)) return this.tsParseModuleOrNamespaceDeclaration(t);\n                break;\n\n              case \"namespace\":\n                if (s || this.match(h.name)) return s && this.next(), this.tsParseModuleOrNamespaceDeclaration(t);\n                break;\n\n              case \"type\":\n                if (s || this.match(h.name)) return s && this.next(), this.tsParseTypeAliasDeclaration(t);\n            }\n          }, s.tsTryParseGenericAsyncArrowFunction = function (e, s) {\n            var i = this,\n                r = this.tsTryParseAndCatch(function () {\n              var r = i.startNodeAt(e, s);\n              return r.typeParameters = i.tsParseTypeParameters(), t.prototype.parseFunctionParams.call(i, r), r.returnType = i.tsTryParseTypeOrTypePredicateAnnotation(), i.expect(h.arrow), r;\n            });\n\n            if (r) {\n              var a = this.state.inAsync,\n                  n = this.state.inGenerator;\n              return this.state.inAsync = !0, this.state.inGenerator = !1, r.id = null, r.generator = !1, r.expression = !0, r.async = !0, this.parseFunctionBody(r, !0), this.state.inAsync = a, this.state.inGenerator = n, this.finishNode(r, \"ArrowFunctionExpression\");\n            }\n          }, s.tsParseTypeArguments = function () {\n            var t = this,\n                e = this.startNode();\n            return e.params = this.tsInType(function () {\n              return t.tsInNoContext(function () {\n                return t.expectRelational(\"<\"), t.tsParseDelimitedList(\"TypeParametersOrArguments\", t.tsParseType.bind(t));\n              });\n            }), this.state.exprAllowed = !1, this.expectRelational(\">\"), this.finishNode(e, \"TSTypeParameterInstantiation\");\n          }, s.tsIsDeclarationStart = function () {\n            if (this.match(h.name)) switch (this.state.value) {\n              case \"abstract\":\n              case \"declare\":\n              case \"enum\":\n              case \"interface\":\n              case \"module\":\n              case \"namespace\":\n              case \"type\":\n                return !0;\n            }\n            return !1;\n          }, s.isExportDefaultSpecifier = function () {\n            return !this.tsIsDeclarationStart() && t.prototype.isExportDefaultSpecifier.call(this);\n          }, s.parseAssignableListItem = function (t, e) {\n            var s,\n                i = !1;\n            t && (s = this.parseAccessModifier(), i = !!this.tsParseModifier([\"readonly\"]));\n            var r = this.parseMaybeDefault();\n            this.parseAssignableListItemTypes(r);\n            var a = this.parseMaybeDefault(r.start, r.loc.start, r);\n\n            if (s || i) {\n              var n = this.startNodeAtNode(a);\n              if (e.length && (n.decorators = e), s && (n.accessibility = s), i && (n.readonly = i), \"Identifier\" !== a.type && \"AssignmentPattern\" !== a.type) throw this.raise(n.start, \"A parameter property may not be declared using a binding pattern.\");\n              return n.parameter = a, this.finishNode(n, \"TSParameterProperty\");\n            }\n\n            return e.length && (r.decorators = e), a;\n          }, s.parseFunctionBodyAndFinish = function (e, s, i) {\n            !i && this.match(h.colon) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(h.colon));\n            var r = \"FunctionDeclaration\" === s ? \"TSDeclareFunction\" : \"ClassMethod\" === s ? \"TSDeclareMethod\" : void 0;\n            r && !this.match(h.braceL) && this.isLineTerminator() ? this.finishNode(e, r) : t.prototype.parseFunctionBodyAndFinish.call(this, e, s, i);\n          }, s.parseSubscript = function (e, s, i, r, a) {\n            var n = this;\n\n            if (!this.hasPrecedingLineBreak() && this.match(h.bang)) {\n              this.state.exprAllowed = !1, this.next();\n              var o = this.startNodeAt(s, i);\n              return o.expression = e, this.finishNode(o, \"TSNonNullExpression\");\n            }\n\n            if (this.isRelational(\"<\")) {\n              var u = this.tsTryParseAndCatch(function () {\n                if (!r && n.atPossibleAsync(e)) {\n                  var t = n.tsTryParseGenericAsyncArrowFunction(s, i);\n                  if (t) return t;\n                }\n\n                var o = n.startNodeAt(s, i);\n                o.callee = e;\n                var u = n.tsParseTypeArguments();\n\n                if (u) {\n                  if (!r && n.eat(h.parenL)) return o.arguments = n.parseCallExpressionArguments(h.parenR, !1), o.typeParameters = u, n.finishCallExpression(o);\n                  if (n.match(h.backQuote)) return n.parseTaggedTemplateExpression(s, i, e, a, u);\n                }\n\n                n.unexpected();\n              });\n              if (u) return u;\n            }\n\n            return t.prototype.parseSubscript.call(this, e, s, i, r, a);\n          }, s.parseNewArguments = function (e) {\n            var s = this;\n\n            if (this.isRelational(\"<\")) {\n              var i = this.tsTryParseAndCatch(function () {\n                var t = s.tsParseTypeArguments();\n                return s.match(h.parenL) || s.unexpected(), t;\n              });\n              i && (e.typeParameters = i);\n            }\n\n            t.prototype.parseNewArguments.call(this, e);\n          }, s.parseExprOp = function (e, s, i, r, a) {\n            if (st(h._in.binop) > r && !this.hasPrecedingLineBreak() && this.isContextual(\"as\")) {\n              var n = this.startNodeAt(s, i);\n              return n.expression = e, n.typeAnnotation = this.tsNextThenParseType(), this.finishNode(n, \"TSAsExpression\"), this.parseExprOp(n, s, i, r, a);\n            }\n\n            return t.prototype.parseExprOp.call(this, e, s, i, r, a);\n          }, s.checkReservedWord = function (t, e, s, i) {}, s.checkDuplicateExports = function () {}, s.parseImport = function (e) {\n            return this.match(h.name) && this.lookahead().type === h.eq ? this.tsParseImportEqualsDeclaration(e) : t.prototype.parseImport.call(this, e);\n          }, s.parseExport = function (e) {\n            if (this.match(h._import)) return this.expect(h._import), this.tsParseImportEqualsDeclaration(e, !0);\n\n            if (this.eat(h.eq)) {\n              var s = e;\n              return s.expression = this.parseExpression(), this.semicolon(), this.finishNode(s, \"TSExportAssignment\");\n            }\n\n            if (this.eatContextual(\"as\")) {\n              var i = e;\n              return this.expectContextual(\"namespace\"), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, \"TSNamespaceExportDeclaration\");\n            }\n\n            return t.prototype.parseExport.call(this, e);\n          }, s.isAbstractClass = function () {\n            return this.isContextual(\"abstract\") && this.lookahead().type === h._class;\n          }, s.parseExportDefaultExpression = function () {\n            if (this.isAbstractClass()) {\n              var e = this.startNode();\n              return this.next(), this.parseClass(e, !0, !0), e.abstract = !0, e;\n            }\n\n            if (\"interface\" === this.state.value) {\n              var s = this.tsParseDeclaration(this.startNode(), this.state.value, !0);\n              if (s) return s;\n            }\n\n            return t.prototype.parseExportDefaultExpression.call(this);\n          }, s.parseStatementContent = function (e, s) {\n            if (this.state.type === h._const) {\n              var i = this.lookahead();\n\n              if (i.type === h.name && \"enum\" === i.value) {\n                var r = this.startNode();\n                return this.expect(h._const), this.expectContextual(\"enum\"), this.tsParseEnumDeclaration(r, !0);\n              }\n            }\n\n            return t.prototype.parseStatementContent.call(this, e, s);\n          }, s.parseAccessModifier = function () {\n            return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n          }, s.parseClassMember = function (e, s, i) {\n            var r = this.parseAccessModifier();\n            r && (s.accessibility = r), t.prototype.parseClassMember.call(this, e, s, i);\n          }, s.parseClassMemberWithIsStatic = function (e, s, i, r) {\n            var a = s,\n                n = s,\n                o = s,\n                h = !1,\n                u = !1;\n\n            switch (this.tsParseModifier([\"abstract\", \"readonly\"])) {\n              case \"readonly\":\n                u = !0, h = !!this.tsParseModifier([\"abstract\"]);\n                break;\n\n              case \"abstract\":\n                h = !0, u = !!this.tsParseModifier([\"readonly\"]);\n            }\n\n            if (h && (a.abstract = !0), u && (o.readonly = !0), !h && !r && !a.accessibility) {\n              var p = this.tsTryParseIndexSignature(s);\n              if (p) return void e.body.push(p);\n            }\n\n            if (u) return a.static = r, this.parseClassPropertyName(n), this.parsePostMemberNameModifiers(a), void this.pushClassProperty(e, n);\n            t.prototype.parseClassMemberWithIsStatic.call(this, e, s, i, r);\n          }, s.parsePostMemberNameModifiers = function (t) {\n            this.eat(h.question) && (t.optional = !0);\n          }, s.parseExpressionStatement = function (e, s) {\n            return (\"Identifier\" === s.type ? this.tsParseExpressionStatement(e, s) : void 0) || t.prototype.parseExpressionStatement.call(this, e, s);\n          }, s.shouldParseExportDeclaration = function () {\n            return !!this.tsIsDeclarationStart() || t.prototype.shouldParseExportDeclaration.call(this);\n          }, s.parseConditional = function (e, s, i, r, a) {\n            if (!a || !this.match(h.question)) return t.prototype.parseConditional.call(this, e, s, i, r, a);\n            var n = this.state.clone();\n\n            try {\n              return t.prototype.parseConditional.call(this, e, s, i, r);\n            } catch (t) {\n              if (!(t instanceof SyntaxError)) throw t;\n              return this.state = n, a.start = t.pos || this.state.start, e;\n            }\n          }, s.parseParenItem = function (e, s, i) {\n            if (e = t.prototype.parseParenItem.call(this, e, s, i), this.eat(h.question) && (e.optional = !0), this.match(h.colon)) {\n              var r = this.startNodeAt(s, i);\n              return r.expression = e, r.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r, \"TSTypeCastExpression\");\n            }\n\n            return e;\n          }, s.parseExportDeclaration = function (e) {\n            var s,\n                i = this.eatContextual(\"declare\");\n            return this.match(h.name) && (s = this.tsTryParseExportDeclaration()), s || (s = t.prototype.parseExportDeclaration.call(this, e)), s && i && (s.declare = !0), s;\n          }, s.parseClassId = function (e, s, i) {\n            if (s && !i || !this.isContextual(\"implements\")) {\n              t.prototype.parseClassId.apply(this, arguments);\n              var r = this.tsTryParseTypeParameters();\n              r && (e.typeParameters = r);\n            }\n          }, s.parseClassProperty = function (e) {\n            !e.optional && this.eat(h.bang) && (e.definite = !0);\n            var s = this.tsTryParseTypeAnnotation();\n            return s && (e.typeAnnotation = s), t.prototype.parseClassProperty.call(this, e);\n          }, s.pushClassMethod = function (e, s, i, r, a) {\n            var n = this.tsTryParseTypeParameters();\n            n && (s.typeParameters = n), t.prototype.pushClassMethod.call(this, e, s, i, r, a);\n          }, s.pushClassPrivateMethod = function (e, s, i, r) {\n            var a = this.tsTryParseTypeParameters();\n            a && (s.typeParameters = a), t.prototype.pushClassPrivateMethod.call(this, e, s, i, r);\n          }, s.parseClassSuper = function (e) {\n            t.prototype.parseClassSuper.call(this, e), e.superClass && this.isRelational(\"<\") && (e.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual(\"implements\") && (e.implements = this.tsParseHeritageClause());\n          }, s.parseObjPropValue = function (e) {\n            var s,\n                i = this.tsTryParseTypeParameters();\n            i && (e.typeParameters = i);\n\n            for (var r = arguments.length, a = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++) {\n              a[n - 1] = arguments[n];\n            }\n\n            (s = t.prototype.parseObjPropValue).call.apply(s, [this, e].concat(a));\n          }, s.parseFunctionParams = function (e, s) {\n            var i = this.tsTryParseTypeParameters();\n            i && (e.typeParameters = i), t.prototype.parseFunctionParams.call(this, e, s);\n          }, s.parseVarHead = function (e) {\n            t.prototype.parseVarHead.call(this, e), \"Identifier\" === e.id.type && this.eat(h.bang) && (e.definite = !0);\n            var s = this.tsTryParseTypeAnnotation();\n            s && (e.id.typeAnnotation = s, this.finishNode(e.id, e.id.type));\n          }, s.parseAsyncArrowFromCallExpression = function (e, s) {\n            return this.match(h.colon) && (e.returnType = this.tsParseTypeAnnotation()), t.prototype.parseAsyncArrowFromCallExpression.call(this, e, s);\n          }, s.parseMaybeAssign = function () {\n            for (var e, s, i, r, a = arguments.length, n = new Array(a), o = 0; o < a; o++) {\n              n[o] = arguments[o];\n            }\n\n            if (this.match(h.jsxTagStart)) {\n              it(this.curContext() === D.j_oTag), it(this.state.context[this.state.context.length - 2] === D.j_expr);\n              var u = this.state.clone();\n\n              try {\n                var p;\n                return (p = t.prototype.parseMaybeAssign).call.apply(p, [this].concat(n));\n              } catch (t) {\n                if (!(t instanceof SyntaxError)) throw t;\n                this.state = u, it(this.curContext() === D.j_oTag), this.state.context.pop(), it(this.curContext() === D.j_expr), this.state.context.pop(), e = t;\n              }\n            }\n\n            if (void 0 === e && !this.isRelational(\"<\")) return (s = t.prototype.parseMaybeAssign).call.apply(s, [this].concat(n));\n            var c = this.state.clone();\n\n            try {\n              var l;\n              r = this.tsParseTypeParameters(), \"ArrowFunctionExpression\" !== (i = (l = t.prototype.parseMaybeAssign).call.apply(l, [this].concat(n))).type && this.unexpected();\n            } catch (s) {\n              var d;\n              if (!(s instanceof SyntaxError)) throw s;\n              if (e) throw e;\n              return it(!this.hasPlugin(\"jsx\")), this.state = c, (d = t.prototype.parseMaybeAssign).call.apply(d, [this].concat(n));\n            }\n\n            return r && 0 !== r.params.length && this.resetStartLocationFromNode(i, r.params[0]), i.typeParameters = r, i;\n          }, s.parseMaybeUnary = function (e) {\n            return !this.hasPlugin(\"jsx\") && this.eatRelational(\"<\") ? this.tsParseTypeAssertion() : t.prototype.parseMaybeUnary.call(this, e);\n          }, s.parseArrow = function (e) {\n            if (this.match(h.colon)) {\n              var s = this.state.clone();\n\n              try {\n                var i = this.tsParseTypeOrTypePredicateAnnotation(h.colon);\n                this.canInsertSemicolon() && this.unexpected(), this.match(h.arrow) || this.unexpected(), e.returnType = i;\n              } catch (t) {\n                if (!(t instanceof SyntaxError)) throw t;\n                this.state = s;\n              }\n            }\n\n            return t.prototype.parseArrow.call(this, e);\n          }, s.parseAssignableListItemTypes = function (t) {\n            if (this.eat(h.question)) {\n              if (\"Identifier\" !== t.type) throw this.raise(t.start, \"A binding pattern parameter cannot be optional in an implementation signature.\");\n              t.optional = !0;\n            }\n\n            var e = this.tsTryParseTypeAnnotation();\n            return e && (t.typeAnnotation = e), this.finishNode(t, t.type);\n          }, s.toAssignable = function (e, s, i) {\n            switch (e.type) {\n              case \"TSTypeCastExpression\":\n                return t.prototype.toAssignable.call(this, this.typeCastToParameter(e), s, i);\n\n              case \"TSParameterProperty\":\n                return t.prototype.toAssignable.call(this, e, s, i);\n\n              case \"TSAsExpression\":\n              case \"TSNonNullExpression\":\n              case \"TSTypeAssertion\":\n                return e.expression = this.toAssignable(e.expression, s, i), e;\n\n              default:\n                return t.prototype.toAssignable.call(this, e, s, i);\n            }\n          }, s.checkLVal = function (e, s, i, r) {\n            switch (e.type) {\n              case \"TSTypeCastExpression\":\n                return;\n\n              case \"TSParameterProperty\":\n                return void this.checkLVal(e.parameter, s, i, \"parameter property\");\n\n              case \"TSAsExpression\":\n              case \"TSNonNullExpression\":\n              case \"TSTypeAssertion\":\n                return void this.checkLVal(e.expression, s, i, r);\n\n              default:\n                return void t.prototype.checkLVal.call(this, e, s, i, r);\n            }\n          }, s.parseBindingAtom = function () {\n            switch (this.state.type) {\n              case h._this:\n                return this.parseIdentifier(!0);\n\n              default:\n                return t.prototype.parseBindingAtom.call(this);\n            }\n          }, s.parseMaybeDecoratorArguments = function (e) {\n            if (this.isRelational(\"<\")) {\n              var s = this.tsParseTypeArguments();\n\n              if (this.match(h.parenL)) {\n                var i = t.prototype.parseMaybeDecoratorArguments.call(this, e);\n                return i.typeParameters = s, i;\n              }\n\n              this.unexpected(this.state.start, h.parenL);\n            }\n\n            return t.prototype.parseMaybeDecoratorArguments.call(this, e);\n          }, s.isClassMethod = function () {\n            return this.isRelational(\"<\") || t.prototype.isClassMethod.call(this);\n          }, s.isClassProperty = function () {\n            return this.match(h.bang) || this.match(h.colon) || t.prototype.isClassProperty.call(this);\n          }, s.parseMaybeDefault = function () {\n            for (var e, s = arguments.length, i = new Array(s), r = 0; r < s; r++) {\n              i[r] = arguments[r];\n            }\n\n            var a = (e = t.prototype.parseMaybeDefault).call.apply(e, [this].concat(i));\n            return \"AssignmentPattern\" === a.type && a.typeAnnotation && a.right.start < a.typeAnnotation.start && this.raise(a.typeAnnotation.start, \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\"), a;\n          }, s.readToken = function (e) {\n            return !this.state.inType || 62 !== e && 60 !== e ? t.prototype.readToken.call(this, e) : this.finishOp(h.relational, 1);\n          }, s.toAssignableList = function (e, s, i) {\n            for (var r = 0; r < e.length; r++) {\n              var a = e[r];\n              a && \"TSTypeCastExpression\" === a.type && (e[r] = this.typeCastToParameter(a));\n            }\n\n            return t.prototype.toAssignableList.call(this, e, s, i);\n          }, s.typeCastToParameter = function (t) {\n            return t.expression.typeAnnotation = t.typeAnnotation, this.finishNodeAt(t.expression, t.expression.type, t.typeAnnotation.end, t.typeAnnotation.loc.end);\n          }, s.toReferencedList = function (t, e) {\n            for (var s = 0; s < t.length; s++) {\n              var i = t[s];\n              i && i._exprListItem && \"TsTypeCastExpression\" === i.type && this.raise(i.start, \"Did not expect a type annotation here.\");\n            }\n\n            return t;\n          }, s.shouldParseArrow = function () {\n            return this.match(h.colon) || t.prototype.shouldParseArrow.call(this);\n          }, s.shouldParseAsyncArrow = function () {\n            return this.match(h.colon) || t.prototype.shouldParseAsyncArrow.call(this);\n          }, s.canHaveLeadingDecorator = function () {\n            return t.prototype.canHaveLeadingDecorator.call(this) || this.isAbstractClass();\n          }, s.jsxParseOpeningElementAfterName = function (e) {\n            var s = this,\n                i = this.tsTryParseAndCatch(function () {\n              return s.tsParseTypeArguments();\n            });\n            return i && (e.typeParameters = i), t.prototype.jsxParseOpeningElementAfterName.call(this, e);\n          }, e;\n        }(t);\n      }\n    };\n\n    function ut(t, e) {\n      var s = et;\n      return t && t.plugins && (!function (t) {\n        if (rt(t, \"decorators\")) {\n          if (rt(t, \"decorators-legacy\")) throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n          var e = at(t, \"decorators\", \"decoratorsBeforeExport\");\n          if (null == e) throw new Error(\"The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.\");\n          if (\"boolean\" != typeof e) throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n        }\n\n        if (rt(t, \"flow\") && rt(t, \"typescript\")) throw new Error(\"Cannot combine flow and typescript plugins.\");\n        if (rt(t, \"pipelineOperator\") && -1 === nt.indexOf(at(t, \"pipelineOperator\", \"proposal\"))) throw new Error(\"'pipelineOperator' requires 'proposal' option whose value should be one of: \" + nt.map(function (t) {\n          return \"'\" + t + \"'\";\n        }).join(\", \"));\n      }(t.plugins), s = function (t) {\n        var e = ot.filter(function (e) {\n          return rt(t, e);\n        }),\n            s = e.join(\"/\"),\n            i = pt[s];\n\n        if (!i) {\n          i = et;\n\n          for (var r = 0; r < e.length; r++) {\n            var a = e[r];\n            i = ht[a](i);\n          }\n\n          pt[s] = i;\n        }\n\n        return i;\n      }(t.plugins)), new s(t, e);\n    }\n\n    var pt = {};\n    e.parse = function (t, e) {\n      if (!e || \"unambiguous\" !== e.sourceType) return ut(e, t).parse();\n      e = Object.assign({}, e);\n\n      try {\n        e.sourceType = \"module\";\n        var s = ut(e, t),\n            i = s.parse();\n        return s.sawUnambiguousESM || (i.program.sourceType = \"script\"), i;\n      } catch (s) {\n        try {\n          return e.sourceType = \"script\", ut(e, t).parse();\n        } catch (t) {}\n\n        throw s;\n      }\n    }, e.parseExpression = function (t, e) {\n      var s = ut(e, t);\n      return s.options.strictMode && (s.state.strict = !0), s.getExpression();\n    }, e.tokTypes = h;\n  });\n\n  e(W);\n  var K = h;\n\n  function G(t, e) {\n    return Object.assign({\n      sourceType: \"module\",\n      allowAwaitOutsideFunction: !0,\n      allowImportExportEverywhere: !0,\n      allowReturnOutsideFunction: !0,\n      allowSuperOutsideMethod: !0,\n      plugins: [\"jsx\", \"doExpressions\", \"objectRestSpread\", \"classProperties\", \"exportDefaultFrom\", \"exportNamespaceFrom\", \"asyncGenerators\", \"functionBind\", \"functionSent\", \"dynamicImport\", \"numericSeparator\", \"importMeta\", \"optionalCatchBinding\", \"optionalChaining\", \"classPrivateProperties\", [\"pipelineOperator\", {\n        proposal: \"minimal\"\n      }], \"nullishCoalescingOperator\", \"bigInt\", \"throwExpressions\", \"logicalAssignment\", \"classPrivateMethods\"].concat(e)\n    }, t);\n  }\n\n  function X(e, s) {\n    return function (i, r, a) {\n      var n,\n          o = W,\n          h = [G({\n        strictMode: !0\n      }, [\"decorators-legacy\"].concat(s)), G({\n        strictMode: !1\n      }, [\"decorators-legacy\"].concat(s)), G({\n        strictMode: !0\n      }, [[\"decorators\", {\n        decoratorsBeforeExport: !1\n      }]].concat(s)), G({\n        strictMode: !1\n      }, [[\"decorators\", {\n        decoratorsBeforeExport: !1\n      }]].concat(s))];\n\n      try {\n        n = function (t, e) {\n          for (var s, i = 0; i < e.length; i++) {\n            try {\n              return t(e[i]);\n            } catch (t) {\n              s || (s = t);\n            }\n          }\n\n          throw s;\n        }(o[e].bind(null, i), h);\n      } catch (e) {\n        throw t(e.message.replace(/ \\(.*\\)/, \"\"), {\n          start: {\n            line: e.loc.line,\n            column: e.loc.column + 1\n          }\n        });\n      }\n\n      return delete n.tokens, V(n, Object.assign({}, a, {\n        originalText: i\n      }));\n    };\n  }\n\n  var J = X(\"parse\", [\"flow\"]),\n      H = X(\"parse\", [[\"flow\", {\n    all: !0\n  }]]),\n      z = X(\"parseExpression\");\n\n  function Q(e, s) {\n    switch (e.type) {\n      case \"ArrayExpression\":\n        return e.elements.forEach(i);\n\n      case \"ObjectExpression\":\n        return e.properties.forEach(i);\n\n      case \"ObjectProperty\":\n        if (e.computed) throw r(\"computed\");\n        if (e.shorthand) throw r(\"shorthand\");\n        return [e.key, e.value].forEach(i);\n\n      case \"UnaryExpression\":\n        switch (e.operator) {\n          case \"+\":\n          case \"-\":\n            return i(e.argument);\n\n          default:\n            throw r(\"operator\");\n        }\n\n      case \"Identifier\":\n        if (s && \"ObjectProperty\" === s.type && s.key === e) return;\n        throw r();\n\n      case \"NullLiteral\":\n      case \"BooleanLiteral\":\n      case \"NumericLiteral\":\n      case \"StringLiteral\":\n        return;\n\n      default:\n        throw r();\n    }\n\n    function i(t) {\n      return Q(t, e);\n    }\n\n    function r(s) {\n      var i = s ? \"\".concat(e.type, \" with \").concat(s, \"=\").concat(JSON.stringify(e[s])) : e.type;\n      return t(\"\".concat(i, \" is not allowed in JSON.\"), {\n        start: {\n          line: e.loc.start.line,\n          column: e.loc.start.column + 1\n        }\n      });\n    }\n  }\n\n  var $ = Object.assign({\n    parse: J,\n    astFormat: \"estree\",\n    hasPragma: K\n  }, p),\n      Y = Object.assign({}, $, {\n    parse: H\n  }),\n      Z = Object.assign({}, $, {\n    parse: z\n  });\n  return {\n    parsers: {\n      babel: $,\n      \"babel-flow\": Y,\n      babylon: $,\n      json: Object.assign({}, Z, {\n        hasPragma: function hasPragma() {\n          return !0;\n        }\n      }),\n      json5: Z,\n      \"json-stringify\": Object.assign({\n        parse: function parse(t, e, s) {\n          var i = z(t, e, s);\n          return i.comments.forEach(Q), Q(i), i;\n        },\n        astFormat: \"estree-json\"\n      }, p),\n      __js_expression: Z,\n      __vue_expression: Z,\n      __vue_event_binding: $\n    }\n  };\n});","map":null,"metadata":{},"sourceType":"script"}