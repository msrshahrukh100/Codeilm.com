{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../htmlmixed/htmlmixed\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../htmlmixed/htmlmixed\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var paramData = {\n    noEndTag: true,\n    soyState: \"param-def\"\n  };\n  var tags = {\n    \"alias\": {\n      noEndTag: true\n    },\n    \"delpackage\": {\n      noEndTag: true\n    },\n    \"namespace\": {\n      noEndTag: true,\n      soyState: \"namespace-def\"\n    },\n    \"@param\": paramData,\n    \"@param?\": paramData,\n    \"@inject\": paramData,\n    \"@inject?\": paramData,\n    \"@state\": paramData,\n    \"@state?\": paramData,\n    \"template\": {\n      soyState: \"templ-def\",\n      variableScope: true\n    },\n    \"literal\": {},\n    \"msg\": {},\n    \"fallbackmsg\": {\n      noEndTag: true,\n      reduceIndent: true\n    },\n    \"let\": {\n      soyState: \"var-def\"\n    },\n    \"if\": {},\n    \"elseif\": {\n      noEndTag: true,\n      reduceIndent: true\n    },\n    \"else\": {\n      noEndTag: true,\n      reduceIndent: true\n    },\n    \"switch\": {},\n    \"case\": {\n      noEndTag: true,\n      reduceIndent: true\n    },\n    \"default\": {\n      noEndTag: true,\n      reduceIndent: true\n    },\n    \"foreach\": {\n      variableScope: true,\n      soyState: \"var-def\"\n    },\n    \"ifempty\": {\n      noEndTag: true,\n      reduceIndent: true\n    },\n    \"for\": {\n      variableScope: true,\n      soyState: \"var-def\"\n    },\n    \"call\": {\n      soyState: \"templ-ref\"\n    },\n    \"param\": {\n      soyState: \"param-ref\"\n    },\n    \"print\": {\n      noEndTag: true\n    },\n    \"deltemplate\": {\n      soyState: \"templ-def\",\n      variableScope: true\n    },\n    \"delcall\": {\n      soyState: \"templ-ref\"\n    },\n    \"log\": {},\n    \"element\": {\n      variableScope: true\n    }\n  };\n  var indentingTags = Object.keys(tags).filter(function (tag) {\n    return !tags[tag].noEndTag || tags[tag].reduceIndent;\n  });\n  CodeMirror.defineMode(\"soy\", function (config) {\n    var textMode = CodeMirror.getMode(config, \"text/plain\");\n    var modes = {\n      html: CodeMirror.getMode(config, {\n        name: \"text/html\",\n        multilineTagIndentFactor: 2,\n        multilineTagIndentPastTag: false\n      }),\n      attributes: textMode,\n      text: textMode,\n      uri: textMode,\n      trusted_resource_uri: textMode,\n      css: CodeMirror.getMode(config, \"text/css\"),\n      js: CodeMirror.getMode(config, {\n        name: \"text/javascript\",\n        statementIndent: 2 * config.indentUnit\n      })\n    };\n\n    function last(array) {\n      return array[array.length - 1];\n    }\n\n    function tokenUntil(stream, state, untilRegExp) {\n      if (stream.sol()) {\n        for (var indent = 0; indent < state.indent; indent++) {\n          if (!stream.eat(/\\s/)) break;\n        }\n\n        if (indent) return null;\n      }\n\n      var oldString = stream.string;\n      var match = untilRegExp.exec(oldString.substr(stream.pos));\n\n      if (match) {\n        // We don't use backUp because it backs up just the position, not the state.\n        // This uses an undocumented API.\n        stream.string = oldString.substr(0, stream.pos + match.index);\n      }\n\n      var result = stream.hideFirstChars(state.indent, function () {\n        var localState = last(state.localStates);\n        return localState.mode.token(stream, localState.state);\n      });\n      stream.string = oldString;\n      return result;\n    }\n\n    function contains(list, element) {\n      while (list) {\n        if (list.element === element) return true;\n        list = list.next;\n      }\n\n      return false;\n    }\n\n    function prepend(list, element) {\n      return {\n        element: element,\n        next: list\n      };\n    }\n\n    function popcontext(state) {\n      if (!state.context) return;\n\n      if (state.context.scope) {\n        state.variables = state.context.scope;\n      }\n\n      state.context = state.context.previousContext;\n    } // Reference a variable `name` in `list`.\n    // Let `loose` be truthy to ignore missing identifiers.\n\n\n    function ref(list, name, loose) {\n      return contains(list, name) ? \"variable-2\" : loose ? \"variable\" : \"variable-2 error\";\n    } // Data for an open soy tag.\n\n\n    function Context(previousContext, tag, scope) {\n      this.previousContext = previousContext;\n      this.tag = tag;\n      this.kind = null;\n      this.scope = scope;\n    }\n\n    return {\n      startState: function startState() {\n        return {\n          soyState: [],\n          templates: null,\n          variables: prepend(null, 'ij'),\n          scopes: null,\n          indent: 0,\n          quoteKind: null,\n          context: null,\n          localStates: [{\n            mode: modes.html,\n            state: CodeMirror.startState(modes.html)\n          }]\n        };\n      },\n      copyState: function copyState(state) {\n        return {\n          tag: state.tag,\n          // Last seen Soy tag.\n          soyState: state.soyState.concat([]),\n          templates: state.templates,\n          variables: state.variables,\n          context: state.context,\n          indent: state.indent,\n          // Indentation of the following line.\n          quoteKind: state.quoteKind,\n          localStates: state.localStates.map(function (localState) {\n            return {\n              mode: localState.mode,\n              state: CodeMirror.copyState(localState.mode, localState.state)\n            };\n          })\n        };\n      },\n      token: function token(stream, state) {\n        var match;\n\n        switch (last(state.soyState)) {\n          case \"comment\":\n            if (stream.match(/^.*?\\*\\//)) {\n              state.soyState.pop();\n            } else {\n              stream.skipToEnd();\n            }\n\n            if (!state.context || !state.context.scope) {\n              var paramRe = /@param\\??\\s+(\\S+)/g;\n              var current = stream.current();\n\n              for (var match; match = paramRe.exec(current);) {\n                state.variables = prepend(state.variables, match[1]);\n              }\n            }\n\n            return \"comment\";\n\n          case \"string\":\n            var match = stream.match(/^.*?([\"']|\\\\[\\s\\S])/);\n\n            if (!match) {\n              stream.skipToEnd();\n            } else if (match[1] == state.quoteKind) {\n              state.quoteKind = null;\n              state.soyState.pop();\n            }\n\n            return \"string\";\n        }\n\n        if (!state.soyState.length || last(state.soyState) != \"literal\") {\n          if (stream.match(/^\\/\\*/)) {\n            state.soyState.push(\"comment\");\n            return \"comment\";\n          } else if (stream.match(stream.sol() ? /^\\s*\\/\\/.*/ : /^\\s+\\/\\/.*/)) {\n            return \"comment\";\n          }\n        }\n\n        switch (last(state.soyState)) {\n          case \"templ-def\":\n            if (match = stream.match(/^\\.?([\\w]+(?!\\.[\\w]+)*)/)) {\n              state.templates = prepend(state.templates, match[1]);\n              state.soyState.pop();\n              return \"def\";\n            }\n\n            stream.next();\n            return null;\n\n          case \"templ-ref\":\n            if (match = stream.match(/(\\.?[a-zA-Z_][a-zA-Z_0-9]+)+/)) {\n              state.soyState.pop(); // If the first character is '.', it can only be a local template.\n\n              if (match[0][0] == '.') {\n                return \"variable-2\";\n              } // Otherwise\n\n\n              return \"variable\";\n            }\n\n            stream.next();\n            return null;\n\n          case \"namespace-def\":\n            if (match = stream.match(/^\\.?([\\w\\.]+)/)) {\n              state.soyState.pop();\n              return \"variable\";\n            }\n\n            stream.next();\n            return null;\n\n          case \"param-def\":\n            if (match = stream.match(/^\\w+/)) {\n              state.variables = prepend(state.variables, match[0]);\n              state.soyState.pop();\n              state.soyState.push(\"param-type\");\n              return \"def\";\n            }\n\n            stream.next();\n            return null;\n\n          case \"param-ref\":\n            if (match = stream.match(/^\\w+/)) {\n              state.soyState.pop();\n              return \"property\";\n            }\n\n            stream.next();\n            return null;\n\n          case \"param-type\":\n            if (stream.peek() == \"}\") {\n              state.soyState.pop();\n              return null;\n            }\n\n            if (stream.eatWhile(/^([\\w]+|[?])/)) {\n              return \"type\";\n            }\n\n            stream.next();\n            return null;\n\n          case \"var-def\":\n            if (match = stream.match(/^\\$([\\w]+)/)) {\n              state.variables = prepend(state.variables, match[1]);\n              state.soyState.pop();\n              return \"def\";\n            }\n\n            stream.next();\n            return null;\n\n          case \"tag\":\n            var endTag = state.tag[0] == \"/\";\n            var tagName = endTag ? state.tag.substring(1) : state.tag;\n            var tag = tags[tagName];\n\n            if (stream.match(/^\\/?}/)) {\n              var selfClosed = stream.current() == \"/}\";\n\n              if (selfClosed && !endTag) {\n                popcontext(state);\n              }\n\n              if (state.tag == \"/template\" || state.tag == \"/deltemplate\") {\n                state.variables = prepend(null, 'ij');\n                state.indent = 0;\n              } else {\n                state.indent -= config.indentUnit * (selfClosed || indentingTags.indexOf(state.tag) == -1 ? 2 : 1);\n              }\n\n              state.soyState.pop();\n              return \"keyword\";\n            } else if (stream.match(/^([\\w?]+)(?==)/)) {\n              if (stream.current() == \"kind\" && (match = stream.match(/^=\"([^\"]+)/, false))) {\n                var kind = match[1];\n                state.context.kind = kind;\n                var mode = modes[kind] || modes.html;\n                var localState = last(state.localStates);\n\n                if (localState.mode.indent) {\n                  state.indent += localState.mode.indent(localState.state, \"\", \"\");\n                }\n\n                state.localStates.push({\n                  mode: mode,\n                  state: CodeMirror.startState(mode)\n                });\n              }\n\n              return \"attribute\";\n            } else if (match = stream.match(/([\\w]+)(?=\\()/)) {\n              return \"variable callee\";\n            } else if (match = stream.match(/^[\"']/)) {\n              state.soyState.push(\"string\");\n              state.quoteKind = match;\n              return \"string\";\n            }\n\n            if (stream.match(/(null|true|false)(?!\\w)/) || stream.match(/0x([0-9a-fA-F]{2,})/) || stream.match(/-?([0-9]*[.])?[0-9]+(e[0-9]*)?/)) {\n              return \"atom\";\n            }\n\n            if (stream.match(/(\\||[+\\-*\\/%]|[=!]=|\\?:|[<>]=?)/)) {\n              // Tokenize filter, binary, null propagator, and equality operators.\n              return \"operator\";\n            }\n\n            if (match = stream.match(/^\\$([\\w]+)/)) {\n              return ref(state.variables, match[1]);\n            }\n\n            if (match = stream.match(/^\\w+/)) {\n              return /^(?:as|and|or|not|in)$/.test(match[0]) ? \"keyword\" : null;\n            }\n\n            stream.next();\n            return null;\n\n          case \"literal\":\n            if (stream.match(/^(?=\\{\\/literal})/)) {\n              state.indent -= config.indentUnit;\n              state.soyState.pop();\n              return this.token(stream, state);\n            }\n\n            return tokenUntil(stream, state, /\\{\\/literal}/);\n        }\n\n        if (stream.match(/^\\{literal}/)) {\n          state.indent += config.indentUnit;\n          state.soyState.push(\"literal\");\n          state.context = new Context(state.context, \"literal\", state.variables);\n          return \"keyword\"; // A tag-keyword must be followed by whitespace, comment or a closing tag.\n        } else if (match = stream.match(/^\\{([/@\\\\]?\\w+\\??)(?=$|[\\s}]|\\/[/*])/)) {\n          var prevTag = state.tag;\n          state.tag = match[1];\n          var endTag = state.tag[0] == \"/\";\n          var indentingTag = !!tags[state.tag];\n          var tagName = endTag ? state.tag.substring(1) : state.tag;\n          var tag = tags[tagName];\n          if (state.tag != \"/switch\") state.indent += ((endTag || tag && tag.reduceIndent) && prevTag != \"switch\" ? 1 : 2) * config.indentUnit;\n          state.soyState.push(\"tag\");\n          var tagError = false;\n\n          if (tag) {\n            if (!endTag) {\n              if (tag.soyState) state.soyState.push(tag.soyState);\n            } // If a new tag, open a new context.\n\n\n            if (!tag.noEndTag && (indentingTag || !endTag)) {\n              state.context = new Context(state.context, state.tag, tag.variableScope ? state.variables : null); // Otherwise close the current context.\n            } else if (endTag) {\n              if (!state.context || state.context.tag != tagName) {\n                tagError = true;\n              } else if (state.context) {\n                if (state.context.kind) {\n                  state.localStates.pop();\n                  var localState = last(state.localStates);\n\n                  if (localState.mode.indent) {\n                    state.indent -= localState.mode.indent(localState.state, \"\", \"\");\n                  }\n                }\n\n                popcontext(state);\n              }\n            }\n          } else if (endTag) {\n            // Assume all tags with a closing tag are defined in the config.\n            tagError = true;\n          }\n\n          return (tagError ? \"error \" : \"\") + \"keyword\"; // Not a tag-keyword; it's an implicit print tag.\n        } else if (stream.eat('{')) {\n          state.tag = \"print\";\n          state.indent += 2 * config.indentUnit;\n          state.soyState.push(\"tag\");\n          return \"keyword\";\n        }\n\n        return tokenUntil(stream, state, /\\{|\\s+\\/\\/|\\/\\*/);\n      },\n      indent: function indent(state, textAfter, line) {\n        var indent = state.indent,\n            top = last(state.soyState);\n        if (top == \"comment\") return CodeMirror.Pass;\n\n        if (top == \"literal\") {\n          if (/^\\{\\/literal}/.test(textAfter)) indent -= config.indentUnit;\n        } else {\n          if (/^\\s*\\{\\/(template|deltemplate)\\b/.test(textAfter)) return 0;\n          if (/^\\{(\\/|(fallbackmsg|elseif|else|ifempty)\\b)/.test(textAfter)) indent -= config.indentUnit;\n          if (state.tag != \"switch\" && /^\\{(case|default)\\b/.test(textAfter)) indent -= config.indentUnit;\n          if (/^\\{\\/switch\\b/.test(textAfter)) indent -= config.indentUnit;\n        }\n\n        var localState = last(state.localStates);\n\n        if (indent && localState.mode.indent) {\n          indent += localState.mode.indent(localState.state, textAfter, line);\n        }\n\n        return indent;\n      },\n      innerMode: function innerMode(state) {\n        if (state.soyState.length && last(state.soyState) != \"literal\") return null;else return last(state.localStates);\n      },\n      electricInput: /^\\s*\\{(\\/|\\/template|\\/deltemplate|\\/switch|fallbackmsg|elseif|else|case|default|ifempty|\\/literal\\})$/,\n      lineComment: \"//\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      blockCommentContinue: \" * \",\n      useInnerComments: false,\n      fold: \"indent\"\n    };\n  }, \"htmlmixed\");\n  CodeMirror.registerHelper(\"wordChars\", \"soy\", /[\\w$]/);\n  CodeMirror.registerHelper(\"hintWords\", \"soy\", Object.keys(tags).concat([\"css\", \"debugger\"]));\n  CodeMirror.defineMIME(\"text/x-soy\", \"soy\");\n});","map":null,"metadata":{},"sourceType":"script"}