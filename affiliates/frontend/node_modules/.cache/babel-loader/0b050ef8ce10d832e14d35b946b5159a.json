{"ast":null,"code":"import e from \"codemirror\";\ne.defineMode(\"elixir\", function (e) {\n  var t,\n      n = function n(e) {\n    for (var t = {}, n = 0, r = e.length; n < r; ++n) {\n      t[e[n]] = !0;\n    }\n\n    return t;\n  },\n      r = n([\"alias\", \"case\", \"cond\", \"def\", \"defmodule\", \"defp\", \"defstruct\", \"defprotocol\", \"defimpl\", \"defmacro\", \"quote\", \"unquote\", \"receive\", \"fn\", \"do\", \"else\", \"else if\", \"end\", \"false\", \"if\", \"in\", \"next\", \"rescue\", \"for\", \"true\", \"unless\", \"when\", \"nil\", \"raise\", \"throw\", \"try\", \"catch\", \"after\", \"with\", \"require\", \"use\", \"__MODULE__\", \"__FILE__\", \"__DIR__\", \"__ENV__\", \"__CALLER__\"]),\n      o = n([\"def\", \"defmodule\", \"defp\", \"case\", \"cond\", \"rescue\", \"try\", \"catch\", \"->\"]),\n      a = n([\"end\"]),\n      i = {\n    \"[\": \"]\",\n    \"{\": \"}\",\n    \"(\": \")\"\n  },\n      u = function u(e, t, n) {\n    return n.tokenize.push(e), e(t, n);\n  },\n      f = function f(e, n) {\n    if (e.sol() && e.match('\"\"\"') && e.eol()) return n.tokenize.push(p), \"comment\";\n    if (e.eatSpace()) return null;\n    var r,\n        o = e.next();\n    if (\"'\" === o || '\"' === o) return u(d(o, \"string\", '\"' === o), e, n);\n\n    if (\"/\" === o) {\n      var a = e.current().length;\n\n      if (e.skipTo(\"/\")) {\n        var f = e.current().length,\n            l = 0;\n\n        for (e.backUp(e.current().length - a); e.current().length < f;) {\n          var c = e.next();\n          if (\"(\" === c ? l += 1 : \")\" === c && (l -= 1), l < 0) break;\n        }\n\n        if (e.backUp(e.current().length - a), 0 === l) return u(d(o, \"string-2\", !0), e, n);\n      }\n\n      return \"operator\";\n    }\n\n    if (\"%\" === o) {\n      var k = \"string\",\n          m = !0;\n      e.eat(\"s\") ? k = \"atom\" : e.eat(/[WQ]/) ? k = \"string\" : e.eat(/[r]/) ? k = \"string-2\" : e.eat(/[wxq]/) && (k = \"string\", m = !1);\n      var h = e.eat(/[^\\w\\s=]/);\n      return h ? (i.propertyIsEnumerable(h) && (h = i[h]), u(d(h, k, m, !0), e, n)) : \"operator\";\n    }\n\n    if (\"#\" === o) return e.skipToEnd(), \"comment\";\n    if (\"<\" === o && (r = e.match(/^<-?[\\`\\\"\\']?([a-zA-Z_?]\\w*)[\\`\\\"\\']?(?:;|$)/))) return u(s(r[1]), e, n);\n    if (\"0\" === o) return e.eat(\"x\") ? e.eatWhile(/[\\da-fA-F]/) : e.eat(\"b\") ? e.eatWhile(/[01]/) : e.eatWhile(/[0-7]/), \"number\";\n    if (/\\d/.test(o)) return e.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+\\-]?[\\d_]+)?/), \"number\";\n\n    if (\"?\" === o) {\n      for (; e.match(/^\\\\[CM]-/);) {\n        ;\n      }\n\n      return e.eat(\"\\\\\") ? e.eatWhile(/\\w/) : e.next(), \"string\";\n    }\n\n    return \":\" === o ? e.eat(\"'\") ? u(d(\"'\", \"atom\", !1), e, n) : e.eat('\"') ? u(d('\"', \"atom\", !0), e, n) : e.eat(/[\\<\\>]/) ? (e.eat(/[\\<\\>]/), \"atom\") : e.eat(/[\\+\\-\\*\\/\\&\\|\\:\\!]/) ? \"atom\" : e.eat(/[a-zA-Z$@_\\xa1-\\uffff]/) ? (e.eatWhile(/[\\w$\\xa1-\\uffff]/), e.eat(/[\\?\\!\\=]/), \"atom\") : \"operator\" : \"@\" === o && e.match(/^@?[a-zA-Z_\\xa1-\\uffff]/) ? (e.eat(\"@\"), e.eatWhile(/[\\w\\xa1-\\uffff]/), \"variable-2\") : \"$\" === o ? (e.eat(/[a-zA-Z_]/) ? e.eatWhile(/[\\w]/) : e.eat(/\\d/) ? e.eat(/\\d/) : e.next(), \"variable-3\") : /[a-zA-Z_\\xa1-\\uffff]/.test(o) ? (e.eatWhile(/[\\w\\xa1-\\uffff]/), e.eat(/[\\?\\!]/), e.eat(\":\") ? \"atom\" : \"ident\") : \"|\" !== o || !n.varList && \"{\" !== n.lastTok && \"do\" !== n.lastTok ? /[\\(\\)\\[\\]{}\\\\;]/.test(o) ? (t = o, null) : \"-\" === o && e.eat(\">\") ? \"arrow\" : \"|\" === o && e.eat(\">\") ? \"pipe\" : /[=+\\-\\/*:\\.^%<>~|]/.test(o) ? (\".\" !== o || e.eatWhile(/[=+\\-\\/*:\\.^%<>~|]/) || (t = \".\"), \"operator\") : null : (t = \"|\", null);\n  },\n      l = function l(e) {\n    return e || (e = 1), function (t, n) {\n      if (\"}\" === t.peek()) {\n        if (1 === e) return n.tokenize.pop(), n.tokenize[n.tokenize.length - 1](t, n);\n        n.tokenize[n.tokenize.length - 1] = l(e - 1);\n      } else \"{\" === t.peek() && (n.tokenize[n.tokenize.length - 1] = l(e + 1));\n\n      return f(t, n);\n    };\n  },\n      c = function c() {\n    var e = !1;\n    return function (t, n) {\n      return e ? (n.tokenize.pop(), n.tokenize[n.tokenize.length - 1](t, n)) : (e = !0, f(t, n));\n    };\n  },\n      d = function d(e, t, n, r) {\n    return function (o, a) {\n      var i,\n          u = !1;\n\n      for (\"read-quoted-paused\" === a.context.type && (a.context = a.context.prev, o.eat(\"}\")); null != (i = o.next());) {\n        if (i === e && (r || !u)) {\n          a.tokenize.pop();\n          break;\n        }\n\n        if (n && \"#\" === i && !u) {\n          if (o.eat(\"{\")) {\n            \"}\" === e && (a.context = {\n              prev: a.context,\n              type: \"read-quoted-paused\"\n            }), a.tokenize.push(l());\n            break;\n          }\n\n          if (/[@\\$]/.test(o.peek())) {\n            a.tokenize.push(c());\n            break;\n          }\n        }\n\n        u = !u && \"\\\\\" === i;\n      }\n\n      return t;\n    };\n  },\n      s = function s(e) {\n    return function (t, n) {\n      return t.match(e) ? n.tokenize.pop() : t.skipToEnd(), \"string\";\n    };\n  },\n      p = function p(e, t) {\n    return e.sol() && e.match('\"\"\"') && e.eol() && t.tokenize.pop(), e.skipToEnd(), \"comment\";\n  };\n\n  return {\n    startState: function startState() {\n      return {\n        tokenize: [f],\n        indented: 0,\n        context: {\n          type: \"top\",\n          indented: -e.indentUnit\n        },\n        continuedLine: !1,\n        lastTok: null,\n        varList: !1\n      };\n    },\n    token: function token(e, n) {\n      t = null;\n      var i,\n          u = n.tokenize[n.tokenize.length - 1](e, n),\n          f = t;\n\n      if (\"ident\" === u) {\n        var l = e.current();\n        u = \".\" === n.lastTok ? \"property\" : r.propertyIsEnumerable(e.current()) ? \"keyword\" : /^[A-Z]/.test(l) ? \"tag\" : \"def\" === n.lastTok || \"class\" === n.lastTok || n.varList ? \"def\" : \"variable\";\n        var c = e.column() === e.indentation();\n        \"keyword\" === u && (f = l, o.propertyIsEnumerable(l) ? i = \"indent\" : a.propertyIsEnumerable(l) ? i = \"dedent\" : \"if\" !== l && \"unless\" !== l || !c ? \"do\" === l && n.context.indented < n.indented && (i = \"indent\") : i = \"indent\");\n      }\n\n      return (t || u && \"comment\" !== u) && (n.lastTok = f), \"|\" === t && (n.varList = !n.varList), \"indent\" === i || /[\\(\\[\\{]/.test(t) ? n.context = {\n        prev: n.context,\n        type: t || u,\n        indented: n.indented\n      } : (\"dedent\" === i || /[\\)\\]\\}]/.test(t)) && n.context.prev && (n.context = n.context.prev), e.eol() && (n.continuedLine = \"\\\\\" === t || \"operator\" === u), u;\n    },\n    electricInput: /^\\s*(?:end|rescue|else if|else|catch\\})$/,\n    lineComment: \"#\"\n  };\n}), e.defineMIME(\"text/x-elixir\", \"elixir\");","map":null,"metadata":{},"sourceType":"module"}