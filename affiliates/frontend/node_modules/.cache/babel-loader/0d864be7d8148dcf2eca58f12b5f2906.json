{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n/**\n *  Copyright (c) Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  \n */\n\n/**\n * Builds an online immutable parser, designed to be used as part of a syntax\n * highlighting and code intelligence tools.\n *\n * Options:\n *\n *     eatWhitespace: (\n *       stream: Stream | CodeMirror.StringStream | CharacterStream\n *     ) => boolean\n *       Use CodeMirror API.\n *\n *     LexRules: { [name: string]: RegExp }, Includes `Punctuation`, `Comment`.\n *\n *     ParseRules: { [name: string]: Array<Rule> }, Includes `Document`.\n *\n *     editorConfig: { [name: string]: any }, Provides an editor-specific\n *       configurations set.\n *\n */\n\n\nexports.default = onlineParser;\n\nvar _Rules = require('./Rules');\n\nfunction onlineParser() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    eatWhitespace: function eatWhitespace(stream) {\n      return stream.eatWhile(_Rules.isIgnored);\n    },\n    lexRules: _Rules.LexRules,\n    parseRules: _Rules.ParseRules,\n    editorConfig: {}\n  };\n  return {\n    startState: function startState() {\n      var initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeperator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, 'Document');\n      return initialState;\n    },\n    token: function token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n\nfunction getToken(stream, state, options) {\n  var lexRules = options.lexRules,\n      parseRules = options.parseRules,\n      eatWhitespace = options.eatWhitespace,\n      editorConfig = options.editorConfig; // Restore state after an empty-rule.\n\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  } // Remember initial indentation\n\n\n  if (stream.sol()) {\n    var tabSize = editorConfig && editorConfig.tabSize || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  } // Consume spaces and ignored characters\n\n\n  if (eatWhitespace(stream)) {\n    return 'ws';\n  } // Get a matched token from the stream, using lex\n\n\n  var token = lex(lexRules, stream); // If there's no matching token, skip ahead.\n\n  if (!token) {\n    stream.match(/\\S+/);\n    pushRule(SpecialParseRules, state, 'Invalid');\n    return 'invalidchar';\n  } // If the next token is a Comment, insert a Comment parsing rule.\n\n\n  if (token.kind === 'Comment') {\n    pushRule(SpecialParseRules, state, 'Comment');\n    return 'comment';\n  } // Save state before continuing.\n\n\n  var backupState = assign({}, state); // Handle changes in expected indentation level\n\n  if (token.kind === 'Punctuation') {\n    if (/^[{([]/.test(token.value)) {\n      // Push on the stack of levels one level deeper than the current level.\n      state.levels = (state.levels || []).concat(state.indentLevel + 1);\n    } else if (/^[})\\]]/.test(token.value)) {\n      // Pop from the stack of levels.\n      // If the top of the stack is lower than the current level, lower the\n      // current level to match.\n      var levels = state.levels = (state.levels || []).slice(0, -1);\n\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n\n  while (state.rule) {\n    // If this is a forking rule, determine what rule to use based on\n    var expected = typeof state.rule === 'function' ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step]; // Seperator between list elements if necessary.\n\n    if (state.needsSeperator) {\n      expected = expected && expected.separator;\n    }\n\n    if (expected) {\n      // Un-wrap optional/list parseRules.\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      } // A string represents a Rule\n\n\n      if (typeof expected === 'string') {\n        pushRule(parseRules, state, expected);\n        continue;\n      } // Otherwise, match a Terminal.\n\n\n      if (expected.match && expected.match(token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        } // If this token was a punctuator, advance the parse rule, otherwise\n        // mark the state to be advanced before the next token. This ensures\n        // that tokens which can be appended to keep the appropriate state.\n\n\n        if (token.kind === 'Punctuation') {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n\n        return expected.style;\n      }\n    }\n\n    unsuccessful(state);\n  } // The parser does not know how to interpret this token, do not affect state.\n\n\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, 'Invalid');\n  return 'invalidchar';\n} // Utility function to assign from object to another object.\n\n\nfunction assign(to, from) {\n  var keys = Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n\n  return to;\n} // A special rule set for parsing comment tokens.\n\n\nvar SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n}; // Push a new rule onto the state.\n\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError('Unknown rule: ' + ruleKind);\n  }\n\n  state.prevState = _extends({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeperator = false;\n} // Pop the current rule from the state.\n\n\nfunction popRule(state) {\n  // Check if there's anything to pop\n  if (!state.prevState) {\n    return;\n  }\n\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeperator = state.prevState.needsSeperator;\n  state.prevState = state.prevState.prevState;\n} // Advance the step of the current rule.\n\n\nfunction advanceRule(state, successful) {\n  // If this is advancing successfully and the current state is a list, give\n  // it an opportunity to repeat itself.\n  if (isList(state)) {\n    if (state.rule && state.rule[state.step].separator) {\n      var separator = state.rule[state.step].separator;\n      state.needsSeperator = !state.needsSeperator; // If the separator was optional, then give it an opportunity to repeat.\n\n      if (!state.needsSeperator && separator.ofRule) {\n        return;\n      }\n    } // If this was a successful list parse, then allow it to repeat itself.\n\n\n    if (successful) {\n      return;\n    }\n  } // Advance the step in the rule. If the rule is completed, pop\n  // the rule and advance the parent rule as well (recursively).\n\n\n  state.needsSeperator = false;\n  state.step++; // While the current rule is completed.\n\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n\n    if (state.rule) {\n      // Do not advance a List step so it has the opportunity to repeat itself.\n      if (isList(state)) {\n        if (state.rule && state.rule[state.step].separator) {\n          state.needsSeperator = !state.needsSeperator;\n        }\n      } else {\n        state.needsSeperator = false;\n        state.step++;\n      }\n    }\n  }\n}\n\nfunction isList(state) {\n  return Array.isArray(state.rule) && typeof state.rule[state.step] !== 'string' && state.rule[state.step].isList;\n} // Unwind the state after an unsuccessful match.\n\n\nfunction unsuccessful(state) {\n  // Fall back to the parent rule until you get to an optional or list rule or\n  // until the entire stack of rules is empty.\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  } // If there is still a rule, it must be an optional or list rule.\n  // Consider this rule a success so that we may move past it.\n\n\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n} // Given a stream, returns a { kind, value } pair, or null.\n\n\nfunction lex(lexRules, stream) {\n  var kinds = Object.keys(lexRules);\n\n  for (var i = 0; i < kinds.length; i++) {\n    var match = stream.match(lexRules[kinds[i]]);\n\n    if (match && match instanceof Array) {\n      return {\n        kind: kinds[i],\n        value: match[0]\n      };\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}